{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>This site contains the documentation for the <code>olfactory-navigation</code> framework.</p> <p>This project consists in a framework that allows one to define an olfactory environment and agents to navigate this environment in order to try and find the source of an odor using exclusively its sense of smell.</p> <p>We can imagine for instance a dog attempting to find a treat in a field where the wind carries the odor towards him.</p> <p>The framework aims to allow a user to create agents using different techniques and evaluate its performance (computational and technical) during simulations on olfactory environments.</p>"},{"location":"#table-of-contents","title":"Table Of Contents","text":"<ol> <li> <p>Code Reference</p> <p>1.1 olfactory_navigation</p> </li> <li> <p>Tutorials</p> <p>2.1 What is an Environment?</p> <p>2.2 What is an Agent?</p> <p>2.3 How does a simulation work?</p> <p>2.4 What tests are available?</p> </li> </ol>"},{"location":"#pimlb","title":"PiMLb","text":"<p>This framework was built within the ERC funded project RIDING, by the PiMLb unit of the Malga lab.</p> <p> </p>"},{"location":"reference/","title":"olfactory_navigation","text":""},{"location":"reference/#olfactory_navigation.Agent","title":"<code>Agent</code>","text":"<p>A generic agent class.</p> <p>It is meant to define the general structure for an agent meant to evolve in a environment of olfactory cues. To define such agent, a set of methods need to be implemented. This methods can be seperated into 3 categories:</p> <ol> <li>Training methods</li> <li>Simulation methods</li> <li>General methods</li> </ol> <p>The training methods are meant to train the agent before testing their performance in a simulation. A single method is needed for this:</p> <ul> <li>train()</li> </ul> <p>The simulation methods are meant for the agent to make choices and receiving observations during a simulation. The following methods are required for this:</p> <ul> <li>initialize_state(): This method is meant for the state of the agent(s) to be initialized before the simulation loop starts. The state of the agent can be an internal clock, a belief or something else arbitrary.</li> <li>choose_action(): Here the agent(s) is asked to choose an action to play based on its internal state.</li> <li>update_state(): Then, after the agent(s) has taken an action, the observation it makes along with whether he reached the source or not is returned to him using this method. This allows the agent to update its internal state.</li> <li>kill(): Finally, the method asks for a set of agents to be terminated. The basic case happens when the agent reaches the source but it can also be asked to terminate if it has reached the end of the simulation without success.</li> </ul> <p>The general methods are methods to perform general actions with the agent. These methods are:</p> <ul> <li>save(): To save the agent to long term storage.</li> <li>load(): To load the agent from long term storage.</li> <li>modify_environment(): To provide an equivalent agent with a different environment linked to it. If the agent has previously been trained, the trained components needs to be adapted to this new environment.</li> <li>to_gpu(): To create an alternative version of the agent whether the array instances are stored on the GPU memory instead of the CPU memory.</li> <li>to_cpu(): To create an alternative version of the agent whether the array instances are stored on the CPU memory instead of the GPU memory.</li> </ul> <p>For a user to implement an agent, the main methods to define are the Simulation methods! The training method is, as stated, optional, as some agent definitions do not require it. And the General methods all have some default behavior and are therefore only needed to be overwritten in specific cases.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment the agent is meant to evolve in.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name for the agent. If it is not provided it will be named like \"-thresh_\". <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>saved_at</code> <code>str</code> <p>If the agent has been saved, the path at which it is saved is recorded in this variable.</p> <code>on_gpu</code> <code>bool</code> <p>Whether the arrays are on the GPU memory or not. For this, the support for Cupy needs to be enabled and the agent needs to have been moved to the GPU using the to_gpu() function.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> Source code in <code>olfactory_navigation/agent.py</code> <pre><code>class Agent:\n    '''\n    A generic agent class.\n\n    It is meant to define the general structure for an agent meant to evolve in a environment of olfactory cues.\n    To define such agent, a set of methods need to be implemented. This methods can be seperated into 3 categories:\n\n    1. Training methods\n    2. Simulation methods\n    3. General methods\n\n    The training methods are meant to train the agent before testing their performance in a simulation. A single method is needed for this:\n\n    - train()\n\n    The simulation methods are meant for the agent to make choices and receiving observations during a simulation. The following methods are required for this:\n\n    - initialize_state(): This method is meant for the state of the agent(s) to be initialized before the simulation loop starts. The state of the agent can be an internal clock, a belief or something else arbitrary.\n    - choose_action(): Here the agent(s) is asked to choose an action to play based on its internal state.\n    - update_state(): Then, after the agent(s) has taken an action, the observation it makes along with whether he reached the source or not is returned to him using this method. This allows the agent to update its internal state.\n    - kill(): Finally, the method asks for a set of agents to be terminated. The basic case happens when the agent reaches the source but it can also be asked to terminate if it has reached the end of the simulation without success.\n\n    The general methods are methods to perform general actions with the agent. These methods are:\n\n    - save(): To save the agent to long term storage.\n    - load(): To load the agent from long term storage.\n    - modify_environment(): To provide an equivalent agent with a different environment linked to it. If the agent has previously been trained, the trained components needs to be adapted to this new environment.\n    - to_gpu(): To create an alternative version of the agent whether the array instances are stored on the GPU memory instead of the CPU memory.\n    - to_cpu(): To create an alternative version of the agent whether the array instances are stored on the CPU memory instead of the GPU memory.\n\n    For a user to implement an agent, the main methods to define are the Simulation methods! The training method is, as stated, optional, as some agent definitions do not require it.\n    And the General methods all have some default behavior and are therefore only needed to be overwritten in specific cases.\n\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment the agent is meant to evolve in.\n\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name for the agent. If it is not provided it will be named like \"&lt;class_name&gt;-thresh_&lt;threshold&gt;\".\n    seed : int, default=12131415\n        For reproducible randomness.\n\n    Attributes\n    ----------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    saved_at : str\n        If the agent has been saved, the path at which it is saved is recorded in this variable.\n    on_gpu : bool\n        Whether the arrays are on the GPU memory or not. For this, the support for Cupy needs to be enabled and the agent needs to have been moved to the GPU using the to_gpu() function.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    '''\n    def __init__(self,\n                 environment: Environment,\n                 thresholds: float | list[float] | dict[str, float] | dict[str, list[float]] = 3e-6,\n                 space_aware: bool = False,\n                 spacial_subdivisions: np.ndarray | None = None,\n                 actions: dict[str, np.ndarray] | np.ndarray | None = None,\n                 name: str | None = None,\n                 seed: int = 12131415\n                 ) -&gt; None:\n        self.environment = environment\n        self.space_aware = space_aware\n\n        # Handle thresholds\n        if isinstance(thresholds, float):\n            thresholds = [thresholds]\n\n        if isinstance(thresholds, list):\n            # Ensure -inf and +inf begin and end the thresholds list\n            if -np.inf not in thresholds:\n                thresholds = [-np.inf] + thresholds\n\n            if np.inf not in thresholds:\n                thresholds = thresholds + [np.inf]\n\n            self.thresholds = np.array(thresholds)\n\n        # Handle the case where a dict of thresholds is provided in the case of a layered environment and ensuring they are ordered.\n        elif isinstance(thresholds, dict):\n            assert self.environment.has_layers, \"Thresholds can only be provided as a dict if the environment is layered.\"\n            assert len(thresholds) == len(self.environment.layer_labels), \"Thresholds must be given for each layers.\"\n\n            if all(isinstance(layer_thresholds, list) for layer_thresholds in thresholds.values()):\n                layer_thresholds_count = len(thresholds.values()[0])\n                assert all(len(layer_thresholds) == layer_thresholds_count for layer_thresholds in thresholds.values()), \"If provided as lists, the threshold lists must all be of the same length.\"\n            else:\n                assert all(isinstance(layer_threshold, float) for layer_threshold in thresholds.values()), \"The thresholds provided in a dictionary must all be list or float, not a combination of both.\"\n\n            # Processing layers of thresholds\n            layer_thresholds_list = []\n            for layer_label in enumerate(self.environment.layer_labels):\n                assert layer_label in thresholds, f\"Environment's layer [{layer_label}] was not matched to any layers of the environment.\"\n                layer_thresholds = thresholds[layer_label]\n\n                if not isinstance(layer_thresholds, list):\n                    layer_thresholds = [layer_thresholds]\n\n                # Ensure -inf and +inf begin and end the thresholds list\n                if -np.inf not in layer_thresholds:\n                    layer_thresholds = [-np.inf] + layer_thresholds\n\n                if np.inf not in layer_thresholds:\n                    layer_thresholds = layer_thresholds + [np.inf]\n\n                layer_thresholds_list.append(layer_thresholds)\n\n            # Building an array with the layers of thresholds\n            self.thresholds = np.array(layer_thresholds_list)\n\n        # Ensuring the thresholds are in ascending order\n        self.thresholds.sort()\n\n        # Spacial subdivisions\n        if spacial_subdivisions is None:\n            self.spacial_subdivisions = np.array(self.environment.shape)\n        else:\n            self.spacial_subdivisions = np.array(spacial_subdivisions)\n        assert len(self.spacial_subdivisions) == self.environment.dimensions, \"The amount of spacial divisions must match the amount of dimensions of the environment.\"\n\n        # Mapping environment to spacial subdivisions\n        env_shape = np.array(self.environment.shape)\n\n        std_size = (env_shape / self.spacial_subdivisions).astype(int)\n        overflows = (env_shape % self.spacial_subdivisions)\n\n        cell_sizes = [(np.repeat(size, partitions) + np.array([np.floor(overflow / 2), *np.zeros(partitions-2), np.ceil(overflow / 2)])).astype(int)\n                    for partitions, size, overflow in zip(self.spacial_subdivisions, std_size, overflows)]\n\n        # Finding the edges of the cells and filling a grid with ids\n        cell_edges = [np.concatenate(([0], np.cumsum(ax_sizes))) for ax_sizes in cell_sizes]\n\n        lower_bounds = np.array([ax_arr.ravel() for ax_arr in np.meshgrid(*[bounds_arr[:-1] for bounds_arr in cell_edges], indexing='ij')]).T\n        upper_bounds = np.array([ax_arr.ravel() for ax_arr in np.meshgrid(*[bounds_arr[1 :] for bounds_arr in cell_edges], indexing='ij')]).T\n\n        self._environment_to_subdivision_mapping = np.full(self.environment.shape, -1)\n        for i, (lower_b, upper_b) in enumerate(zip(lower_bounds, upper_bounds)):\n            slices = [slice(ax_lower, ax_upper) for ax_lower, ax_upper in zip(lower_b, upper_b)]\n\n            # Grid to cell mapping\n            self._environment_to_subdivision_mapping[*slices] = i\n\n        # Allowed actions\n        self.action_labels = None\n        if actions is None:\n            if environment.dimensions == 2:\n                self.action_set = np.array([\n                    [-1,  0], # North\n                    [ 0,  1], # East\n                    [ 1,  0], # South\n                    [ 0, -1]  # West\n                ])\n                self.action_labels = [\n                    'North',\n                    'East',\n                    'South',\n                    'West'\n                ]\n            elif environment.dimensions == 3:\n                self.action_set = np.array([\n                    [ 0, -1,  0], # North\n                    [ 0,  0,  1], # East\n                    [ 0,  1,  0], # South\n                    [ 0,  0, -1], # West\n                    [ 1,  0,  0], # Up\n                    [-1,  0,  0]  # Down\n                ])\n                self.action_labels = [\n                    'North',\n                    'East',\n                    'South',\n                    'West',\n                    'Up',\n                    'Down'\n                ]\n            else: # ND\n                self.action_set = np.zeros((2*environment.dimensions, environment.dimensions))\n                self.action_labels = []\n                for dim in range(environment.dimensions):\n                    # Increase in dimension 'dim'\n                    self.action_set[dim*2, -dim-1] = 1\n                    self.action_labels.append(f'd{dim}+1')\n\n                    # Decrease in dimension 'dim'\n                    self.action_set[(dim*2) + 1, -dim-1] = -1\n                    self.action_labels.append(f'd{dim}-1')\n\n            # Layered\n            if environment.has_layers:\n                self.action_set = np.array([[layer, *action_vector] for layer in environment.layers for action_vector in self.action_set])\n                self.action_labels = [f'l_{layer}_{action}' for  layer in environment.layer_labels for action in self.action_labels]\n\n        # Actions provided as numpy array\n        elif isinstance(actions, np.ndarray):\n            self.action_set = actions\n            self.action_labels = ['a_' + '_'.join([str(dim_a) for dim_a in action_vector]) for action_vector in self.action_set]\n\n        # Actions provided as dict\n        else:\n            self.action_set = np.ndarray(list(actions.values()))\n            self.action_labels = list(actions.keys())\n\n        # Asertion that the shape of the actions set if right\n        layered = 0 if not environment.has_layers else 1\n        assert self.action_set.shape[1] == (layered + environment.dimensions), f\"The shape of the action_set provided is not right. (Found {self.action_set.shape}; expected (., {layered + environment.dimensions}))\"\n\n        # setup name\n        if name is None:\n            self.name = self.class_name\n            if len(self.thresholds.shape) == 2:\n                thresh_string = '-'.join(['_'.join([f'l{row_i}'] + [str(item) for item in row]) for row_i, row in enumerate(self.thresholds[:,1:-1])])\n            else:\n                thresh_string = '_'.join([str(item) for item in self.thresholds])\n            self.name += f'-tresholds-' + thresh_string\n            self.name += '-space_aware' if self.space_aware else ''\n        else:\n            self.name = name\n\n        # Other variables\n        self.saved_at = None\n\n        self.on_gpu = False\n        self._alternate_version = None\n\n        # random state\n        self.seed = seed\n        self.rnd_state = np.random.RandomState(seed = seed)\n\n\n    @property\n    def class_name(self):\n        '''\n        The name of the class of the agent.\n        '''\n        return self.__class__.__name__\n\n\n    # ----------------\n    # Training methods\n    # ----------------\n    def train(self) -&gt; None:\n        '''\n        Optional function to train the agent in the olfactory environment it is in.\n        This function is optional as some agents have some fixed behavior and therefore dont require training.\n        '''\n        raise NotImplementedError('The train function is not implemented, make an agent subclass to implement the method')\n\n\n    # ------------------\n    # Simulation methods\n    # ------------------\n    def initialize_state(self,\n                         n: int = 1\n                         ) -&gt; None:\n        '''\n        Function to initialize the internal state of the agent(s) for the simulation process. The internal state can be concepts such as the \"memory\" or \"belief\" of the agent.\n        The n parameter corresponds to how many \"instances\" need to instanciated. This is meant so that we work with a \"group\" of agents instead of individual instances.\n\n        This is done with the purpose that the state of the group of agents be stored in (Numpy) arrays to allow vectorization instead of sequential loops.\n\n        Parameters\n        ----------\n        n : int, default=1\n            How many agents to initialize.\n        '''\n        raise NotImplementedError('The initialize_state function is not implemented, make an agent subclass to implement the method')\n\n\n    def choose_action(self) -&gt; np.ndarray:\n        '''\n        Function to allow for the agent(s) to choose an action to take based on its current state.\n\n        It should return a 2D array of shape n by 2 (or 3, or 4 depending of whether the environment has layers and/or a 3rd dimension),\n        where n is how many agents are to choose an action. It should be n 2D vectors of (the layer and) the change in the (z,) y, and x positions.\n\n        Returns\n        -------\n        movement_vector : np.ndarray\n            An array of n vectors in 2D space of the movement(s) the agent(s) will take.\n        '''\n        raise NotImplementedError('The choose_action function is not implemented, make an agent subclass to implement the method')\n\n\n    def discretize_observations(self,\n                                observation: np.ndarray,\n                                action: np.ndarray,\n                                source_reached: np.ndarray\n                                ) -&gt; np.ndarray:\n        '''\n        Function to convert a set of observations to discrete observation ids.\n        It uses the olfaction thresholds of the agent to discretize the odor concentrations.\n\n        In the case where the agent is also aware of it's own position in space, in which case the observation matrix is of size n by 1 + environment.dimensions,\n        the agent first converts the points on the grid to position ids and then multiply the id by olfactory observation id.\n\n        Parameters\n        ----------\n        observation : np.ndarray\n            The observations the agent receives, in the case the agent is space_aware, the position point is also included.\n        action: np.ndarray\n            The action the agent did. This parameter is used in the particular case where the environment has layers and the odor thresholds are layer dependent.\n        source_reached : np.ndarray\n            A 1D array of boolean values signifying whether each agent reached or not the source.\n\n        Returns\n        -------\n        discrete_observations: np.ndarray\n            An integer array of discrete observations\n        '''\n        # GPU support\n        xp = np if not self.on_gpu else cp\n\n        n = len(observation)\n        discrete_observations = xp.ones(n, dtype=int) * -1\n\n        # Gather olfactory observation\n        olfactory_observation = observation if not self.space_aware else observation[:,0]\n\n        # Compute the amount of observations available\n        observation_count = self.thresholds.shape[-1] - 1 # |thresholds| - 1 observation buckets\n\n        # Handle the special case where we have a layered environment and different thresholds for these layers\n        if self.environment.has_layers and len(self.thresholds.shape) == 2:\n            layer_ids = action[:,0] # First column of actions is the layer\n            action_layer_thresholds = self.thresholds[layer_ids]\n            observation_ids = xp.argwhere((olfactory_observation[:,None] &gt;= action_layer_thresholds[:,:-1]) &amp; (olfactory_observation[:,None] &lt; action_layer_thresholds[:,1:]))[:,1]\n        else:\n            # Setting observation ids\n            observation_ids = xp.argwhere((olfactory_observation[:,None] &gt;= self.thresholds[:-1][None,:]) &amp; (olfactory_observation[:,None] &lt; self.thresholds[1:][None,:]))[:,1]\n\n        # If needed, multiply observation indices by position indices\n        if not self.space_aware:\n            discrete_observations = observation_ids\n        else:\n            position_clipped = xp.clip(observation[:,1:], a_min=0, a_max=(xp.array(self.environment.shape)-1))\n            position_count = int(xp.prod(self.spacial_subdivisions))\n            position_ids = self._environment_to_subdivision_mapping[*position_clipped.astype(int).T]\n\n            # Add the amount of possible positions to the observation count\n            observation_count *= position_count\n\n            # Combine with observation ids\n            discrete_observations = (observation_ids * position_count) + position_ids\n\n        # Adding the goal observation\n        discrete_observations[source_reached] = observation_count\n\n        return discrete_observations\n\n\n    def update_state(self,\n                     action: np.ndarray,\n                     observation: np.ndarray,\n                     source_reached: np.ndarray\n                     ) -&gt; None | np.ndarray:\n        '''\n        Function to update the internal state(s) of the agent(s) based on the action(s) taken and the observation(s) received.\n        The observations are then compared with the thresholds to decide whether something was sensed or not or to what level.\n\n        Parameters\n        ----------\n        action : np.ndarray\n            A 2D array of n movement vectors. If the environment is layered, the 1st component should be the layer.\n        observation : np.ndarray\n            A n by 1 (or 1 + environment.dimensions if space_aware) array of odor cues (float values) retrieved from the environment.\n        source_reached : np.array\n            A 1D array of boolean values signifying whether each agent reached or not the source.\n\n        Returns\n        -------\n        update_successfull : np.ndarray, optional\n            If nothing is returned, it means all the agent's state updates have been successfull.\n            Else, a boolean np.ndarray of size n can be returned confirming for each agent whether the update has been successful or not.\n        '''\n        raise NotImplementedError('The update_state function is not implemented, make an agent subclass to implement the method')\n\n\n    def kill(self,\n             simulations_to_kill: np.ndarray\n             ) -&gt; None:\n        '''\n        Function to kill any agents that either reached the source or failed by not reaching the source before the horizon or failing to update its own state.\n        The agents where the simulations_to_kill paramater is True have to removed from the list of agents.\n        It is necessary because their reference will also be removed from the simulation loop. Therefore, if they are not removed, the array sizes will not match anymore.\n\n        Parameters\n        ----------\n        simulations_to_kill : np.ndarray\n            An array of size n containing boolean values of whether or not agent's simulations are terminated and therefore should be removed.\n        '''\n        raise NotImplementedError('The kill function is not implemented, make an agent subclass to implement the method')\n\n\n    # ---------------\n    # General methods\n    # ---------------\n    def save(self,\n             folder: str | None = None,\n             force: bool = False,\n             save_environment: bool = False\n             ) -&gt; None:\n        '''\n        Function to save a trained agent to long term storage.\n        By default, the agent is saved in its entirety using pickle.\n\n        However, it is strongly advised to overwrite this method to only save save the necessary components of the agents in order to be able to load it and reproduce its behavior.\n        For instance, if the agent is saved after the simulation is run, the state would also be saved within the pickle which is not wanted.\n\n        Parameters\n        ----------\n        folder : str, optional\n            The folder in which the agent's data should be saved.\n        force : bool, default=False\n            If the agent is already saved at the folder provided, the saving should fail.\n            If the already saved agent should be overwritten, this parameter should be toggled to True.\n        save_environment : bool, default=False\n            Whether to save the agent's linked environment alongside the agent itself.\n        '''\n        if self.on_gpu:\n            cpu_agent = self.to_cpu()\n            cpu_agent.save(folder=folder, force=force, save_environment=save_environment)\n            return\n\n        # Adding env name to folder path\n        if folder is None:\n            folder = f'./Agent-{self.name}'\n        else:\n            folder += f'/Agent-{self.name}'\n\n        # Checking the folder exists or creates it\n        if not os.path.exists(folder):\n            os.mkdir(folder)\n        elif len(os.listdir(folder)) &gt; 0:\n            if force:\n                shutil.rmtree(folder)\n                os.mkdir(folder)\n            else:\n                raise Exception(f'{folder} is not empty. If you want to overwrite the saved agent, enable \"force\".')\n\n        # Send self to pickle\n        with open(folder + '/binary.pkl', 'wb') as f:\n            pickle.dump(self, f)\n\n        # Save environment in folder too if requested\n        if save_environment:\n            self.environment.save(folder=(folder + f'/Env-{self.environment.name}'))\n\n\n    @classmethod\n    def load(cls,\n             folder: str\n             ) -&gt; 'Agent':\n        '''\n        Function to load a trained agent from long term storage.\n        By default, as for the save function, it will load the agent from the folder assuming it is a pickle file.\n\n        Parameters\n        ----------\n        folder : str\n            The folder in which the agent was saved.\n\n        Returns\n        -------\n        loaded_agent : Agent\n            The agent loaded from the folder.\n        '''\n        from olfactory_navigation import agents\n\n        for name, obj in inspect.getmembers(agents):\n            if inspect.isclass(obj) and (name in folder) and issubclass(obj, cls) and (obj != cls):\n                return obj.load(folder)\n\n        # Default loading with pickle\n        with open(folder + '/binary.pkl', 'rb') as f:\n            return pickle.load(f)\n\n\n    def modify_environment(self,\n                           new_environment: Environment\n                           ) -&gt; 'Agent':\n        '''\n        Function to modify the environment of the agent.\n\n        Note: By default, a new agent is created with the same thresholds and name but with a this new environment!\n        If there are any trained elements to the agent, they are to be modified in this method to be adapted to this new environment.\n\n        Parameters\n        ----------\n        new_environment : Environment\n            The new environment to replace the agent in an equivalent agent.\n\n        Returns\n        -------\n        modified_agent : Agent\n            A new Agent whose environment has been replaced.\n        '''\n        # TODO: Fix this to account for other init parameters\n        modified_agent = self.__class__(environment=new_environment,\n                                        thresholds=self.thresholds,\n                                        name=self.name)\n        return modified_agent\n\n\n    def to_gpu(self) -&gt; 'Agent':\n        '''\n        Function to send the numpy arrays of the agent to the gpu.\n        It returns a new instance of the Agent class with the arrays on the gpu.\n\n        Returns\n        -------\n        gpu_agent : Agent\n            A new environment instance where the arrays are on the gpu memory.\n        '''\n        # Check whether the agent is already on the gpu or not\n        if self.on_gpu:\n            return self\n\n        # Warn and overwrite alternate_version in case it already exists\n        if self._alternate_version is not None:\n            print('[warning] A GPU instance already existed and is being recreated.')\n            self._alternate_version = None\n\n        assert gpu_support, \"GPU support is not enabled, Cupy might need to be installed...\"\n\n        # Generating a new instance\n        cls = self.__class__\n        gpu_agent = cls.__new__(cls)\n\n        # Copying arguments to gpu\n        for arg, val in self.__dict__.items():\n            if isinstance(val, np.ndarray):\n                setattr(gpu_agent, arg, cp.array(val))\n            elif arg == 'rnd_state':\n                setattr(gpu_agent, arg, cp.random.RandomState(self.seed))\n            else:\n                setattr(gpu_agent, arg, val)\n\n        # Self reference instances\n        self._alternate_version = gpu_agent\n        gpu_agent._alternate_version = self\n\n        gpu_agent.on_gpu = True\n        return gpu_agent\n\n\n    def to_cpu(self) -&gt; 'Agent':\n        '''\n        Function to send the numpy arrays of the agent to the cpu.\n        It returns a new instance of the Agent class with the arrays on the cpu.\n\n        Returns\n        -------\n        cpu_agent : Agent\n            A new environment instance where the arrays are on the cpu memory.\n        '''\n        # Check whether the agent is already on the cpu or not\n        if not self.on_gpu:\n            return self\n\n        if self._alternate_version is not None:\n            print('[warning] A CPU instance already existed and is being recreated.')\n            self._alternate_version = None\n\n        # Generating a new instance\n        cls = self.__class__\n        cpu_agent = cls.__new__(cls)\n\n        # Copying arguments to gpu\n        for arg, val in self.__dict__.items():\n            if isinstance(val, cp.ndarray):\n                setattr(cpu_agent, arg, cp.asnumpy(val))\n            elif arg == 'rnd_state':\n                setattr(cpu_agent, arg, np.random.RandomState(self.seed))\n            else:\n                setattr(cpu_agent, arg, val)\n\n        # Self reference instances\n        self._alternate_version = cpu_agent\n        cpu_agent._alternate_version = self\n\n        cpu_agent.on_gpu = True\n        return cpu_agent\n\n\n    @property\n    def gpu_version(self):\n        '''\n        A version of the Agent on the GPU.\n        If the agent is already on the GPU it returns itself, otherwise the to_gpu function is called to generate a new one.\n        '''\n        if self.on_gpu:\n            return self\n        else:\n            if self._alternate_version is not None: # Check if an alternate version already exists\n                return self._alternate_version\n            else: # Generate an alternate version on the gpu\n                return self.to_gpu()\n\n\n    @property\n    def cpu_version(self):\n        '''\n        A version of the Agent on the CPU.\n        If the agent is already on the CPU it returns itself, otherwise the to_cpu function is called to generate a new one.\n        '''\n        if not self.on_gpu:\n            return self\n        else:\n            if self._alternate_version is not None: # Check if an alternate version already exists\n                return self._alternate_version\n            else: # Generate an alternate version on the cpu\n                return self.to_cpu()\n</code></pre>"},{"location":"reference/#olfactory_navigation.Agent.class_name","title":"<code>class_name</code>  <code>property</code>","text":"<p>The name of the class of the agent.</p>"},{"location":"reference/#olfactory_navigation.Agent.cpu_version","title":"<code>cpu_version</code>  <code>property</code>","text":"<p>A version of the Agent on the CPU. If the agent is already on the CPU it returns itself, otherwise the to_cpu function is called to generate a new one.</p>"},{"location":"reference/#olfactory_navigation.Agent.gpu_version","title":"<code>gpu_version</code>  <code>property</code>","text":"<p>A version of the Agent on the GPU. If the agent is already on the GPU it returns itself, otherwise the to_gpu function is called to generate a new one.</p>"},{"location":"reference/#olfactory_navigation.Agent.choose_action","title":"<code>choose_action()</code>","text":"<p>Function to allow for the agent(s) to choose an action to take based on its current state.</p> <p>It should return a 2D array of shape n by 2 (or 3, or 4 depending of whether the environment has layers and/or a 3rd dimension), where n is how many agents are to choose an action. It should be n 2D vectors of (the layer and) the change in the (z,) y, and x positions.</p> <p>Returns:</p> Name Type Description <code>movement_vector</code> <code>ndarray</code> <p>An array of n vectors in 2D space of the movement(s) the agent(s) will take.</p> Source code in <code>olfactory_navigation/agent.py</code> <pre><code>def choose_action(self) -&gt; np.ndarray:\n    '''\n    Function to allow for the agent(s) to choose an action to take based on its current state.\n\n    It should return a 2D array of shape n by 2 (or 3, or 4 depending of whether the environment has layers and/or a 3rd dimension),\n    where n is how many agents are to choose an action. It should be n 2D vectors of (the layer and) the change in the (z,) y, and x positions.\n\n    Returns\n    -------\n    movement_vector : np.ndarray\n        An array of n vectors in 2D space of the movement(s) the agent(s) will take.\n    '''\n    raise NotImplementedError('The choose_action function is not implemented, make an agent subclass to implement the method')\n</code></pre>"},{"location":"reference/#olfactory_navigation.Agent.discretize_observations","title":"<code>discretize_observations(observation, action, source_reached)</code>","text":"<p>Function to convert a set of observations to discrete observation ids. It uses the olfaction thresholds of the agent to discretize the odor concentrations.</p> <p>In the case where the agent is also aware of it's own position in space, in which case the observation matrix is of size n by 1 + environment.dimensions, the agent first converts the points on the grid to position ids and then multiply the id by olfactory observation id.</p> <p>Parameters:</p> Name Type Description Default <code>observation</code> <code>ndarray</code> <p>The observations the agent receives, in the case the agent is space_aware, the position point is also included.</p> required <code>action</code> <code>ndarray</code> <p>The action the agent did. This parameter is used in the particular case where the environment has layers and the odor thresholds are layer dependent.</p> required <code>source_reached</code> <code>ndarray</code> <p>A 1D array of boolean values signifying whether each agent reached or not the source.</p> required <p>Returns:</p> Name Type Description <code>discrete_observations</code> <code>ndarray</code> <p>An integer array of discrete observations</p> Source code in <code>olfactory_navigation/agent.py</code> <pre><code>def discretize_observations(self,\n                            observation: np.ndarray,\n                            action: np.ndarray,\n                            source_reached: np.ndarray\n                            ) -&gt; np.ndarray:\n    '''\n    Function to convert a set of observations to discrete observation ids.\n    It uses the olfaction thresholds of the agent to discretize the odor concentrations.\n\n    In the case where the agent is also aware of it's own position in space, in which case the observation matrix is of size n by 1 + environment.dimensions,\n    the agent first converts the points on the grid to position ids and then multiply the id by olfactory observation id.\n\n    Parameters\n    ----------\n    observation : np.ndarray\n        The observations the agent receives, in the case the agent is space_aware, the position point is also included.\n    action: np.ndarray\n        The action the agent did. This parameter is used in the particular case where the environment has layers and the odor thresholds are layer dependent.\n    source_reached : np.ndarray\n        A 1D array of boolean values signifying whether each agent reached or not the source.\n\n    Returns\n    -------\n    discrete_observations: np.ndarray\n        An integer array of discrete observations\n    '''\n    # GPU support\n    xp = np if not self.on_gpu else cp\n\n    n = len(observation)\n    discrete_observations = xp.ones(n, dtype=int) * -1\n\n    # Gather olfactory observation\n    olfactory_observation = observation if not self.space_aware else observation[:,0]\n\n    # Compute the amount of observations available\n    observation_count = self.thresholds.shape[-1] - 1 # |thresholds| - 1 observation buckets\n\n    # Handle the special case where we have a layered environment and different thresholds for these layers\n    if self.environment.has_layers and len(self.thresholds.shape) == 2:\n        layer_ids = action[:,0] # First column of actions is the layer\n        action_layer_thresholds = self.thresholds[layer_ids]\n        observation_ids = xp.argwhere((olfactory_observation[:,None] &gt;= action_layer_thresholds[:,:-1]) &amp; (olfactory_observation[:,None] &lt; action_layer_thresholds[:,1:]))[:,1]\n    else:\n        # Setting observation ids\n        observation_ids = xp.argwhere((olfactory_observation[:,None] &gt;= self.thresholds[:-1][None,:]) &amp; (olfactory_observation[:,None] &lt; self.thresholds[1:][None,:]))[:,1]\n\n    # If needed, multiply observation indices by position indices\n    if not self.space_aware:\n        discrete_observations = observation_ids\n    else:\n        position_clipped = xp.clip(observation[:,1:], a_min=0, a_max=(xp.array(self.environment.shape)-1))\n        position_count = int(xp.prod(self.spacial_subdivisions))\n        position_ids = self._environment_to_subdivision_mapping[*position_clipped.astype(int).T]\n\n        # Add the amount of possible positions to the observation count\n        observation_count *= position_count\n\n        # Combine with observation ids\n        discrete_observations = (observation_ids * position_count) + position_ids\n\n    # Adding the goal observation\n    discrete_observations[source_reached] = observation_count\n\n    return discrete_observations\n</code></pre>"},{"location":"reference/#olfactory_navigation.Agent.initialize_state","title":"<code>initialize_state(n=1)</code>","text":"<p>Function to initialize the internal state of the agent(s) for the simulation process. The internal state can be concepts such as the \"memory\" or \"belief\" of the agent. The n parameter corresponds to how many \"instances\" need to instanciated. This is meant so that we work with a \"group\" of agents instead of individual instances.</p> <p>This is done with the purpose that the state of the group of agents be stored in (Numpy) arrays to allow vectorization instead of sequential loops.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>How many agents to initialize.</p> <code>1</code> Source code in <code>olfactory_navigation/agent.py</code> <pre><code>def initialize_state(self,\n                     n: int = 1\n                     ) -&gt; None:\n    '''\n    Function to initialize the internal state of the agent(s) for the simulation process. The internal state can be concepts such as the \"memory\" or \"belief\" of the agent.\n    The n parameter corresponds to how many \"instances\" need to instanciated. This is meant so that we work with a \"group\" of agents instead of individual instances.\n\n    This is done with the purpose that the state of the group of agents be stored in (Numpy) arrays to allow vectorization instead of sequential loops.\n\n    Parameters\n    ----------\n    n : int, default=1\n        How many agents to initialize.\n    '''\n    raise NotImplementedError('The initialize_state function is not implemented, make an agent subclass to implement the method')\n</code></pre>"},{"location":"reference/#olfactory_navigation.Agent.kill","title":"<code>kill(simulations_to_kill)</code>","text":"<p>Function to kill any agents that either reached the source or failed by not reaching the source before the horizon or failing to update its own state. The agents where the simulations_to_kill paramater is True have to removed from the list of agents. It is necessary because their reference will also be removed from the simulation loop. Therefore, if they are not removed, the array sizes will not match anymore.</p> <p>Parameters:</p> Name Type Description Default <code>simulations_to_kill</code> <code>ndarray</code> <p>An array of size n containing boolean values of whether or not agent's simulations are terminated and therefore should be removed.</p> required Source code in <code>olfactory_navigation/agent.py</code> <pre><code>def kill(self,\n         simulations_to_kill: np.ndarray\n         ) -&gt; None:\n    '''\n    Function to kill any agents that either reached the source or failed by not reaching the source before the horizon or failing to update its own state.\n    The agents where the simulations_to_kill paramater is True have to removed from the list of agents.\n    It is necessary because their reference will also be removed from the simulation loop. Therefore, if they are not removed, the array sizes will not match anymore.\n\n    Parameters\n    ----------\n    simulations_to_kill : np.ndarray\n        An array of size n containing boolean values of whether or not agent's simulations are terminated and therefore should be removed.\n    '''\n    raise NotImplementedError('The kill function is not implemented, make an agent subclass to implement the method')\n</code></pre>"},{"location":"reference/#olfactory_navigation.Agent.load","title":"<code>load(folder)</code>  <code>classmethod</code>","text":"<p>Function to load a trained agent from long term storage. By default, as for the save function, it will load the agent from the folder assuming it is a pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>The folder in which the agent was saved.</p> required <p>Returns:</p> Name Type Description <code>loaded_agent</code> <code>Agent</code> <p>The agent loaded from the folder.</p> Source code in <code>olfactory_navigation/agent.py</code> <pre><code>@classmethod\ndef load(cls,\n         folder: str\n         ) -&gt; 'Agent':\n    '''\n    Function to load a trained agent from long term storage.\n    By default, as for the save function, it will load the agent from the folder assuming it is a pickle file.\n\n    Parameters\n    ----------\n    folder : str\n        The folder in which the agent was saved.\n\n    Returns\n    -------\n    loaded_agent : Agent\n        The agent loaded from the folder.\n    '''\n    from olfactory_navigation import agents\n\n    for name, obj in inspect.getmembers(agents):\n        if inspect.isclass(obj) and (name in folder) and issubclass(obj, cls) and (obj != cls):\n            return obj.load(folder)\n\n    # Default loading with pickle\n    with open(folder + '/binary.pkl', 'rb') as f:\n        return pickle.load(f)\n</code></pre>"},{"location":"reference/#olfactory_navigation.Agent.modify_environment","title":"<code>modify_environment(new_environment)</code>","text":"<p>Function to modify the environment of the agent.</p> <p>Note: By default, a new agent is created with the same thresholds and name but with a this new environment! If there are any trained elements to the agent, they are to be modified in this method to be adapted to this new environment.</p> <p>Parameters:</p> Name Type Description Default <code>new_environment</code> <code>Environment</code> <p>The new environment to replace the agent in an equivalent agent.</p> required <p>Returns:</p> Name Type Description <code>modified_agent</code> <code>Agent</code> <p>A new Agent whose environment has been replaced.</p> Source code in <code>olfactory_navigation/agent.py</code> <pre><code>def modify_environment(self,\n                       new_environment: Environment\n                       ) -&gt; 'Agent':\n    '''\n    Function to modify the environment of the agent.\n\n    Note: By default, a new agent is created with the same thresholds and name but with a this new environment!\n    If there are any trained elements to the agent, they are to be modified in this method to be adapted to this new environment.\n\n    Parameters\n    ----------\n    new_environment : Environment\n        The new environment to replace the agent in an equivalent agent.\n\n    Returns\n    -------\n    modified_agent : Agent\n        A new Agent whose environment has been replaced.\n    '''\n    # TODO: Fix this to account for other init parameters\n    modified_agent = self.__class__(environment=new_environment,\n                                    thresholds=self.thresholds,\n                                    name=self.name)\n    return modified_agent\n</code></pre>"},{"location":"reference/#olfactory_navigation.Agent.save","title":"<code>save(folder=None, force=False, save_environment=False)</code>","text":"<p>Function to save a trained agent to long term storage. By default, the agent is saved in its entirety using pickle.</p> <p>However, it is strongly advised to overwrite this method to only save save the necessary components of the agents in order to be able to load it and reproduce its behavior. For instance, if the agent is saved after the simulation is run, the state would also be saved within the pickle which is not wanted.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>The folder in which the agent's data should be saved.</p> <code>None</code> <code>force</code> <code>bool</code> <p>If the agent is already saved at the folder provided, the saving should fail. If the already saved agent should be overwritten, this parameter should be toggled to True.</p> <code>False</code> <code>save_environment</code> <code>bool</code> <p>Whether to save the agent's linked environment alongside the agent itself.</p> <code>False</code> Source code in <code>olfactory_navigation/agent.py</code> <pre><code>def save(self,\n         folder: str | None = None,\n         force: bool = False,\n         save_environment: bool = False\n         ) -&gt; None:\n    '''\n    Function to save a trained agent to long term storage.\n    By default, the agent is saved in its entirety using pickle.\n\n    However, it is strongly advised to overwrite this method to only save save the necessary components of the agents in order to be able to load it and reproduce its behavior.\n    For instance, if the agent is saved after the simulation is run, the state would also be saved within the pickle which is not wanted.\n\n    Parameters\n    ----------\n    folder : str, optional\n        The folder in which the agent's data should be saved.\n    force : bool, default=False\n        If the agent is already saved at the folder provided, the saving should fail.\n        If the already saved agent should be overwritten, this parameter should be toggled to True.\n    save_environment : bool, default=False\n        Whether to save the agent's linked environment alongside the agent itself.\n    '''\n    if self.on_gpu:\n        cpu_agent = self.to_cpu()\n        cpu_agent.save(folder=folder, force=force, save_environment=save_environment)\n        return\n\n    # Adding env name to folder path\n    if folder is None:\n        folder = f'./Agent-{self.name}'\n    else:\n        folder += f'/Agent-{self.name}'\n\n    # Checking the folder exists or creates it\n    if not os.path.exists(folder):\n        os.mkdir(folder)\n    elif len(os.listdir(folder)) &gt; 0:\n        if force:\n            shutil.rmtree(folder)\n            os.mkdir(folder)\n        else:\n            raise Exception(f'{folder} is not empty. If you want to overwrite the saved agent, enable \"force\".')\n\n    # Send self to pickle\n    with open(folder + '/binary.pkl', 'wb') as f:\n        pickle.dump(self, f)\n\n    # Save environment in folder too if requested\n    if save_environment:\n        self.environment.save(folder=(folder + f'/Env-{self.environment.name}'))\n</code></pre>"},{"location":"reference/#olfactory_navigation.Agent.to_cpu","title":"<code>to_cpu()</code>","text":"<p>Function to send the numpy arrays of the agent to the cpu. It returns a new instance of the Agent class with the arrays on the cpu.</p> <p>Returns:</p> Name Type Description <code>cpu_agent</code> <code>Agent</code> <p>A new environment instance where the arrays are on the cpu memory.</p> Source code in <code>olfactory_navigation/agent.py</code> <pre><code>def to_cpu(self) -&gt; 'Agent':\n    '''\n    Function to send the numpy arrays of the agent to the cpu.\n    It returns a new instance of the Agent class with the arrays on the cpu.\n\n    Returns\n    -------\n    cpu_agent : Agent\n        A new environment instance where the arrays are on the cpu memory.\n    '''\n    # Check whether the agent is already on the cpu or not\n    if not self.on_gpu:\n        return self\n\n    if self._alternate_version is not None:\n        print('[warning] A CPU instance already existed and is being recreated.')\n        self._alternate_version = None\n\n    # Generating a new instance\n    cls = self.__class__\n    cpu_agent = cls.__new__(cls)\n\n    # Copying arguments to gpu\n    for arg, val in self.__dict__.items():\n        if isinstance(val, cp.ndarray):\n            setattr(cpu_agent, arg, cp.asnumpy(val))\n        elif arg == 'rnd_state':\n            setattr(cpu_agent, arg, np.random.RandomState(self.seed))\n        else:\n            setattr(cpu_agent, arg, val)\n\n    # Self reference instances\n    self._alternate_version = cpu_agent\n    cpu_agent._alternate_version = self\n\n    cpu_agent.on_gpu = True\n    return cpu_agent\n</code></pre>"},{"location":"reference/#olfactory_navigation.Agent.to_gpu","title":"<code>to_gpu()</code>","text":"<p>Function to send the numpy arrays of the agent to the gpu. It returns a new instance of the Agent class with the arrays on the gpu.</p> <p>Returns:</p> Name Type Description <code>gpu_agent</code> <code>Agent</code> <p>A new environment instance where the arrays are on the gpu memory.</p> Source code in <code>olfactory_navigation/agent.py</code> <pre><code>def to_gpu(self) -&gt; 'Agent':\n    '''\n    Function to send the numpy arrays of the agent to the gpu.\n    It returns a new instance of the Agent class with the arrays on the gpu.\n\n    Returns\n    -------\n    gpu_agent : Agent\n        A new environment instance where the arrays are on the gpu memory.\n    '''\n    # Check whether the agent is already on the gpu or not\n    if self.on_gpu:\n        return self\n\n    # Warn and overwrite alternate_version in case it already exists\n    if self._alternate_version is not None:\n        print('[warning] A GPU instance already existed and is being recreated.')\n        self._alternate_version = None\n\n    assert gpu_support, \"GPU support is not enabled, Cupy might need to be installed...\"\n\n    # Generating a new instance\n    cls = self.__class__\n    gpu_agent = cls.__new__(cls)\n\n    # Copying arguments to gpu\n    for arg, val in self.__dict__.items():\n        if isinstance(val, np.ndarray):\n            setattr(gpu_agent, arg, cp.array(val))\n        elif arg == 'rnd_state':\n            setattr(gpu_agent, arg, cp.random.RandomState(self.seed))\n        else:\n            setattr(gpu_agent, arg, val)\n\n    # Self reference instances\n    self._alternate_version = gpu_agent\n    gpu_agent._alternate_version = self\n\n    gpu_agent.on_gpu = True\n    return gpu_agent\n</code></pre>"},{"location":"reference/#olfactory_navigation.Agent.train","title":"<code>train()</code>","text":"<p>Optional function to train the agent in the olfactory environment it is in. This function is optional as some agents have some fixed behavior and therefore dont require training.</p> Source code in <code>olfactory_navigation/agent.py</code> <pre><code>def train(self) -&gt; None:\n    '''\n    Optional function to train the agent in the olfactory environment it is in.\n    This function is optional as some agents have some fixed behavior and therefore dont require training.\n    '''\n    raise NotImplementedError('The train function is not implemented, make an agent subclass to implement the method')\n</code></pre>"},{"location":"reference/#olfactory_navigation.Agent.update_state","title":"<code>update_state(action, observation, source_reached)</code>","text":"<p>Function to update the internal state(s) of the agent(s) based on the action(s) taken and the observation(s) received. The observations are then compared with the thresholds to decide whether something was sensed or not or to what level.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>ndarray</code> <p>A 2D array of n movement vectors. If the environment is layered, the 1st component should be the layer.</p> required <code>observation</code> <code>ndarray</code> <p>A n by 1 (or 1 + environment.dimensions if space_aware) array of odor cues (float values) retrieved from the environment.</p> required <code>source_reached</code> <code>array</code> <p>A 1D array of boolean values signifying whether each agent reached or not the source.</p> required <p>Returns:</p> Name Type Description <code>update_successfull</code> <code>(ndarray, optional)</code> <p>If nothing is returned, it means all the agent's state updates have been successfull. Else, a boolean np.ndarray of size n can be returned confirming for each agent whether the update has been successful or not.</p> Source code in <code>olfactory_navigation/agent.py</code> <pre><code>def update_state(self,\n                 action: np.ndarray,\n                 observation: np.ndarray,\n                 source_reached: np.ndarray\n                 ) -&gt; None | np.ndarray:\n    '''\n    Function to update the internal state(s) of the agent(s) based on the action(s) taken and the observation(s) received.\n    The observations are then compared with the thresholds to decide whether something was sensed or not or to what level.\n\n    Parameters\n    ----------\n    action : np.ndarray\n        A 2D array of n movement vectors. If the environment is layered, the 1st component should be the layer.\n    observation : np.ndarray\n        A n by 1 (or 1 + environment.dimensions if space_aware) array of odor cues (float values) retrieved from the environment.\n    source_reached : np.array\n        A 1D array of boolean values signifying whether each agent reached or not the source.\n\n    Returns\n    -------\n    update_successfull : np.ndarray, optional\n        If nothing is returned, it means all the agent's state updates have been successfull.\n        Else, a boolean np.ndarray of size n can be returned confirming for each agent whether the update has been successful or not.\n    '''\n    raise NotImplementedError('The update_state function is not implemented, make an agent subclass to implement the method')\n</code></pre>"},{"location":"reference/#olfactory_navigation.Environment","title":"<code>Environment</code>","text":"<p>Class to represent an olfactory environment.</p> <p>It is defined based on an olfactory data set provided as either a numpy file or an array directly with shape time, y, x. From this environment, the various parameters are applied in the following order:</p> <ol> <li>The source position is set</li> <li>The margins are added and the shape (total size) of the environment are set.</li> <li>The data file's x and y components are squished and streched the to fit the inter-marginal shape of the environment.</li> <li>The source's position is also moved to stay at the same position within the data.</li> <li>The multiplier is finally applied to modify the data file's x and y components a final time by growing or shrinking the margins to account for the multiplier. (The multiplication applies with the source position as a center point)</li> </ol> <p>Note: to modify the shape of the data file's x and y components the OpenCV library's resize function is used. And the interpolation method is controlled by the interpolation_method parameter.</p> <p>Then, the starting probability map is built. Either an array can be provided directly or preset option can be chosen:</p> <ul> <li>'data_zone': The agent can start at any point in the data_zone (after all the modification parameters have been applied)</li> <li>'odor_present': The agent can start at any point where an odor cue above the odor_present_threshold can be found at any timestep during the simulation</li> </ul> <p>Parameters:</p> Name Type Description Default <code>data_file</code> <code>str or ndarray</code> <p>The dataset containing the olfactory data. It can be provided as a path to a file containing said array.</p> required <code>data_source_position</code> <code>list or ndarray</code> <p>The center point of the source provided as a list or a 1D array with the components being x,y. This position is computed in the olfactory data zone (so excluding the margins).</p> required <code>source_radius</code> <code>float</code> <p>The radius from the center point of the source in which we consider the agent has reached the source.</p> <code>1.0</code> <code>layers</code> <code>bool or list[int] or list[str]</code> <p>Whether or not the data provided contains layers or not. If a list of strings is provided, it will be either used to name the layers found (if numpy data), or it is used to querry the datasets of the h5 file.</p> <code>False</code> <code>shape</code> <code>list or ndarray</code> <p>A 2-element array or list of how many units should be kept in the final array (including the margins). As it should include the margins, the shape should be strictly larger than the sum of the margins in each direction. By default, the shape of the olfactory data will be maintained.</p> <code>None</code> <code>margins</code> <code>int or list or ndarray</code> <p>How many units have to be added to the data as margins. (Before the multiplier is applied) If a unique element is provided, the margin will be this same value on each side. If a list or array of 2 elements is provided, the first number will be vertical margins (y-axis), while the other will be on the x-axis (horizontal).</p> <code>0</code> <code>multiplier</code> <code>list or ndarray</code> <p>A 2-element array or list of how much the odor field should be streched in each direction. If a value larger than 1 is provided, the margins will be reduced to accomodate for the larger size of the olfactory data size. And inversly, less than 1 will increase the margins. By default, the multipliers will be set to 1.0.</p> <code>[1.0,1.0]</code> <code>interpolation_method</code> <code>Nearest or Linear or Cubic</code> <p>The interpolation method to be used in the case the data needs to be reshaped to fit the shape, margins and multiplier parameters. By default, it uses Bi-linear interpolation. The interpolation is performed using the OpenCV library.</p> <code>'Linear'</code> <code>preprocess_data</code> <code>bool</code> <p>Applicable only for data_file being a path to a h5 file. Whether to reshape of the data at the creation of the environment. Reshaping the data ahead of time will require more processing at the creation and more memory overall. While if this is disabled, when gathering observations, more time will be required but less memory will need to be used at once.</p> <code>False</code> <code>boundary_condition</code> <code>stop or wrap or wrap_vertical or wrap_horizontal or clip</code> <p>How the agent should behave at the boundary. Stop means for the agent to stop at the boundary, if the agent tries to move north while being on the top edge, it will stay in the same state. Wrap means for the borders to be like portals, when entering on one side, it reappears on the other side. Wrap can be specified to be only vertically or horizontally</p> <code>'stop'</code> <code>start_zone</code> <code>odor_present or data_zone or ndarray</code> <p>Either an array or a string representing how the starting probabilities should be constructed. - odor_present: The start probabilities will be uniform where odor cues can be found above 0 (or a given odor_present_threshold) - data_zone: Uniform over the data zone, so without the margins. Note that the points within the source radius will be excluded from this probability grid.</p> <code>'data_zone'</code> <code>odor_present_threshold</code> <code>float</code> <p>An olfactory threshold, under which the odor is considered too low to be noticed. It is used only to build the starting zone if the 'odor_present' option is selected.</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to be given to the agent. If it is not provided, by default it will have the format: -marg_-edge_-start_-source__radius <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <p>Attributes:</p> Name Type Description <code>data</code> <code>ndarray</code> <p>An array containing the olfactory data after the modification parameters have been applied.</p> <code>data_file_path</code> <code>str</code> <p>If the data is loaded from a path, the path will be recorded here.</p> <code>data_source_position</code> <code>ndarray</code> <p>The position of the source in the original data file (after modifications have been applied).</p> <code>layers</code> <code>ndarray</code> <p>A numbered list of the IDs of the layers.</p> <code>layer_labels</code> <code>list[str]</code> <p>A list of how the layers are named.</p> <code>has_layers</code> <code>bool</code> <p>Whether or not the environment is made up of layers.</p> <code>margins</code> <code>ndarray</code> <p>An array of the margins vertically and horizontally (after multiplier is applied).</p> <code>timestamps</code> <code>int</code> <p>The amount of timeslices available in the environment.</p> <code>data_shape</code> <code>tuple[int]</code> <p>The shape of the data's odor field (after modifications have been applied).</p> <code>dimensions</code> <code>int</code> <p>The amount of dimensions of the physical space of the olfactory environment.</p> <code>shape</code> <code>tuple[int]</code> <p>The shape of the environment. It is a tuple of the size in each axis of the environment.</p> <code>data_bounds</code> <code>ndarray</code> <p>The bounds between which the original olfactory data stands in the coordinate system of the environment (after modifications have been applied).</p> <code>source_position</code> <code>ndarray</code> <p>The position of the source in the padded grid (after modifications have been applied).</p> <code>source_radius</code> <code>float</code> <p>The radius of the source.</p> <code>interpolation_method</code> <code>str</code> <p>The interpolation used to modify the shape of the original data.</p> <code>data_processed</code> <code>bool</code> <p>Whether the data was processed (ie the shape is at it should be) or not.</p> <code>boundary_condition</code> <code>str</code> <p>How the agent should behave when reaching the boundary.</p> <code>start_probabilities</code> <code>ndarray</code> <p>A probability map of where the agent is likely to start within the environment. Note: Zero within the source radius.</p> <code>start_type</code> <code>str</code> <p>The type of the start probability map building. For instance: 'data_zone', 'odor_present', or 'custom' (if an array is provided).</p> <code>odor_present_threshold</code> <code>float</code> <p>The threshold used to uild the start probabilities if the option 'odor_present' is used.</p> <code>name</code> <code>str</code> <p>The name set to the agent as defined in the parameters.</p> <code>saved_at</code> <code>str</code> <p>If the environment is saved, the path at which it is saved will be recorded here.</p> <code>on_gpu</code> <code>bool</code> <p>Whether the environment's arrays are on the gpu's memory or not.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Environment</code> <p>An instance of the environment on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Environment</code> <p>An instance of the environment on the CPU. If it already is, it returns itself.</p> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>class Environment:\n    '''\n    Class to represent an olfactory environment.\n\n    It is defined based on an olfactory data set provided as either a numpy file or an array directly with shape time, y, x.\n    From this environment, the various parameters are applied in the following order:\n\n    0. The source position is set\n    1. The margins are added and the shape (total size) of the environment are set.\n    2. The data file's x and y components are squished and streched the to fit the inter-marginal shape of the environment.\n    3. The source's position is also moved to stay at the same position within the data.\n    4. The multiplier is finally applied to modify the data file's x and y components a final time by growing or shrinking the margins to account for the multiplier. (The multiplication applies with the source position as a center point)\n\n    Note: to modify the shape of the data file's x and y components the OpenCV library's resize function is used. And the interpolation method is controlled by the interpolation_method parameter.\n\n\n    Then, the starting probability map is built. Either an array can be provided directly or preset option can be chosen:\n\n    - 'data_zone': The agent can start at any point in the data_zone (after all the modification parameters have been applied)\n    - 'odor_present': The agent can start at any point where an odor cue above the odor_present_threshold can be found at any timestep during the simulation\n\n    Parameters\n    ----------\n    data_file : str or np.ndarray\n        The dataset containing the olfactory data. It can be provided as a path to a file containing said array.\n    data_source_position : list or np.ndarray\n        The center point of the source provided as a list or a 1D array with the components being x,y.\n        This position is computed in the olfactory data zone (so excluding the margins).\n    source_radius : float, default=1.0\n        The radius from the center point of the source in which we consider the agent has reached the source.\n    layers : bool or list[int] or list[str], default=False\n        Whether or not the data provided contains layers or not.\n        If a list of strings is provided, it will be either used to name the layers found (if numpy data), or it is used to querry the datasets of the h5 file.\n    shape : list or np.ndarray, optional\n        A 2-element array or list of how many units should be kept in the final array (including the margins).\n        As it should include the margins, the shape should be strictly larger than the sum of the margins in each direction.\n        By default, the shape of the olfactory data will be maintained.\n    margins : int or list or np.ndarray, default=0\n        How many units have to be added to the data as margins. (Before the multiplier is applied)\n        If a unique element is provided, the margin will be this same value on each side.\n        If a list or array of 2 elements is provided, the first number will be vertical margins (y-axis), while the other will be on the x-axis (horizontal).\n    multiplier : list or np.ndarray, default=[1.0,1.0]\n        A 2-element array or list of how much the odor field should be streched in each direction.\n        If a value larger than 1 is provided, the margins will be reduced to accomodate for the larger size of the olfactory data size.\n        And inversly, less than 1 will increase the margins.\n        By default, the multipliers will be set to 1.0.\n    interpolation_method : 'Nearest' or 'Linear' or 'Cubic', default='Linear'\n        The interpolation method to be used in the case the data needs to be reshaped to fit the shape, margins and multiplier parameters.\n        By default, it uses Bi-linear interpolation. The interpolation is performed using the OpenCV library.\n    preprocess_data : bool, default=False\n        Applicable only for data_file being a path to a h5 file.\n        Whether to reshape of the data at the creation of the environment.\n        Reshaping the data ahead of time will require more processing at the creation and more memory overall.\n        While if this is disabled, when gathering observations, more time will be required but less memory will need to be used at once.\n    boundary_condition : 'stop' or 'wrap' or 'wrap_vertical' or 'wrap_horizontal' or 'clip', default='stop'\n        How the agent should behave at the boundary.\n        Stop means for the agent to stop at the boundary, if the agent tries to move north while being on the top edge, it will stay in the same state.\n        Wrap means for the borders to be like portals, when entering on one side, it reappears on the other side.\n        Wrap can be specified to be only vertically or horizontally\n    start_zone : 'odor_present' or 'data_zone' or np.ndarray, default='data_zone'\n        Either an array or a string representing how the starting probabilities should be constructed.\n        - odor_present: The start probabilities will be uniform where odor cues can be found above 0 (or a given odor_present_threshold)\n        - data_zone: Uniform over the data zone, so without the margins.\n        Note that the points within the source radius will be excluded from this probability grid.\n    odor_present_threshold : float, optional\n        An olfactory threshold, under which the odor is considered too low to be noticed.\n        It is used only to build the starting zone if the 'odor_present' option is selected.\n    name : str, optional\n        A custom name to be given to the agent.\n        If it is not provided, by default it will have the format:\n        &lt;shape&gt;-marg_&lt;margins&gt;-edge_&lt;boundary_condition&gt;-start_&lt;start_zone&gt;-source_&lt;source_point&gt;_radius&lt;source_radius&gt;\n    seed : int, default=12131415\n        For reproducible randomness.\n\n    Attributes\n    ----------\n    data : np.ndarray\n        An array containing the olfactory data after the modification parameters have been applied.\n    data_file_path : str\n        If the data is loaded from a path, the path will be recorded here.\n    data_source_position : np.ndarray\n        The position of the source in the original data file (after modifications have been applied).\n    layers : np.ndarray\n        A numbered list of the IDs of the layers.\n    layer_labels : list[str]\n        A list of how the layers are named.\n    has_layers : bool\n        Whether or not the environment is made up of layers.\n    margins : np.ndarray\n        An array of the margins vertically and horizontally (after multiplier is applied).\n    timestamps : int\n        The amount of timeslices available in the environment.\n    data_shape : tuple[int]\n        The shape of the data's odor field (after modifications have been applied).\n    dimensions : int\n        The amount of dimensions of the physical space of the olfactory environment.\n    shape : tuple[int]\n        The shape of the environment. It is a tuple of the size in each axis of the environment.\n    data_bounds : np.ndarray\n        The bounds between which the original olfactory data stands in the coordinate system of the environment (after modifications have been applied).\n    source_position : np.ndarray\n        The position of the source in the padded grid (after modifications have been applied).\n    source_radius : float\n        The radius of the source.\n    interpolation_method : str\n        The interpolation used to modify the shape of the original data.\n    data_processed : bool\n        Whether the data was processed (ie the shape is at it should be) or not.\n    boundary_condition : str\n        How the agent should behave when reaching the boundary.\n    start_probabilities : np.ndarray\n        A probability map of where the agent is likely to start within the environment.\n        Note: Zero within the source radius.\n    start_type : str\n        The type of the start probability map building. For instance: 'data_zone', 'odor_present', or 'custom' (if an array is provided).\n    odor_present_threshold : float\n        The threshold used to uild the start probabilities if the option 'odor_present' is used.\n    name : str\n        The name set to the agent as defined in the parameters.\n    saved_at : str\n        If the environment is saved, the path at which it is saved will be recorded here.\n    on_gpu : bool\n        Whether the environment's arrays are on the gpu's memory or not.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Environment\n        An instance of the environment on the CPU. If it already is, it returns itself.\n    gpu_version : Environment\n        An instance of the environment on the CPU. If it already is, it returns itself.\n    '''\n    def __init__(self,\n                 data_file: str | np.ndarray,\n                 data_source_position: list | np.ndarray,\n                 source_radius: float = 1.0,\n                 layers: bool | list[str] = False,\n                 shape: list | np.ndarray | None = None,\n                 margins: int | list | np.ndarray = 0,\n                 multiplier: list| np.ndarray = [1.0, 1.0],\n                 interpolation_method: Literal['Nearest', 'Linear', 'Cubic'] = 'Linear',\n                 preprocess_data: bool = False,\n                 boundary_condition: Literal['stop', 'wrap', 'wrap_vertical', 'wrap_horizontal', 'clip', 'no'] = 'stop',\n                 start_zone: Literal['odor_present', 'data_zone'] | np.ndarray = 'data_zone',\n                 odor_present_threshold: float | None = None,\n                 name: str | None = None,\n                 seed: int = 12131415,\n                 ) -&gt; None:\n        self.saved_at: str = None\n\n        # Layer properties\n        self.layers = None\n        self.layer_labels = None\n        self.has_layers = False\n\n        if isinstance(layers, list):\n            self.has_layers = True\n            self.layers = np.arange(len(layers))\n            self.layer_labels = [layer for layer in layers]\n        elif isinstance(layers, bool):\n            self.has_layers = layers\n\n        # Load from file if string provided\n        self.data_file_path = None\n        self._preprocess_data: bool = preprocess_data\n\n        loaded_data = None\n        if isinstance(data_file, str):\n            self.data_file_path = data_file\n\n            # NUMPY\n            if data_file.endswith('.npy'):\n                loaded_data = np.load(data_file)\n\n                # Layered data\n                if self.has_layers:\n                    if self.layers is None:\n                        self.layers = np.arange(len(loaded_data))\n                        self.layer_labels = [str(layer) for layer in range(len(loaded_data))]\n                    else:\n                        assert (len(self.layers) == len(loaded_data)), \"The amount of layers provided dont match the amount in the dataset.\"\n\n                        # Re-ordering the layers\n                        loaded_data = loaded_data[self.layers]\n\n            # H5\n            elif data_file.endswith('.h5'):\n                loaded_data = h5py.File(data_file,'r')\n\n                # Layered data\n                if self.has_layers:\n\n                    # Converting layers to strings\n                    data_layer_labels = list(loaded_data.keys())\n                    if self.layers is None:\n                        self.layers = np.arange(len(data_layer_labels))\n                        self.layer_labels = data_layer_labels\n\n                    # Getting the labels based on the list of integers provided\n                    elif all(isinstance(layer, int) for layer in layers):\n                        self.layer_labels = [data_layer_labels[layer_id] for layer_id in self.layers]\n\n                    # Loading the list of slices from the data\n                    loaded_data = [[loaded_data[layer][f\"{t}\"] for t in range(len(loaded_data[layer]))] for layer in self.layer_labels]\n\n                else:\n                    loaded_data = [loaded_data[f\"{t}\"] for t in range(len(loaded_data))]\n\n            # Not supported\n            else:\n                raise NotImplementedError('File format loading not implemented')\n\n        elif not isinstance(data_file, np.ndarray):\n            raise NotImplementedError(\"Data file should be either a path or an object that is either an h5 object or a numpy array\")\n\n        self._data: np.ndarray = loaded_data if loaded_data is not None else data_file\n\n        # Unmodified sizes\n        self.timesteps = len(self._data if not self.has_layers else self._data[0])\n        self.data_shape = (self._data[0] if not self.has_layers else self._data[0][0]).shape\n        self.dimensions = len(self.data_shape)\n        self.data_source_position = np.array(data_source_position)\n        self.original_data_source_position = self.data_source_position\n\n        original_data_shape = self.data_shape\n\n        # Making margins a |dims|x2 array\n        if isinstance(margins, int):\n            self.margins = np.ones((self.dimensions, 2), dtype=int) * margins\n        elif isinstance(margins, list) or isinstance(margins, np.ndarray):\n            margins = np.array(margins)\n            if margins.shape == (self.dimensions,): # Symmetric min and max margins\n                self.margins = np.hstack((margins[:,None], margins[:,None]))\n            elif margins.shape == (self.dimensions,2):\n                self.margins = margins\n            else:\n                raise ValueError('The array or lists of Margins provided have a shape not supported. (Supported formats (2,) or (2,2))')\n        else:\n            raise ValueError('margins argument should be either an integer or a 1D or 2D array with either shape (2) or (2,2)')\n        assert (self.margins.dtype == int), 'margins should be integers'\n\n        # Process shape parameter\n        new_data_shape = None\n        if shape is not None:\n            shape = np.array(shape)\n\n            assert np.all(shape &gt; np.sum(self.margins, axis=1)), \"The shape of the environment must be strictly larger than the sum of margins.\"\n\n            # Computing the new shape of the data\n            new_data_shape: np.ndarray = (shape - np.sum(self.margins, axis=1)).astype(int)\n\n            # New source position\n            self.data_source_position = (self.data_source_position * (new_data_shape / self.data_shape)).astype(int)\n        else:\n            shape = self.data_shape + np.sum(self.margins, axis=1)\n\n        if new_data_shape is not None:\n            self.data_shape = (*new_data_shape,)\n\n        # Process multiplier\n        multiplier = np.array(multiplier)\n\n        # Assert multiplier value is correct\n        with np.errstate(divide='ignore'):\n            low_max_mult = ((self.margins[:,0] / self.data_source_position) + 1)\n            high_max_mult = (1 + (self.margins[:,1] / (self.data_shape - self.data_source_position)))\n            max_mult = np.min(np.vstack([low_max_mult, high_max_mult]), axis=0)\n\n            assert np.all(multiplier &lt;= max_mult), f\"The multiplier given is larger than allowed (the values should be lower than {max_mult})\"\n\n        # Compute new data shape with the multiplier\n        if new_data_shape is None:\n            new_data_shape = self.data_shape\n        new_data_shape = (new_data_shape * multiplier).astype(int)\n\n        # New source position based on multiplier\n        new_source_position = (self.data_source_position * multiplier).astype(int)\n\n        # Recomputing margins with new source position\n        self.margins[:,0] -= (new_source_position - self.data_source_position)\n        self.margins[:,1] = (shape - (self.margins[:,0] + new_data_shape))\n\n        # Re-Setting new source position\n        self.data_source_position = new_source_position\n\n        # Interpolation method choice\n        self.interpolation_method = interpolation_method\n\n        # Input the new shape of the data if set by custom shape or multiplier\n        if new_data_shape is not None:\n            self.data_shape: tuple[int] = (*new_data_shape,)\n\n        # Check if data is already processed by default\n        self.data_processed = (self.data_shape == original_data_shape)\n\n        # If requested process all the slices of data into a single\n        if preprocess_data and not self.data_processed:\n            assert self.dimensions == 2, \"Higher dimensional data doesnt support reshaping yet, ensure it is done beforehand..\"\n            if self.has_layers:\n                new_data = np.zeros((len(self.layers), self.timesteps, *self.data_shape))\n                for layer in self.layers:\n                    for i in range(self.timesteps):\n                        new_data[layer, i] = _resize_array(np.array(self._data[layer][i]),\n                                                           new_shape=self.data_shape,\n                                                           interpolation=self.interpolation_method.lower())\n            else:\n                new_data = np.zeros((self.timesteps, *self.data_shape))\n                for i in range(self.timesteps):\n                    new_data[i] = _resize_array(np.array(self._data[i]),\n                                                new_shape=self.data_shape,\n                                                interpolation=self.interpolation_method.lower())\n            self._data = new_data\n            self.data_processed = True\n\n        # Reading shape of data array\n        self.shape = (*(self.data_shape + np.sum(self.margins, axis=1)),)\n\n        # Converting the shape tuple to integer sets\n        self.shape: tuple[int] = tuple([int(el) for el in self.shape])\n        self.data_shape: tuple[int] = tuple([int(el) for el in self.data_shape])\n\n        # Building a data bounds\n        self.data_bounds = np.array([self.margins[:,0], self.margins[:,0] + np.array(self.data_shape)]).T\n\n        # Saving arguments\n        self.source_position = self.data_source_position + self.margins[:,0]\n        self.source_radius = source_radius\n\n        # Boundary conditions\n        assert not ((self.dimensions &gt; 2) and (boundary_condition in ['wrap_vertical', 'wrap_horizontal'])), \"There are more than 2 dimensions, the options of 'wrap_horizontal' and 'wrap_vertical' are disabled.\"\n        self.boundary_condition = boundary_condition\n\n        # Starting zone\n        self.start_probabilities = np.zeros(self.shape)\n        self.start_type = start_zone if isinstance(start_zone, str) else 'custom'\n\n        if isinstance(start_zone, np.ndarray):\n            if start_zone.shape == (self.dimensions,2):\n                slices = tuple(slice(low, high) for low, high in start_zone)\n                self.start_probabilities[slices] = 1.0\n                self.start_type += '_' + '_'.join([str(el) for el in start_zone.ravel()])\n            elif start_zone.shape == self.shape:\n                self.start_probabilities = start_zone\n            else:\n                raise ValueError('If an np.ndarray is provided for the start_zone it has to be |dim| x 2...')\n\n        elif start_zone == 'data_zone':\n            slices = tuple(slice(low, high) for low, high in self.data_bounds)\n            self.start_probabilities[slices] = 1.0\n\n        elif start_zone == 'odor_present':\n            if self.data_processed and isinstance(self._data, np.ndarray):\n                odor_present_map = (np.mean((self._data &gt; (odor_present_threshold if odor_present_threshold is not None else 0)).astype(int), axis=0) &gt; 0).astype(float)\n                self.start_probabilities[tuple(slice(low, high) for low, high in self.data_bounds)] = odor_present_map\n            else:\n                odor_sum = np.zeros(self.data_shape, dtype=float)\n                for i in range(self.timesteps):\n                    data_slice = np.array(self._data[i]) if not self.has_layers else np.array(self._data[0][i])\n                    reshaped_data_slice = _resize_array(data_slice,\n                                                        new_shape=self.data_shape,\n                                                        interpolation=self.interpolation_method.lower())\n                    odor_sum += (reshaped_data_slice &gt; (odor_present_threshold if odor_present_threshold is not None else 0))\n                self.start_probabilities[tuple(slice(low, high) for low, high in self.data_bounds)] = (odor_sum / self.timesteps)\n        else:\n            raise ValueError('start_zone value is wrong')\n\n        # Odor present tresh\n        self.odor_present_threshold = odor_present_threshold\n\n        # Removing the source area from the starting zone\n        source_mask = np.fromfunction((lambda *points: np.sum((np.array(points).transpose([i+1 for i in range(len(self.shape))] + [0]) - self.source_position[None,:])**2, axis=-1) &lt;= self.source_radius**2), shape=self.shape)\n        self.start_probabilities[source_mask] = 0\n        self.start_probabilities /= np.sum(self.start_probabilities) # Normalization\n\n        # Name\n        self.name = name\n        if self.name is None:\n            self.name =  '_'.join([str(axis_size) for axis_size in self.shape]) # Size of env\n            self.name += f'-marg_' + '_'.join(['_'.join([str(marg) for marg in dim_margins]) for dim_margins in self.margins]) # margins\n            self.name += f'-edge_{self.boundary_condition}' # Boundary condition\n            self.name += f'-start_{self.start_type}' # Start zone\n            self.name += f'-source_' + '_'.join([str(pos) for pos in self.source_position]) + f'_radius{self.source_radius}' # Source\n\n        # gpu support\n        self._alternate_version = None\n        self.on_gpu = False\n\n        # random state\n        self.seed = seed\n        self.rnd_state = np.random.RandomState(seed = seed)\n\n\n    @property\n    def data(self) -&gt; np.ndarray:\n        '''\n        The whole dataset with the right shape. If not preprocessed to modify its shape the data will be processed when querrying this object.\n        '''\n        if not self._data_is_numpy or not self.data_processed:\n            xp = cp if self.on_gpu else np\n            print('[Warning] The whole dataset is being querried, it will be reshaped at this time. To avoid this, avoid querrying environment.data directly.')\n\n            # Reshaping\n            if self.has_layers:\n                new_data = np.zeros((len(self.layers), self.timesteps, *self.data_shape))\n                for layer in self.layers:\n                    for i in range(self.timesteps):\n                        new_data[layer, i] = _resize_array(np.array(self._data[layer][i]),\n                                                           new_shape=self.data_shape,\n                                                           interpolation=self.interpolation_method.lower())\n            else:\n                new_data = np.zeros((self.timesteps, *self.data_shape))\n                for i in range(self.timesteps):\n                    new_data[i] = _resize_array(np.array(self._data[i]),\n                                                new_shape=self.data_shape,\n                                                interpolation=self.interpolation_method.lower())\n\n            self._data = xp.array(new_data)\n            self.data_processed = True\n\n        return self._data\n\n\n    @property\n    def _data_is_numpy(self) -&gt; bool:\n        '''\n        Wheter the data is a numpy array or not.\n        '''\n        xp = cp if self.on_gpu else np\n        return isinstance(self._data, xp.ndarray)\n\n\n    def plot(self,\n             frame: int = 0,\n             layer: int = 0,\n             ax: plt.Axes | None = None\n             ) -&gt; None:\n        '''\n        Simple function to plot the environment with a single frame of odor cues.\n        The starting zone is also market down with a blue contour.\n        The source of the odor is marked by a red circle.\n\n        Parameters\n        ----------\n        frame : int, default=0\n            The frame of odor cues to print.\n        layer : int, default=0\n            The layer of the odor cues to print. (Ignored if the environment is not layered.)\n        ax : plt.Axes, optional\n            An ax on which the environment can be plot.\n        '''\n        # If on GPU use the CPU version to plot\n        if self.on_gpu:\n            self._alternate_version.plot(\n                frame=frame,\n                ax=ax\n            )\n            return # Blank return\n\n        # TODO: Implement plotting for 3D\n        assert self.dimensions == 2, \"Plotting function only available for 2D environments for now...\"\n\n        if ax is None:\n            _, ax = plt.subplots(1, figsize=(15,5))\n\n        legend_elements = [[],[]]\n\n        # Gather data frame\n        data_frame: np.ndarray = self._data[layer][frame] if self.has_layers else self._data[frame]\n        if not isinstance(data_frame, np.ndarray):\n            data_frame = np.array(data_frame)\n\n        if not self.data_processed:\n            data_frame = _resize_array(data_frame,\n                                       new_shape=self.data_shape,\n                                       interpolation=self.interpolation_method.lower())\n\n        # Odor grid\n        odor = Rectangle([0,0], 1, 1, color='black', fill=True)\n        frame_data = (data_frame &gt; (self.odor_present_threshold if self.odor_present_threshold is not None else 0)).astype(float)\n        environment_frame = np.zeros(self.shape, dtype=float)\n        environment_frame[self.data_bounds[0,0]:self.data_bounds[0,1], self.data_bounds[1,0]:self.data_bounds[1,1]] = frame_data\n        ax.imshow(environment_frame, cmap='Greys')\n\n        legend_elements[0].append(odor)\n        legend_elements[1].append(f'Frame {frame}' + ('' if not self.has_layers else f' (layer {layer})') + ' odor cues')\n\n        # Start zone contour\n        start_zone = Rectangle([0,0], 1, 1, color='blue', fill=False)\n        ax.contour(self.start_probabilities, levels=[0.0], colors='blue')\n\n        legend_elements[0].append(start_zone)\n        legend_elements[1].append('Start zone')\n\n        # Source circle\n        goal_circle = Circle(self.source_position[::-1], self.source_radius, color='r', fill=False, zorder=10)\n        legend_elements[0].append(goal_circle)\n        legend_elements[1].append('Source')\n\n        if self.source_radius &gt; 0.0:\n            ax.add_patch(goal_circle)\n        else:\n            ax.scatter(self.source_position[1], self.source_position[0], c='red')\n\n        # Legend\n        ax.legend(legend_elements[0], legend_elements[1])\n\n\n    def get_observation(self,\n                        pos: np.ndarray,\n                        time: int | np.ndarray = 0,\n                        layer: int | np.ndarray = 0\n                        ) -&gt; float | np.ndarray:\n        '''\n        Function to get an observation at a given position on the grid at a given time.\n        A set of observations can also be requested, either at a single position for multiple timestamps or with the same amoung of positions as timestamps provided.\n\n        Note: The position will not be checked against boundary conditions; if a position is out-of-bounds it will simply return 0.0!\n\n        Parameters\n        ----------\n        pos : np.ndarray\n            The position or list of positions to get observations at.\n        time : int or np.ndarray, default=0\n            A timestamp or list of timestamps to get the observations at.\n        layer : int or np.ndarray, default=0\n            A layer or list of timestamps to get the observations at.\n            Note: If the environment doesnt have layers, this parameter will be ignored.\n\n        Returns\n        -------\n        observation : float or np.ndarray\n            A single observation or list of observations.\n        '''\n        xp = cp if self.on_gpu else np\n\n        # Handling the case of a single point\n        is_single_point = (len(pos.shape) == 1)\n        if is_single_point:\n            pos = pos[None,:]\n\n        # Counting how many position points we are dealing with\n        pos_count = len(pos)\n\n        # Time looping\n        time = time % self.timesteps\n\n        # Determine unique layers and reindexing them if needed\n        unique_layers = xp.array([layer]) if isinstance(layer, int) else xp.unique(layer)\n        layer = 0 if isinstance(layer, int) else xp.where(layer == unique_layers[:,None])[0]\n        layer_count = len(unique_layers)\n\n        # Determine unique times and reindexing them if needed\n        unique_times = xp.array([time]) if isinstance(time, int) else xp.unique(time)\n        unique_time_indices = 0 if isinstance(time, int) else xp.where(time == unique_times[:,None])[0]\n        time_count = len(unique_times)\n\n        # Handling the case where the data is a sequence of slices (h5, so not numpy array)\n        data = self._data\n\n        # Selecting the required slices\n        if self._data_is_numpy:\n            data = data[unique_layers][:,unique_times] if self.has_layers else data[unique_times]\n        else:\n            # Case where we are dealing with a h5 file\n            # Note: Can't use self.data_shape because we don't know whether the data is processed yet or no\n            selected_slices = xp.zeros((layer_count, time_count, *self._data[0][0].shape)) if self.has_layers else xp.zeros((time_count, *self._data[0].shape))\n            for i, t in enumerate(unique_times):\n                if self.has_layers:\n                    for j, l in enumerate(unique_layers):\n                        selected_slices[j,i] = xp.array(data[int(l)][int(t)])\n                else:\n                    selected_slices[i] = xp.array(data[t])\n            data = xp.array(selected_slices)\n\n        # Handle the case it needs to be processed on the fly\n        if not self.data_processed:\n            reshaped_data = xp.zeros((layer_count, time_count, *self.data_shape)) if self.has_layers else xp.zeros((time_count, *self.data_shape))\n\n            for i in range(time_count):\n                if self.has_layers:\n                    for j in range(layer_count):\n                        reshaped_data[j,i] = _resize_array(data[j,i],\n                                                           new_shape=self.data_shape,\n                                                           interpolation=self.interpolation_method.lower())\n                else:\n                    reshaped_data[i] = _resize_array(data[i],\n                                                     new_shape=self.data_shape,\n                                                     interpolation=self.interpolation_method.lower())\n\n            data = xp.array(reshaped_data)\n\n        # Return 0.0 if outside of data zone\n        data_pos = pos - self.margins[:,0][None,:]\n        data_pos_valid = xp.all((data_pos &gt;= 0) &amp; (data_pos &lt; xp.array(self.data_shape)), axis=1)\n        observation = xp.zeros(pos_count, dtype=float)\n\n        # Gathering data on layered data on not\n        if self.has_layers:\n            observation[data_pos_valid] = data[(layer if isinstance(layer, int) else layer[data_pos_valid]), # layer\n                                               (unique_time_indices if isinstance(unique_time_indices, int) else unique_time_indices[data_pos_valid]), # t\n                                               *data_pos[data_pos_valid,:].T] # physical position\n        else:\n            observation[data_pos_valid] = data[(unique_time_indices if isinstance(unique_time_indices, int) else unique_time_indices[data_pos_valid]), # t\n                                               *data_pos[data_pos_valid,:].T] # physical position\n\n        return float(observation[0]) if is_single_point else observation\n\n\n    def source_reached(self,\n                       pos: np.ndarray\n                       ) -&gt; bool | np.ndarray:\n        '''\n        Checks whether a given position is within the source radius.\n\n        Parameters\n        ----------\n        pos : np.ndarray\n            The position to check whether in the radius of the source.\n\n        Returns\n        -------\n        is_at_source : bool\n            Whether or not the position is within the radius of the source.\n        '''\n        xp = cp if self.on_gpu else np\n\n        # Handling the case of a single point\n        is_single_point = (len(pos.shape) == 1)\n        if is_single_point:\n            pos = pos[None,:]\n\n        is_at_source: np.ndarray = (xp.sum((pos - self.source_position[None,:]) ** 2, axis=-1) &lt;= (self.source_radius ** 2))\n\n        return bool(is_at_source[0]) if is_single_point else is_at_source\n\n\n    def random_start_points(self,\n                            n: int = 1\n                            ) -&gt; np.ndarray:\n        '''\n        Function to generate n starting positions following the starting probabilities.\n\n        Parameters\n        ----------\n        n : int, default=1\n            How many random starting positions to generate\n\n        Returns\n        -------\n        random_states_2d : np.ndarray\n            The n random 2d points in a n x 2 array.\n        '''\n        xp = cp if self.on_gpu else np\n\n        assert (n &gt; 0), \"n has to be a strictly positive number (&gt;0)\"\n\n        random_states = self.rnd_state.choice(xp.arange(int(np.prod(self.shape))), size=n, replace=True, p=self.start_probabilities.ravel())\n        random_states_2d = xp.array(xp.unravel_index(random_states, self.shape)).T\n        return random_states_2d\n\n\n    def move(self,\n             pos: np.ndarray,\n             movement: np.ndarray\n             ) -&gt; np.ndarray:\n        '''\n        Applies a movement vector to a position point and returns a new position point while respecting the boundary conditions.\n\n        Parameters\n        ----------\n        pos : np.ndarray\n            The start position of the movement.\n        movement : np.ndarray\n            A 2D movement vector.\n\n        Returns\n        -------\n        new_pos : np.ndarray\n            The new position after applying the movement.\n        '''\n        xp = cp if self.on_gpu else np\n\n        # Applying the movement vector\n        new_pos = pos + movement\n\n        # Handling the case we are dealing with a single point.\n        is_single_point = (len(pos.shape) == 1)\n        if is_single_point:\n            new_pos = new_pos[None,:]\n\n        shape_array = xp.array(self.shape)[None,:]\n\n        # Wrap boundary\n        if self.boundary_condition == 'wrap':\n            new_pos = xp.where(new_pos &lt; 0, (new_pos + shape_array), new_pos)\n            new_pos = xp.where(new_pos &gt;= shape_array, (new_pos - shape_array), new_pos)\n\n        # Stop boundary\n        elif self.boundary_condition == 'stop':\n            new_pos = xp.clip(new_pos, 0, (shape_array-1))\n\n        # Special wrap - vertical only\n        elif (self.dimensions == 2) and (self.boundary_condition == 'wrap_vertical'):\n            height, width = self.shape\n\n            new_pos[new_pos[:,0] &lt; 0, 0] += height\n            new_pos[new_pos[:,0] &gt;= height, 0] -= height\n\n            new_pos[:,1] = xp.clip(new_pos[:,1], 0, (width-1))\n\n        # Special wrap - horizontal only\n        elif (self.dimensions == 2) and (self.boundary_condition == 'wrap_horizontal'):\n            height, width = self.shape\n\n            new_pos[new_pos[:,1] &lt; 0, 1] += width\n            new_pos[new_pos[:,1] &gt;= width, 1] -= width\n\n            new_pos[:,0] = xp.clip(new_pos[:,0], 0, (height-1))\n\n        return new_pos[0] if is_single_point else new_pos\n\n\n    def distance_to_source(self,\n                           point: np.ndarray,\n                           metric: Literal['manhattan'] = 'manhattan'\n                           ) -&gt; float | np.ndarray:\n        '''\n        Function to compute the distance(s) between given points and the source point.\n\n        Parameters\n        ----------\n        point : np.ndarray\n            A single or an Nx2 array containing N points.\n        metric : 'manhattan'\n            The metric to use to compute the distance.\n\n        Returns\n        -------\n        dist : float or np.ndarray\n            A single distance or a list of distance in a 1D distance array.\n        '''\n        xp = cp if self.on_gpu else np\n\n        # Handling the case we have a single point\n        is_single_point = (len(point.shape) == 1)\n        if is_single_point:\n            point = point[None,:]\n\n        # Computing dist\n        dist = None\n        if metric == 'manhattan':\n            dist = xp.sum(xp.abs(self.source_position[None,:] - point), axis=-1) - self.source_radius\n\n        if dist is None: # Meaning it was not computed\n            raise NotImplementedError('This distance metric has not yet been implemented')\n\n        return float(dist[0]) if is_single_point else dist\n\n\n    def save(self,\n             folder: str | None = None,\n             save_arrays: bool = False,\n             force: bool = False\n             ) -&gt; None:\n        '''\n        Function to save the environment to the memory.\n\n        By default it saved in a new folder at the current path in a new folder with the name 'Env-&lt;name&gt;' where &lt;name&gt; is the name set when initializing an environment.\n        In this folder a file \"METADATA.json\" is created containing all the properties of the environment.\n\n        The numpy arrays of the environment (grid and start_probabilities) can be saved or not. If not, when the environment is loaded it needs to be reconstructed from the original data file.\n        The arrays are saved to .npy files along with the METADATA file.\n\n        If an environment of the same name is already saved, the saving will be interupted. It can however be forced with the force parameter.\n\n        Parameters\n        ----------\n        folder : str, optional\n            The folder to which to save the environment data. If it is not provided, it will be created in the current folder.\n        save_arrays : bool, default=False\n            Whether or not to save the numpy arrays to memory. (The arrays can be heavy)\n        force : bool, default=False\n            In case an environment of the same name is already saved, it will be overwritten.\n        '''\n        # If on gpu, use the cpu version to save\n        if self.on_gpu:\n            self._alternate_version.save(\n                folder=folder,\n                save_arrays=save_arrays,\n                force=force\n            )\n            return # Blank return\n\n        # Assert either data_file is provided or save_arrays is enabled\n        assert save_arrays or ((self.data_file_path is not None) and (self.start_type is not None)), \"The environment was not created from a data file so 'save_arrays' has to be set to True.\"\n\n        # Adding env name to folder path\n        if folder is None:\n            folder = f'./Env-{self.name}'\n        else:\n            folder += '/Env-' + self.name\n\n        # Checking the folder exists or creates it\n        if not os.path.exists(folder):\n            os.mkdir(folder)\n        elif len(os.listdir(folder)) &gt; 0:\n            if force:\n                shutil.rmtree(folder)\n                os.mkdir(folder)\n            else:\n                raise Exception(f'{folder} is not empty. If you want to overwrite the saved model, enable \"force\".')\n\n        # Generating the metadata arguments dictionary\n        arguments = {}\n        arguments['name'] = self.name\n\n        if self.data_file_path is not None:\n            arguments['data_file_path'] = self.data_file_path\n\n        arguments['timesteps']                     = int(self.timesteps)\n        arguments['data_shape']                    = self.data_shape\n        arguments['dimensions']                    = self.dimensions\n        arguments['margins']                       = self.margins.tolist()\n        arguments['shape']                         = self.shape\n        arguments['data_bounds']                   = self.data_bounds.tolist()\n        arguments['original_data_source_position'] = self.original_data_source_position.tolist()\n        arguments['data_source_position']          = self.data_source_position.tolist()\n        arguments['layers']                        = (self.layer_labels if self.has_layers else False)\n        arguments['source_position']               = self.source_position.tolist()\n        arguments['source_radius']                 = self.source_radius\n        arguments['interpolation_method']          = self.interpolation_method\n        arguments['preprocess_data']               = self._preprocess_data\n        arguments['data_processed']                = self.data_processed\n        arguments['boundary_condition']            = self.boundary_condition\n        arguments['start_type']                    = self.start_type\n        arguments['seed']                          = self.seed\n\n        # Check how the start probabilities were built\n        if self.start_type.startswith('custom') and len(self.start_type.split('_')) == 1 and not save_arrays:\n            raise Exception('Start probabilities have been set from a custom array, please enable save_arrays to be able to reconstruct the environment later.')\n\n        if self.odor_present_threshold is not None:\n            arguments['odor_present_threshold'] = self.odor_present_threshold\n\n        # Output the arguments to a METADATA file\n        with open(folder + '/METADATA.json', 'w') as json_file:\n            json.dump(arguments, json_file, indent=4)\n\n        # Output the numpy arrays\n        if save_arrays:\n            if isinstance(self._data, np.ndarray):\n                np.save(folder + '/data.npy', self._data)\n            else:\n                raise NotImplementedError('The saving of data that is not a Numpy array was not implemented yet.')\n            np.save(folder + '/start_probabilities.npy', self.start_probabilities)\n\n        # Success print\n        self.saved_at = os.path.abspath(folder).replace('\\\\', '/')\n        print(f'Environment saved to: {folder}')\n\n\n    @classmethod\n    def load(cls,\n             folder: str\n             ) -&gt; 'Environment':\n        '''\n        Function to load an environment from a given folder.\n\n        Parameters\n        ----------\n        folder : str\n            The folder of the Environment.\n\n        Returns\n        -------\n        loaded_env : Environment\n            The loaded environment.\n        '''\n        assert os.path.exists(folder), \"Folder doesn't exist...\"\n        assert folder.split('/')[-1].startswith('Env-'), \"The folder provided is not the data of en Environment object.\"\n\n        # Load arguments\n        arguments: dict = None\n        with open(folder + '/METADATA.json', 'r') as json_file:\n            arguments = json.load(json_file)\n\n        # Check if numpy arrays are provided, if not, recreate a new environment model\n        if os.path.exists(folder + '/data.npy') and os.path.exists(folder + '/start_probabilities.npy'):\n            data = np.load(folder + '/data.npy')\n            start_probabilities = np.load(folder + '/start_probabilities.npy')\n\n            loaded_env = cls.__new__(cls)\n\n            # Set the arguments\n            loaded_env.name                          = arguments['name']\n            loaded_env.timesteps                     = arguments['timesteps']\n            loaded_env.data_shape                    = arguments['data_shape']\n            loaded_env.dimensions                    = arguments['dimensions']\n            loaded_env.margins                       = np.array(arguments['margins'])\n            loaded_env.shape                         = arguments['shape']\n            loaded_env.data_bounds                   = np.array(arguments['data_bounds'])\n            loaded_env.original_data_source_position = np.array(arguments['original_data_source_position'])\n            loaded_env.data_source_position          = np.array(arguments['data_source_position'])\n            loaded_env.source_position               = np.array(arguments['source_position'])\n            loaded_env.source_radius                 = arguments['source_radius']\n            loaded_env.has_layers                    = isinstance(arguments['layers'], list)\n            loaded_env.layers                        = np.arange(len(arguments['layers'])) if loaded_env.has_layers else None\n            loaded_env.layer_labels                  = arguments['layers']\n            loaded_env.interpolation_method          = arguments['interpolation_method']\n            loaded_env._preprocess_data              = arguments['preprocess_data']\n            loaded_env.data_processed                = arguments['data_processed']\n            loaded_env.boundary_condition            = arguments['boundary_condition']\n            loaded_env.on_gpu                        = False\n            loaded_env.seed                          = arguments['seed']\n            loaded_env.rnd_state                     = np.random.RandomState(arguments['seed'])\n\n            # Optional arguments\n            loaded_env.data_file_path                = arguments.get('data_file_path')\n            loaded_env.odor_present_threshold        = arguments.get('odor_present_threshold')\n            loaded_env.start_type                    = arguments.get('start_type')\n\n            # Arrays\n            loaded_env._data = data\n            loaded_env.start_probabilities = start_probabilities\n\n        else:\n            start_zone: str = arguments['start_type']\n            start_zone_boundaries = None\n            if start_zone.startswith('custom'):\n                start_zone_boundaries = np.array(start_zone.split('_')[1:]).reshape((arguments['dimensions'],2)).astype(int)\n\n            loaded_env = Environment(\n                data_file              = arguments['data_file_path'],\n                data_source_position   = arguments['original_data_source_position'],\n                source_radius          = arguments['source_radius'],\n                layers                 = arguments['layers'],\n                shape                  = arguments['shape'],\n                margins                = arguments['margins'],\n                interpolation_method   = arguments['interpolation_method'],\n                preprocess_data        = arguments['preprocess_data'],\n                boundary_condition     = arguments['boundary_condition'],\n                start_zone             = (start_zone_boundaries if start_zone_boundaries is not None else start_zone),\n                odor_present_threshold = arguments.get('odor_present_threshold'),\n                name                   = arguments['name'],\n                seed                   = arguments['seed']\n            )\n\n        # Folder where the environment was pulled from\n        loaded_env.saved_at = os.path.abspath(folder)\n\n        return loaded_env\n\n\n    def to_gpu(self) -&gt; 'Environment':\n        '''\n        Function to send the numpy arrays of the environment to the gpu memory.\n        It returns a new instance of the Environment with the arrays as cupy arrays.\n\n        Returns\n        -------\n        gpu_environment : Environment\n            A new environment instance where the arrays are on the gpu memory.\n        '''\n        # Check whether the environment is already on the gpu or not\n        if self.on_gpu:\n            return self\n\n        # Warn and overwrite alternate_version in case it already exists\n        if self._alternate_version is not None:\n            print('[warning] A GPU instance already existed and is being recreated.')\n            self._alternate_version = None\n\n        assert gpu_support, \"GPU support is not enabled...\"\n\n        # Generating a new instance\n        cls = self.__class__\n        gpu_environment = cls.__new__(cls)\n\n        # Copying arguments to gpu\n        for arg, val in self.__dict__.items():\n            if isinstance(val, np.ndarray):\n                setattr(gpu_environment, arg, cp.array(val))\n            elif arg == 'rnd_state':\n                setattr(gpu_environment, arg, cp.random.RandomState(self.seed))\n            else:\n                setattr(gpu_environment, arg, val)\n\n        # Self reference instances\n        self._alternate_version = gpu_environment\n        gpu_environment._alternate_version = self\n\n        gpu_environment.on_gpu = True\n        return gpu_environment\n\n\n    def to_cpu(self) -&gt; 'Environment':\n        '''\n        Function to send the numpy arrays of the environment to the cpu memory.\n        It returns a new instance of the Environment with the arrays as numpy arrays.\n\n        Returns\n        -------\n        cpu_environment : Environment\n            A new environment instance where the arrays are on the cpu memory.\n        '''\n        # Check whether the agent is already on the cpu or not\n        if not self.on_gpu:\n            return self\n\n        if self._alternate_version is not None:\n            print('[warning] A CPU instance already existed and is being recreated.')\n            self._alternate_version = None\n\n        # Generating a new instance\n        cls = self.__class__\n        cpu_environment = cls.__new__(cls)\n\n        # Copying arguments to gpu\n        for arg, val in self.__dict__.items():\n            if isinstance(val, cp.ndarray):\n                setattr(cpu_environment, arg, cp.asnumpy(val))\n            elif arg == 'rnd_state':\n                setattr(cpu_environment, arg, np.random.RandomState(self.seed))\n            else:\n                setattr(cpu_environment, arg, val)\n\n        # Self reference instances\n        self._alternate_version = cpu_environment\n        cpu_environment._alternate_version = self\n\n        cpu_environment.on_gpu = True\n        return cpu_environment\n\n\n    @property\n    def gpu_version(self) -&gt; 'Environment':\n        '''\n        A version of the Environment on the GPU.\n        If the environment is already on the GPU it returns itself, otherwise the to_gpu function is called to generate a new one.\n        '''\n        if self.on_gpu:\n            return self\n        else:\n            if self._alternate_version is not None: # Check if an alternate version already exists\n                return self._alternate_version\n            else: # Generate an alternate version on the gpu\n                return self.to_gpu()\n\n\n    @property\n    def cpu_version(self) -&gt; 'Environment':\n        '''\n        A version of the Environment on the CPU.\n        If the environment is already on the CPU it returns itself, otherwise the to_cpu function is called to generate a new one.\n        '''\n        if not self.on_gpu:\n            return self\n        else:\n            if self._alternate_version is not None: # Check if an alternate version already exists\n                return self._alternate_version\n            else: # Generate an alternate version on the cpu\n                return self.to_cpu()\n\n\n    def modify(self,\n               data_source_position: list | np.ndarray | None = None,\n               source_radius: float | None = None,\n               shape: list | np.ndarray | None = None,\n               margins: int | list | np.ndarray | None = None,\n               multiplier: list | np.ndarray | None = None,\n               interpolation_method: str | None = None,\n               boundary_condition: str | None = None\n               ) -&gt; 'Environment':\n        '''\n        Returns a copy of the environment with one or more parameters modified.\n\n        Parameters\n        ----------\n        data_source_position: list or np.ndarray, optional\n            A new position for the source relative to the data file.\n        source_radius: float, optional\n            A new source radius.\n        shape: list or np.ndarray, optional\n            A new shape of environment.\n        margins: int or list or np.ndarray, optional\n            A new set of margins.\n        multiplier: list or np.ndarray, optional\n            A new multiplier to be applied to the data file (this will in turn increase or reduce the margins).\n        interpolation_method: str, optional\n            A new interpolation method to be used.\n        boundary_condition: str, optional\n            New boundary conditions for how the agent should behave at the edges.\n\n        Returns\n        -------\n        modified_environment\n            A copy of the environment where the modified parameters have been applied.\n        '''\n        if self.on_gpu:\n            cpu_environment = self.cpu_version\n            new_cpu_environment = cpu_environment.modify(\n                data_source_position = data_source_position,\n                source_radius        = source_radius,\n                shape                = shape,\n                margins              = margins,\n                multiplier           = multiplier,\n                interpolation_method = interpolation_method,\n                boundary_condition   = boundary_condition\n            )\n            return new_cpu_environment.to_gpu()\n\n        modified_environment = Environment(\n            data_file              = (self.data_file_path if (self.data_file_path is not None) else self._data),\n            data_source_position   = (data_source_position if (data_source_position is not None) else self.original_data_source_position),\n            source_radius          = (source_radius if (source_radius is not None) else self.source_radius),\n            layers                 = (self.layer_labels if self.has_layers else False),\n            shape                  = (shape if (shape is not None) else self.shape),\n            margins                = (margins if (margins is not None) else self.margins),\n            multiplier             = (multiplier if (multiplier is not None) else [1.0,1.0]),\n            interpolation_method   = (interpolation_method if (interpolation_method is not None) else self.interpolation_method),\n            preprocess_data        = self._preprocess_data,\n            boundary_condition     = (boundary_condition if (boundary_condition is not None) else self.boundary_condition),\n            start_zone             = self.start_type,\n            odor_present_threshold = self.odor_present_threshold,\n            name                   = self.name,\n            seed                   = self.seed\n        )\n        return modified_environment\n\n\n    def modify_scale(self,\n                     scale_factor: float\n                     ) -&gt; 'Environment':\n        '''\n        Function to modify the size of the environment by a scale factor.\n        Everything will be scaled this factor. This includes: shape, margins, source radius, and data shape.\n\n        Parameters\n        ----------\n        scale_factor : float\n            By how much to modify the size of the current environment.\n\n        Returns\n        -------\n        modified_environment : Environment\n            The environment with the scale factor applied.\n        '''\n        modified_source_radius = self.source_radius * scale_factor\n        modified_shape = (np.array(self.shape) * scale_factor).astype(int)\n        modified_margins = (self.margins * scale_factor).astype(int)\n\n        modified_environment = Environment(\n            data_file              = (self.data_file_path if (self.data_file_path is not None) else self._data),\n            data_source_position   = self.original_data_source_position,\n            source_radius          = modified_source_radius,\n            layers                 = (self.layer_labels if self.has_layers else False),\n            shape                  = modified_shape,\n            margins                = modified_margins,\n            multiplier             = [1.0,1.0],\n            interpolation_method   = self.interpolation_method,\n            preprocess_data        = self._preprocess_data,\n            boundary_condition     = self.boundary_condition,\n            start_zone             = self.start_type,\n            odor_present_threshold = self.odor_present_threshold,\n            name                   = self.name,\n            seed                   = self.seed\n        )\n        return modified_environment\n</code></pre>"},{"location":"reference/#olfactory_navigation.Environment.cpu_version","title":"<code>cpu_version</code>  <code>property</code>","text":"<p>A version of the Environment on the CPU. If the environment is already on the CPU it returns itself, otherwise the to_cpu function is called to generate a new one.</p>"},{"location":"reference/#olfactory_navigation.Environment.data","title":"<code>data</code>  <code>property</code>","text":"<p>The whole dataset with the right shape. If not preprocessed to modify its shape the data will be processed when querrying this object.</p>"},{"location":"reference/#olfactory_navigation.Environment.gpu_version","title":"<code>gpu_version</code>  <code>property</code>","text":"<p>A version of the Environment on the GPU. If the environment is already on the GPU it returns itself, otherwise the to_gpu function is called to generate a new one.</p>"},{"location":"reference/#olfactory_navigation.Environment.distance_to_source","title":"<code>distance_to_source(point, metric='manhattan')</code>","text":"<p>Function to compute the distance(s) between given points and the source point.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>ndarray</code> <p>A single or an Nx2 array containing N points.</p> required <code>metric</code> <code>manhattan</code> <p>The metric to use to compute the distance.</p> <code>'manhattan'</code> <p>Returns:</p> Name Type Description <code>dist</code> <code>float or ndarray</code> <p>A single distance or a list of distance in a 1D distance array.</p> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>def distance_to_source(self,\n                       point: np.ndarray,\n                       metric: Literal['manhattan'] = 'manhattan'\n                       ) -&gt; float | np.ndarray:\n    '''\n    Function to compute the distance(s) between given points and the source point.\n\n    Parameters\n    ----------\n    point : np.ndarray\n        A single or an Nx2 array containing N points.\n    metric : 'manhattan'\n        The metric to use to compute the distance.\n\n    Returns\n    -------\n    dist : float or np.ndarray\n        A single distance or a list of distance in a 1D distance array.\n    '''\n    xp = cp if self.on_gpu else np\n\n    # Handling the case we have a single point\n    is_single_point = (len(point.shape) == 1)\n    if is_single_point:\n        point = point[None,:]\n\n    # Computing dist\n    dist = None\n    if metric == 'manhattan':\n        dist = xp.sum(xp.abs(self.source_position[None,:] - point), axis=-1) - self.source_radius\n\n    if dist is None: # Meaning it was not computed\n        raise NotImplementedError('This distance metric has not yet been implemented')\n\n    return float(dist[0]) if is_single_point else dist\n</code></pre>"},{"location":"reference/#olfactory_navigation.Environment.get_observation","title":"<code>get_observation(pos, time=0, layer=0)</code>","text":"<p>Function to get an observation at a given position on the grid at a given time. A set of observations can also be requested, either at a single position for multiple timestamps or with the same amoung of positions as timestamps provided.</p> <p>Note: The position will not be checked against boundary conditions; if a position is out-of-bounds it will simply return 0.0!</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>ndarray</code> <p>The position or list of positions to get observations at.</p> required <code>time</code> <code>int or ndarray</code> <p>A timestamp or list of timestamps to get the observations at.</p> <code>0</code> <code>layer</code> <code>int or ndarray</code> <p>A layer or list of timestamps to get the observations at. Note: If the environment doesnt have layers, this parameter will be ignored.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>observation</code> <code>float or ndarray</code> <p>A single observation or list of observations.</p> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>def get_observation(self,\n                    pos: np.ndarray,\n                    time: int | np.ndarray = 0,\n                    layer: int | np.ndarray = 0\n                    ) -&gt; float | np.ndarray:\n    '''\n    Function to get an observation at a given position on the grid at a given time.\n    A set of observations can also be requested, either at a single position for multiple timestamps or with the same amoung of positions as timestamps provided.\n\n    Note: The position will not be checked against boundary conditions; if a position is out-of-bounds it will simply return 0.0!\n\n    Parameters\n    ----------\n    pos : np.ndarray\n        The position or list of positions to get observations at.\n    time : int or np.ndarray, default=0\n        A timestamp or list of timestamps to get the observations at.\n    layer : int or np.ndarray, default=0\n        A layer or list of timestamps to get the observations at.\n        Note: If the environment doesnt have layers, this parameter will be ignored.\n\n    Returns\n    -------\n    observation : float or np.ndarray\n        A single observation or list of observations.\n    '''\n    xp = cp if self.on_gpu else np\n\n    # Handling the case of a single point\n    is_single_point = (len(pos.shape) == 1)\n    if is_single_point:\n        pos = pos[None,:]\n\n    # Counting how many position points we are dealing with\n    pos_count = len(pos)\n\n    # Time looping\n    time = time % self.timesteps\n\n    # Determine unique layers and reindexing them if needed\n    unique_layers = xp.array([layer]) if isinstance(layer, int) else xp.unique(layer)\n    layer = 0 if isinstance(layer, int) else xp.where(layer == unique_layers[:,None])[0]\n    layer_count = len(unique_layers)\n\n    # Determine unique times and reindexing them if needed\n    unique_times = xp.array([time]) if isinstance(time, int) else xp.unique(time)\n    unique_time_indices = 0 if isinstance(time, int) else xp.where(time == unique_times[:,None])[0]\n    time_count = len(unique_times)\n\n    # Handling the case where the data is a sequence of slices (h5, so not numpy array)\n    data = self._data\n\n    # Selecting the required slices\n    if self._data_is_numpy:\n        data = data[unique_layers][:,unique_times] if self.has_layers else data[unique_times]\n    else:\n        # Case where we are dealing with a h5 file\n        # Note: Can't use self.data_shape because we don't know whether the data is processed yet or no\n        selected_slices = xp.zeros((layer_count, time_count, *self._data[0][0].shape)) if self.has_layers else xp.zeros((time_count, *self._data[0].shape))\n        for i, t in enumerate(unique_times):\n            if self.has_layers:\n                for j, l in enumerate(unique_layers):\n                    selected_slices[j,i] = xp.array(data[int(l)][int(t)])\n            else:\n                selected_slices[i] = xp.array(data[t])\n        data = xp.array(selected_slices)\n\n    # Handle the case it needs to be processed on the fly\n    if not self.data_processed:\n        reshaped_data = xp.zeros((layer_count, time_count, *self.data_shape)) if self.has_layers else xp.zeros((time_count, *self.data_shape))\n\n        for i in range(time_count):\n            if self.has_layers:\n                for j in range(layer_count):\n                    reshaped_data[j,i] = _resize_array(data[j,i],\n                                                       new_shape=self.data_shape,\n                                                       interpolation=self.interpolation_method.lower())\n            else:\n                reshaped_data[i] = _resize_array(data[i],\n                                                 new_shape=self.data_shape,\n                                                 interpolation=self.interpolation_method.lower())\n\n        data = xp.array(reshaped_data)\n\n    # Return 0.0 if outside of data zone\n    data_pos = pos - self.margins[:,0][None,:]\n    data_pos_valid = xp.all((data_pos &gt;= 0) &amp; (data_pos &lt; xp.array(self.data_shape)), axis=1)\n    observation = xp.zeros(pos_count, dtype=float)\n\n    # Gathering data on layered data on not\n    if self.has_layers:\n        observation[data_pos_valid] = data[(layer if isinstance(layer, int) else layer[data_pos_valid]), # layer\n                                           (unique_time_indices if isinstance(unique_time_indices, int) else unique_time_indices[data_pos_valid]), # t\n                                           *data_pos[data_pos_valid,:].T] # physical position\n    else:\n        observation[data_pos_valid] = data[(unique_time_indices if isinstance(unique_time_indices, int) else unique_time_indices[data_pos_valid]), # t\n                                           *data_pos[data_pos_valid,:].T] # physical position\n\n    return float(observation[0]) if is_single_point else observation\n</code></pre>"},{"location":"reference/#olfactory_navigation.Environment.load","title":"<code>load(folder)</code>  <code>classmethod</code>","text":"<p>Function to load an environment from a given folder.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>The folder of the Environment.</p> required <p>Returns:</p> Name Type Description <code>loaded_env</code> <code>Environment</code> <p>The loaded environment.</p> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>@classmethod\ndef load(cls,\n         folder: str\n         ) -&gt; 'Environment':\n    '''\n    Function to load an environment from a given folder.\n\n    Parameters\n    ----------\n    folder : str\n        The folder of the Environment.\n\n    Returns\n    -------\n    loaded_env : Environment\n        The loaded environment.\n    '''\n    assert os.path.exists(folder), \"Folder doesn't exist...\"\n    assert folder.split('/')[-1].startswith('Env-'), \"The folder provided is not the data of en Environment object.\"\n\n    # Load arguments\n    arguments: dict = None\n    with open(folder + '/METADATA.json', 'r') as json_file:\n        arguments = json.load(json_file)\n\n    # Check if numpy arrays are provided, if not, recreate a new environment model\n    if os.path.exists(folder + '/data.npy') and os.path.exists(folder + '/start_probabilities.npy'):\n        data = np.load(folder + '/data.npy')\n        start_probabilities = np.load(folder + '/start_probabilities.npy')\n\n        loaded_env = cls.__new__(cls)\n\n        # Set the arguments\n        loaded_env.name                          = arguments['name']\n        loaded_env.timesteps                     = arguments['timesteps']\n        loaded_env.data_shape                    = arguments['data_shape']\n        loaded_env.dimensions                    = arguments['dimensions']\n        loaded_env.margins                       = np.array(arguments['margins'])\n        loaded_env.shape                         = arguments['shape']\n        loaded_env.data_bounds                   = np.array(arguments['data_bounds'])\n        loaded_env.original_data_source_position = np.array(arguments['original_data_source_position'])\n        loaded_env.data_source_position          = np.array(arguments['data_source_position'])\n        loaded_env.source_position               = np.array(arguments['source_position'])\n        loaded_env.source_radius                 = arguments['source_radius']\n        loaded_env.has_layers                    = isinstance(arguments['layers'], list)\n        loaded_env.layers                        = np.arange(len(arguments['layers'])) if loaded_env.has_layers else None\n        loaded_env.layer_labels                  = arguments['layers']\n        loaded_env.interpolation_method          = arguments['interpolation_method']\n        loaded_env._preprocess_data              = arguments['preprocess_data']\n        loaded_env.data_processed                = arguments['data_processed']\n        loaded_env.boundary_condition            = arguments['boundary_condition']\n        loaded_env.on_gpu                        = False\n        loaded_env.seed                          = arguments['seed']\n        loaded_env.rnd_state                     = np.random.RandomState(arguments['seed'])\n\n        # Optional arguments\n        loaded_env.data_file_path                = arguments.get('data_file_path')\n        loaded_env.odor_present_threshold        = arguments.get('odor_present_threshold')\n        loaded_env.start_type                    = arguments.get('start_type')\n\n        # Arrays\n        loaded_env._data = data\n        loaded_env.start_probabilities = start_probabilities\n\n    else:\n        start_zone: str = arguments['start_type']\n        start_zone_boundaries = None\n        if start_zone.startswith('custom'):\n            start_zone_boundaries = np.array(start_zone.split('_')[1:]).reshape((arguments['dimensions'],2)).astype(int)\n\n        loaded_env = Environment(\n            data_file              = arguments['data_file_path'],\n            data_source_position   = arguments['original_data_source_position'],\n            source_radius          = arguments['source_radius'],\n            layers                 = arguments['layers'],\n            shape                  = arguments['shape'],\n            margins                = arguments['margins'],\n            interpolation_method   = arguments['interpolation_method'],\n            preprocess_data        = arguments['preprocess_data'],\n            boundary_condition     = arguments['boundary_condition'],\n            start_zone             = (start_zone_boundaries if start_zone_boundaries is not None else start_zone),\n            odor_present_threshold = arguments.get('odor_present_threshold'),\n            name                   = arguments['name'],\n            seed                   = arguments['seed']\n        )\n\n    # Folder where the environment was pulled from\n    loaded_env.saved_at = os.path.abspath(folder)\n\n    return loaded_env\n</code></pre>"},{"location":"reference/#olfactory_navigation.Environment.modify","title":"<code>modify(data_source_position=None, source_radius=None, shape=None, margins=None, multiplier=None, interpolation_method=None, boundary_condition=None)</code>","text":"<p>Returns a copy of the environment with one or more parameters modified.</p> <p>Parameters:</p> Name Type Description Default <code>data_source_position</code> <code>list | ndarray | None</code> <p>A new position for the source relative to the data file.</p> <code>None</code> <code>source_radius</code> <code>float | None</code> <p>A new source radius.</p> <code>None</code> <code>shape</code> <code>list | ndarray | None</code> <p>A new shape of environment.</p> <code>None</code> <code>margins</code> <code>int | list | ndarray | None</code> <p>A new set of margins.</p> <code>None</code> <code>multiplier</code> <code>list | ndarray | None</code> <p>A new multiplier to be applied to the data file (this will in turn increase or reduce the margins).</p> <code>None</code> <code>interpolation_method</code> <code>str | None</code> <p>A new interpolation method to be used.</p> <code>None</code> <code>boundary_condition</code> <code>str | None</code> <p>New boundary conditions for how the agent should behave at the edges.</p> <code>None</code> <p>Returns:</p> Type Description <code>modified_environment</code> <p>A copy of the environment where the modified parameters have been applied.</p> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>def modify(self,\n           data_source_position: list | np.ndarray | None = None,\n           source_radius: float | None = None,\n           shape: list | np.ndarray | None = None,\n           margins: int | list | np.ndarray | None = None,\n           multiplier: list | np.ndarray | None = None,\n           interpolation_method: str | None = None,\n           boundary_condition: str | None = None\n           ) -&gt; 'Environment':\n    '''\n    Returns a copy of the environment with one or more parameters modified.\n\n    Parameters\n    ----------\n    data_source_position: list or np.ndarray, optional\n        A new position for the source relative to the data file.\n    source_radius: float, optional\n        A new source radius.\n    shape: list or np.ndarray, optional\n        A new shape of environment.\n    margins: int or list or np.ndarray, optional\n        A new set of margins.\n    multiplier: list or np.ndarray, optional\n        A new multiplier to be applied to the data file (this will in turn increase or reduce the margins).\n    interpolation_method: str, optional\n        A new interpolation method to be used.\n    boundary_condition: str, optional\n        New boundary conditions for how the agent should behave at the edges.\n\n    Returns\n    -------\n    modified_environment\n        A copy of the environment where the modified parameters have been applied.\n    '''\n    if self.on_gpu:\n        cpu_environment = self.cpu_version\n        new_cpu_environment = cpu_environment.modify(\n            data_source_position = data_source_position,\n            source_radius        = source_radius,\n            shape                = shape,\n            margins              = margins,\n            multiplier           = multiplier,\n            interpolation_method = interpolation_method,\n            boundary_condition   = boundary_condition\n        )\n        return new_cpu_environment.to_gpu()\n\n    modified_environment = Environment(\n        data_file              = (self.data_file_path if (self.data_file_path is not None) else self._data),\n        data_source_position   = (data_source_position if (data_source_position is not None) else self.original_data_source_position),\n        source_radius          = (source_radius if (source_radius is not None) else self.source_radius),\n        layers                 = (self.layer_labels if self.has_layers else False),\n        shape                  = (shape if (shape is not None) else self.shape),\n        margins                = (margins if (margins is not None) else self.margins),\n        multiplier             = (multiplier if (multiplier is not None) else [1.0,1.0]),\n        interpolation_method   = (interpolation_method if (interpolation_method is not None) else self.interpolation_method),\n        preprocess_data        = self._preprocess_data,\n        boundary_condition     = (boundary_condition if (boundary_condition is not None) else self.boundary_condition),\n        start_zone             = self.start_type,\n        odor_present_threshold = self.odor_present_threshold,\n        name                   = self.name,\n        seed                   = self.seed\n    )\n    return modified_environment\n</code></pre>"},{"location":"reference/#olfactory_navigation.Environment.modify_scale","title":"<code>modify_scale(scale_factor)</code>","text":"<p>Function to modify the size of the environment by a scale factor. Everything will be scaled this factor. This includes: shape, margins, source radius, and data shape.</p> <p>Parameters:</p> Name Type Description Default <code>scale_factor</code> <code>float</code> <p>By how much to modify the size of the current environment.</p> required <p>Returns:</p> Name Type Description <code>modified_environment</code> <code>Environment</code> <p>The environment with the scale factor applied.</p> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>def modify_scale(self,\n                 scale_factor: float\n                 ) -&gt; 'Environment':\n    '''\n    Function to modify the size of the environment by a scale factor.\n    Everything will be scaled this factor. This includes: shape, margins, source radius, and data shape.\n\n    Parameters\n    ----------\n    scale_factor : float\n        By how much to modify the size of the current environment.\n\n    Returns\n    -------\n    modified_environment : Environment\n        The environment with the scale factor applied.\n    '''\n    modified_source_radius = self.source_radius * scale_factor\n    modified_shape = (np.array(self.shape) * scale_factor).astype(int)\n    modified_margins = (self.margins * scale_factor).astype(int)\n\n    modified_environment = Environment(\n        data_file              = (self.data_file_path if (self.data_file_path is not None) else self._data),\n        data_source_position   = self.original_data_source_position,\n        source_radius          = modified_source_radius,\n        layers                 = (self.layer_labels if self.has_layers else False),\n        shape                  = modified_shape,\n        margins                = modified_margins,\n        multiplier             = [1.0,1.0],\n        interpolation_method   = self.interpolation_method,\n        preprocess_data        = self._preprocess_data,\n        boundary_condition     = self.boundary_condition,\n        start_zone             = self.start_type,\n        odor_present_threshold = self.odor_present_threshold,\n        name                   = self.name,\n        seed                   = self.seed\n    )\n    return modified_environment\n</code></pre>"},{"location":"reference/#olfactory_navigation.Environment.move","title":"<code>move(pos, movement)</code>","text":"<p>Applies a movement vector to a position point and returns a new position point while respecting the boundary conditions.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>ndarray</code> <p>The start position of the movement.</p> required <code>movement</code> <code>ndarray</code> <p>A 2D movement vector.</p> required <p>Returns:</p> Name Type Description <code>new_pos</code> <code>ndarray</code> <p>The new position after applying the movement.</p> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>def move(self,\n         pos: np.ndarray,\n         movement: np.ndarray\n         ) -&gt; np.ndarray:\n    '''\n    Applies a movement vector to a position point and returns a new position point while respecting the boundary conditions.\n\n    Parameters\n    ----------\n    pos : np.ndarray\n        The start position of the movement.\n    movement : np.ndarray\n        A 2D movement vector.\n\n    Returns\n    -------\n    new_pos : np.ndarray\n        The new position after applying the movement.\n    '''\n    xp = cp if self.on_gpu else np\n\n    # Applying the movement vector\n    new_pos = pos + movement\n\n    # Handling the case we are dealing with a single point.\n    is_single_point = (len(pos.shape) == 1)\n    if is_single_point:\n        new_pos = new_pos[None,:]\n\n    shape_array = xp.array(self.shape)[None,:]\n\n    # Wrap boundary\n    if self.boundary_condition == 'wrap':\n        new_pos = xp.where(new_pos &lt; 0, (new_pos + shape_array), new_pos)\n        new_pos = xp.where(new_pos &gt;= shape_array, (new_pos - shape_array), new_pos)\n\n    # Stop boundary\n    elif self.boundary_condition == 'stop':\n        new_pos = xp.clip(new_pos, 0, (shape_array-1))\n\n    # Special wrap - vertical only\n    elif (self.dimensions == 2) and (self.boundary_condition == 'wrap_vertical'):\n        height, width = self.shape\n\n        new_pos[new_pos[:,0] &lt; 0, 0] += height\n        new_pos[new_pos[:,0] &gt;= height, 0] -= height\n\n        new_pos[:,1] = xp.clip(new_pos[:,1], 0, (width-1))\n\n    # Special wrap - horizontal only\n    elif (self.dimensions == 2) and (self.boundary_condition == 'wrap_horizontal'):\n        height, width = self.shape\n\n        new_pos[new_pos[:,1] &lt; 0, 1] += width\n        new_pos[new_pos[:,1] &gt;= width, 1] -= width\n\n        new_pos[:,0] = xp.clip(new_pos[:,0], 0, (height-1))\n\n    return new_pos[0] if is_single_point else new_pos\n</code></pre>"},{"location":"reference/#olfactory_navigation.Environment.plot","title":"<code>plot(frame=0, layer=0, ax=None)</code>","text":"<p>Simple function to plot the environment with a single frame of odor cues. The starting zone is also market down with a blue contour. The source of the odor is marked by a red circle.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>The frame of odor cues to print.</p> <code>0</code> <code>layer</code> <code>int</code> <p>The layer of the odor cues to print. (Ignored if the environment is not layered.)</p> <code>0</code> <code>ax</code> <code>Axes</code> <p>An ax on which the environment can be plot.</p> <code>None</code> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>def plot(self,\n         frame: int = 0,\n         layer: int = 0,\n         ax: plt.Axes | None = None\n         ) -&gt; None:\n    '''\n    Simple function to plot the environment with a single frame of odor cues.\n    The starting zone is also market down with a blue contour.\n    The source of the odor is marked by a red circle.\n\n    Parameters\n    ----------\n    frame : int, default=0\n        The frame of odor cues to print.\n    layer : int, default=0\n        The layer of the odor cues to print. (Ignored if the environment is not layered.)\n    ax : plt.Axes, optional\n        An ax on which the environment can be plot.\n    '''\n    # If on GPU use the CPU version to plot\n    if self.on_gpu:\n        self._alternate_version.plot(\n            frame=frame,\n            ax=ax\n        )\n        return # Blank return\n\n    # TODO: Implement plotting for 3D\n    assert self.dimensions == 2, \"Plotting function only available for 2D environments for now...\"\n\n    if ax is None:\n        _, ax = plt.subplots(1, figsize=(15,5))\n\n    legend_elements = [[],[]]\n\n    # Gather data frame\n    data_frame: np.ndarray = self._data[layer][frame] if self.has_layers else self._data[frame]\n    if not isinstance(data_frame, np.ndarray):\n        data_frame = np.array(data_frame)\n\n    if not self.data_processed:\n        data_frame = _resize_array(data_frame,\n                                   new_shape=self.data_shape,\n                                   interpolation=self.interpolation_method.lower())\n\n    # Odor grid\n    odor = Rectangle([0,0], 1, 1, color='black', fill=True)\n    frame_data = (data_frame &gt; (self.odor_present_threshold if self.odor_present_threshold is not None else 0)).astype(float)\n    environment_frame = np.zeros(self.shape, dtype=float)\n    environment_frame[self.data_bounds[0,0]:self.data_bounds[0,1], self.data_bounds[1,0]:self.data_bounds[1,1]] = frame_data\n    ax.imshow(environment_frame, cmap='Greys')\n\n    legend_elements[0].append(odor)\n    legend_elements[1].append(f'Frame {frame}' + ('' if not self.has_layers else f' (layer {layer})') + ' odor cues')\n\n    # Start zone contour\n    start_zone = Rectangle([0,0], 1, 1, color='blue', fill=False)\n    ax.contour(self.start_probabilities, levels=[0.0], colors='blue')\n\n    legend_elements[0].append(start_zone)\n    legend_elements[1].append('Start zone')\n\n    # Source circle\n    goal_circle = Circle(self.source_position[::-1], self.source_radius, color='r', fill=False, zorder=10)\n    legend_elements[0].append(goal_circle)\n    legend_elements[1].append('Source')\n\n    if self.source_radius &gt; 0.0:\n        ax.add_patch(goal_circle)\n    else:\n        ax.scatter(self.source_position[1], self.source_position[0], c='red')\n\n    # Legend\n    ax.legend(legend_elements[0], legend_elements[1])\n</code></pre>"},{"location":"reference/#olfactory_navigation.Environment.random_start_points","title":"<code>random_start_points(n=1)</code>","text":"<p>Function to generate n starting positions following the starting probabilities.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>How many random starting positions to generate</p> <code>1</code> <p>Returns:</p> Name Type Description <code>random_states_2d</code> <code>ndarray</code> <p>The n random 2d points in a n x 2 array.</p> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>def random_start_points(self,\n                        n: int = 1\n                        ) -&gt; np.ndarray:\n    '''\n    Function to generate n starting positions following the starting probabilities.\n\n    Parameters\n    ----------\n    n : int, default=1\n        How many random starting positions to generate\n\n    Returns\n    -------\n    random_states_2d : np.ndarray\n        The n random 2d points in a n x 2 array.\n    '''\n    xp = cp if self.on_gpu else np\n\n    assert (n &gt; 0), \"n has to be a strictly positive number (&gt;0)\"\n\n    random_states = self.rnd_state.choice(xp.arange(int(np.prod(self.shape))), size=n, replace=True, p=self.start_probabilities.ravel())\n    random_states_2d = xp.array(xp.unravel_index(random_states, self.shape)).T\n    return random_states_2d\n</code></pre>"},{"location":"reference/#olfactory_navigation.Environment.save","title":"<code>save(folder=None, save_arrays=False, force=False)</code>","text":"<p>Function to save the environment to the memory.</p> <p>By default it saved in a new folder at the current path in a new folder with the name 'Env-' where  is the name set when initializing an environment. In this folder a file \"METADATA.json\" is created containing all the properties of the environment. <p>The numpy arrays of the environment (grid and start_probabilities) can be saved or not. If not, when the environment is loaded it needs to be reconstructed from the original data file. The arrays are saved to .npy files along with the METADATA file.</p> <p>If an environment of the same name is already saved, the saving will be interupted. It can however be forced with the force parameter.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>The folder to which to save the environment data. If it is not provided, it will be created in the current folder.</p> <code>None</code> <code>save_arrays</code> <code>bool</code> <p>Whether or not to save the numpy arrays to memory. (The arrays can be heavy)</p> <code>False</code> <code>force</code> <code>bool</code> <p>In case an environment of the same name is already saved, it will be overwritten.</p> <code>False</code> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>def save(self,\n         folder: str | None = None,\n         save_arrays: bool = False,\n         force: bool = False\n         ) -&gt; None:\n    '''\n    Function to save the environment to the memory.\n\n    By default it saved in a new folder at the current path in a new folder with the name 'Env-&lt;name&gt;' where &lt;name&gt; is the name set when initializing an environment.\n    In this folder a file \"METADATA.json\" is created containing all the properties of the environment.\n\n    The numpy arrays of the environment (grid and start_probabilities) can be saved or not. If not, when the environment is loaded it needs to be reconstructed from the original data file.\n    The arrays are saved to .npy files along with the METADATA file.\n\n    If an environment of the same name is already saved, the saving will be interupted. It can however be forced with the force parameter.\n\n    Parameters\n    ----------\n    folder : str, optional\n        The folder to which to save the environment data. If it is not provided, it will be created in the current folder.\n    save_arrays : bool, default=False\n        Whether or not to save the numpy arrays to memory. (The arrays can be heavy)\n    force : bool, default=False\n        In case an environment of the same name is already saved, it will be overwritten.\n    '''\n    # If on gpu, use the cpu version to save\n    if self.on_gpu:\n        self._alternate_version.save(\n            folder=folder,\n            save_arrays=save_arrays,\n            force=force\n        )\n        return # Blank return\n\n    # Assert either data_file is provided or save_arrays is enabled\n    assert save_arrays or ((self.data_file_path is not None) and (self.start_type is not None)), \"The environment was not created from a data file so 'save_arrays' has to be set to True.\"\n\n    # Adding env name to folder path\n    if folder is None:\n        folder = f'./Env-{self.name}'\n    else:\n        folder += '/Env-' + self.name\n\n    # Checking the folder exists or creates it\n    if not os.path.exists(folder):\n        os.mkdir(folder)\n    elif len(os.listdir(folder)) &gt; 0:\n        if force:\n            shutil.rmtree(folder)\n            os.mkdir(folder)\n        else:\n            raise Exception(f'{folder} is not empty. If you want to overwrite the saved model, enable \"force\".')\n\n    # Generating the metadata arguments dictionary\n    arguments = {}\n    arguments['name'] = self.name\n\n    if self.data_file_path is not None:\n        arguments['data_file_path'] = self.data_file_path\n\n    arguments['timesteps']                     = int(self.timesteps)\n    arguments['data_shape']                    = self.data_shape\n    arguments['dimensions']                    = self.dimensions\n    arguments['margins']                       = self.margins.tolist()\n    arguments['shape']                         = self.shape\n    arguments['data_bounds']                   = self.data_bounds.tolist()\n    arguments['original_data_source_position'] = self.original_data_source_position.tolist()\n    arguments['data_source_position']          = self.data_source_position.tolist()\n    arguments['layers']                        = (self.layer_labels if self.has_layers else False)\n    arguments['source_position']               = self.source_position.tolist()\n    arguments['source_radius']                 = self.source_radius\n    arguments['interpolation_method']          = self.interpolation_method\n    arguments['preprocess_data']               = self._preprocess_data\n    arguments['data_processed']                = self.data_processed\n    arguments['boundary_condition']            = self.boundary_condition\n    arguments['start_type']                    = self.start_type\n    arguments['seed']                          = self.seed\n\n    # Check how the start probabilities were built\n    if self.start_type.startswith('custom') and len(self.start_type.split('_')) == 1 and not save_arrays:\n        raise Exception('Start probabilities have been set from a custom array, please enable save_arrays to be able to reconstruct the environment later.')\n\n    if self.odor_present_threshold is not None:\n        arguments['odor_present_threshold'] = self.odor_present_threshold\n\n    # Output the arguments to a METADATA file\n    with open(folder + '/METADATA.json', 'w') as json_file:\n        json.dump(arguments, json_file, indent=4)\n\n    # Output the numpy arrays\n    if save_arrays:\n        if isinstance(self._data, np.ndarray):\n            np.save(folder + '/data.npy', self._data)\n        else:\n            raise NotImplementedError('The saving of data that is not a Numpy array was not implemented yet.')\n        np.save(folder + '/start_probabilities.npy', self.start_probabilities)\n\n    # Success print\n    self.saved_at = os.path.abspath(folder).replace('\\\\', '/')\n    print(f'Environment saved to: {folder}')\n</code></pre>"},{"location":"reference/#olfactory_navigation.Environment.source_reached","title":"<code>source_reached(pos)</code>","text":"<p>Checks whether a given position is within the source radius.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>ndarray</code> <p>The position to check whether in the radius of the source.</p> required <p>Returns:</p> Name Type Description <code>is_at_source</code> <code>bool</code> <p>Whether or not the position is within the radius of the source.</p> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>def source_reached(self,\n                   pos: np.ndarray\n                   ) -&gt; bool | np.ndarray:\n    '''\n    Checks whether a given position is within the source radius.\n\n    Parameters\n    ----------\n    pos : np.ndarray\n        The position to check whether in the radius of the source.\n\n    Returns\n    -------\n    is_at_source : bool\n        Whether or not the position is within the radius of the source.\n    '''\n    xp = cp if self.on_gpu else np\n\n    # Handling the case of a single point\n    is_single_point = (len(pos.shape) == 1)\n    if is_single_point:\n        pos = pos[None,:]\n\n    is_at_source: np.ndarray = (xp.sum((pos - self.source_position[None,:]) ** 2, axis=-1) &lt;= (self.source_radius ** 2))\n\n    return bool(is_at_source[0]) if is_single_point else is_at_source\n</code></pre>"},{"location":"reference/#olfactory_navigation.Environment.to_cpu","title":"<code>to_cpu()</code>","text":"<p>Function to send the numpy arrays of the environment to the cpu memory. It returns a new instance of the Environment with the arrays as numpy arrays.</p> <p>Returns:</p> Name Type Description <code>cpu_environment</code> <code>Environment</code> <p>A new environment instance where the arrays are on the cpu memory.</p> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>def to_cpu(self) -&gt; 'Environment':\n    '''\n    Function to send the numpy arrays of the environment to the cpu memory.\n    It returns a new instance of the Environment with the arrays as numpy arrays.\n\n    Returns\n    -------\n    cpu_environment : Environment\n        A new environment instance where the arrays are on the cpu memory.\n    '''\n    # Check whether the agent is already on the cpu or not\n    if not self.on_gpu:\n        return self\n\n    if self._alternate_version is not None:\n        print('[warning] A CPU instance already existed and is being recreated.')\n        self._alternate_version = None\n\n    # Generating a new instance\n    cls = self.__class__\n    cpu_environment = cls.__new__(cls)\n\n    # Copying arguments to gpu\n    for arg, val in self.__dict__.items():\n        if isinstance(val, cp.ndarray):\n            setattr(cpu_environment, arg, cp.asnumpy(val))\n        elif arg == 'rnd_state':\n            setattr(cpu_environment, arg, np.random.RandomState(self.seed))\n        else:\n            setattr(cpu_environment, arg, val)\n\n    # Self reference instances\n    self._alternate_version = cpu_environment\n    cpu_environment._alternate_version = self\n\n    cpu_environment.on_gpu = True\n    return cpu_environment\n</code></pre>"},{"location":"reference/#olfactory_navigation.Environment.to_gpu","title":"<code>to_gpu()</code>","text":"<p>Function to send the numpy arrays of the environment to the gpu memory. It returns a new instance of the Environment with the arrays as cupy arrays.</p> <p>Returns:</p> Name Type Description <code>gpu_environment</code> <code>Environment</code> <p>A new environment instance where the arrays are on the gpu memory.</p> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>def to_gpu(self) -&gt; 'Environment':\n    '''\n    Function to send the numpy arrays of the environment to the gpu memory.\n    It returns a new instance of the Environment with the arrays as cupy arrays.\n\n    Returns\n    -------\n    gpu_environment : Environment\n        A new environment instance where the arrays are on the gpu memory.\n    '''\n    # Check whether the environment is already on the gpu or not\n    if self.on_gpu:\n        return self\n\n    # Warn and overwrite alternate_version in case it already exists\n    if self._alternate_version is not None:\n        print('[warning] A GPU instance already existed and is being recreated.')\n        self._alternate_version = None\n\n    assert gpu_support, \"GPU support is not enabled...\"\n\n    # Generating a new instance\n    cls = self.__class__\n    gpu_environment = cls.__new__(cls)\n\n    # Copying arguments to gpu\n    for arg, val in self.__dict__.items():\n        if isinstance(val, np.ndarray):\n            setattr(gpu_environment, arg, cp.array(val))\n        elif arg == 'rnd_state':\n            setattr(gpu_environment, arg, cp.random.RandomState(self.seed))\n        else:\n            setattr(gpu_environment, arg, val)\n\n    # Self reference instances\n    self._alternate_version = gpu_environment\n    gpu_environment._alternate_version = self\n\n    gpu_environment.on_gpu = True\n    return gpu_environment\n</code></pre>"},{"location":"reference/#olfactory_navigation.SimulationHistory","title":"<code>SimulationHistory</code>","text":"<p>Class to record the steps that happened during a simulation with the following information being saved:</p> <ul> <li>the positions the agents pass by</li> <li>the actions the agents take</li> <li>the observations the agents receive ('observations')</li> <li>the time in the simulation process</li> </ul> <p>Parameters:</p> Name Type Description Default <code>start_points</code> <code>ndarray</code> <p>The initial points of the agents in the simulation.</p> required <code>environment</code> <code>Environment</code> <p>The environment on which the simulation is run (can be different from the one associated with the agent).</p> required <code>agent</code> <code>Agent</code> <p>The agent used in the simulation.</p> required <code>time_shift</code> <code>ndarray</code> <p>An array of time shifts in the simulation data.</p> required <code>horizon</code> <code>int</code> <p>The horizon of the simulation. i.e. how many steps can be taken by the agent during the simulation before he is considered lost.</p> required <code>reward_discount</code> <code>float</code> <p>A discount to be applied to the rewards received by the agent. (eg: reward of 1 received at time n would be: 1 * reward_discount^n)</p> <code>0.99</code> <p>Attributes:</p> Name Type Description <code>start_points</code> <code>ndarray</code> <code>environment</code> <code>Environment</code> <code>agent</code> <code>Agent</code> <code>time_shift</code> <code>ndarray</code> <code>horizon</code> <code>int</code> <code>reward_discount</code> <code>float</code> <code>environment_dimensions</code> <code>int</code> <p>The amount of dimensions of the environment.</p> <code>environment_shape</code> <code>tuple[int]</code> <p>The shape of the environment.</p> <code>environment_source_position</code> <code>ndarray</code> <p>The position of the odor source in the environment.</p> <code>environment_source_radius</code> <code>float</code> <p>The radius of the odor source in the environment.</p> <code>environment_layer_labels</code> <code>list[str] or None</code> <p>A list of the layer labels if the environment has layers.</p> <code>agent_thresholds</code> <code>ndarray</code> <p>An array of the olfaction thresholds of the agent.</p> <code>n</code> <code>int</code> <p>The amount of simulations.</p> <code>actions</code> <code>list[ndarray]</code> <p>A list of numpy arrays. At each step of the simulation, an array of shape n by 2 is appended to this list representing the n actions as dy,dx vectors.</p> <code>positions</code> <code>list[ndarray]</code> <p>A list of numpy arrays. At each step of the simulation, an array of shape n by 2 is appended to this list representing the n positions as y,x vectors.</p> <code>observations</code> <code>list[ndarray]</code> <p>A list of numpy arrays. At each step of the simulation, an array of shape n is appended to this list representing the n observations received by the agents.</p> <code>timestamps</code> <code>dict[int, list[datetime]]</code> <p>A dictionay of the timestamps at which the simulation steps were recorded where the key is the id of the first run with these timestamps.</p> <code>reached_source</code> <code>ndarray</code> <p>A numpy array of booleans saying whether the simulations reached the source or not.</p> <code>done_at_step</code> <code>ndarray</code> <p>A numpy array containing n elements that records when a given simulation reaches the source (-1 is not reached).</p> <code>start_time</code> <code>datetime</code> <p>The time at which the first simulation was started.</p> <code>simulation_dfs</code> <code>list[DataFrame]</code> <p>A list of the pandas DataFrame where each dataframe is a single simulation history.</p> <code>runs_analysis_df</code> <code>DataFrame</code> <p>A Pandas DataFrame analyzing the results of the simulations.</p> <code>general_analysis_df</code> <code>DataFrame</code> <p>A Pandas DataFrame analyzing the results of the simulations.</p> <code>done_count</code> <code>int</code> <p>How many simulations are terminated (whether they reached the source or not).</p> <code>successful_simulation</code> <code>ndarray</code> <p>A boolean array of which simulations reached the source.</p> <code>success_count</code> <code>int</code> <p>How many simulations reached the source.</p> <code>simulations_at_horizon</code> <code>ndarray</code> <p>A boolean array of which simulations reached the horizon.</p> <code>summary</code> <code>str</code> <p>A string summarizing the performances of all the simulations.</p> Source code in <code>olfactory_navigation/simulation.py</code> <pre><code>class SimulationHistory:\n    '''\n    Class to record the steps that happened during a simulation with the following information being saved:\n\n    - the positions the agents pass by\n    - the actions the agents take\n    - the observations the agents receive ('observations')\n    - the time in the simulation process\n\n\n    Parameters\n    ----------\n    start_points : np.ndarray\n        The initial points of the agents in the simulation.\n    environment : Environment\n        The environment on which the simulation is run (can be different from the one associated with the agent).\n    agent : Agent\n        The agent used in the simulation.\n    time_shift : np.ndarray\n        An array of time shifts in the simulation data.\n    horizon : int\n        The horizon of the simulation. i.e. how many steps can be taken by the agent during the simulation before he is considered lost.\n    reward_discount : float, default=0.99\n        A discount to be applied to the rewards received by the agent. (eg: reward of 1 received at time n would be: 1 * reward_discount^n)\n\n    Attributes\n    ----------\n    start_points : np.ndarray\n    environment : Environment\n    agent : Agent\n    time_shift : np.ndarray\n    horizon : int\n    reward_discount : float\n    environment_dimensions : int\n        The amount of dimensions of the environment.\n    environment_shape : tuple[int]\n        The shape of the environment.\n    environment_source_position : np.ndarray\n        The position of the odor source in the environment.\n    environment_source_radius : float\n        The radius of the odor source in the environment.\n    environment_layer_labels : list[str] or None\n        A list of the layer labels if the environment has layers.\n    agent_thresholds : np.ndarray\n        An array of the olfaction thresholds of the agent.\n    n : int\n        The amount of simulations.\n    actions : list[np.ndarray]\n        A list of numpy arrays. At each step of the simulation, an array of shape n by 2 is appended to this list representing the n actions as dy,dx vectors.\n    positions : list[np.ndarray]\n        A list of numpy arrays. At each step of the simulation, an array of shape n by 2 is appended to this list representing the n positions as y,x vectors.\n    observations : list[np.ndarray]\n        A list of numpy arrays. At each step of the simulation, an array of shape n is appended to this list representing the n observations received by the agents.\n    timestamps : dict[int, list[datetime]]\n        A dictionay of the timestamps at which the simulation steps were recorded where the key is the id of the first run with these timestamps.\n    reached_source : np.ndarray\n        A numpy array of booleans saying whether the simulations reached the source or not.\n    done_at_step : np.ndarray\n        A numpy array containing n elements that records when a given simulation reaches the source (-1 is not reached).\n    start_time : datetime\n        The time at which the first simulation was started.\n    simulation_dfs : list[pd.DataFrame]\n        A list of the pandas DataFrame where each dataframe is a single simulation history.\n    runs_analysis_df : pd.DataFrame\n        A Pandas DataFrame analyzing the results of the simulations.\n    general_analysis_df : pd.DataFrame\n        A Pandas DataFrame analyzing the results of the simulations.\n    done_count : int\n        How many simulations are terminated (whether they reached the source or not).\n    successful_simulation : np.ndarray\n        A boolean array of which simulations reached the source.\n    success_count : int\n        How many simulations reached the source.\n    simulations_at_horizon : np.ndarray\n        A boolean array of which simulations reached the horizon.\n    summary : str\n        A string summarizing the performances of all the simulations.\n    '''\n    def __init__(self,\n                 start_points: np.ndarray,\n                 environment: Environment,\n                 agent: Agent,\n                 time_shift: np.ndarray,\n                 horizon: int,\n                 reward_discount: float = 0.99\n                 ) -&gt; None:\n        # If only on state is provided, we make it a 1x2 vector\n        if len(start_points.shape) == 1:\n            start_points = start_points[None,:]\n\n        # Fixed parameters\n        self.n = len(start_points)\n        self.environment = environment.cpu_version\n        self.agent = agent.cpu_version\n        self.time_shift = time_shift if gpu_support and cp.get_array_module(time_shift) == np else cp.asnumpy(time_shift)\n        self.horizon = horizon\n        self.reward_discount = reward_discount\n\n        # Simulation Tracking\n        self.start_points = start_points if gpu_support and cp.get_array_module(start_points) == np else cp.asnumpy(start_points)\n        self.actions = []\n        self.positions = []\n        self.observations = []\n        self.timestamps = {0: [datetime.now()]}\n\n        self._running_sims = np.arange(self.n)\n        self.reached_source = np.zeros(self.n, dtype=bool)\n        self.done_at_step = np.full(self.n, fill_value=-1)\n\n        # Environment and agent attributes\n        self.environment_dimensions = self.environment.dimensions\n        self.environment_shape = self.environment.shape\n        self.environment_source_position = self.environment.source_position\n        self.environment_source_radius = self.environment.source_radius\n        self.environment_layer_labels = self.environment.layer_labels\n        self.agent_thresholds = self.agent.thresholds\n\n        # Other parameters\n        self._simulation_dfs = None\n\n\n    def add_step(self,\n                 actions: np.ndarray,\n                 next_positions: np.ndarray,\n                 observations: np.ndarray,\n                 reached_source: np.ndarray,\n                 interupt: np.ndarray\n                 ) -&gt; None:\n        '''\n        Function to add a step in the simulation history.\n\n        Parameters\n        ----------\n        actions : np.ndarray\n            The actions that were taken by the agents.\n        next_positions : np.ndarray\n            The positions that were reached by the agents after having taken actions.\n        observations : np.ndarray\n            The observations the agents receive after having taken actions.\n        reached_source : np.ndarray\n            A boolean array of whether each agent has reached the source or not.\n        interupt : np.ndarray\n            A boolean array of whether each agent has to be terminated even if it hasnt reached the source yet.\n        '''\n        self._simulation_dfs = None\n\n        # Time tracking\n        self.timestamps[0].append(datetime.now())\n\n        # Check if environment if layered and/or 3D\n        layered = 0 if self.environment_layer_labels is None else 1\n\n        # Handle case cupy arrays are provided\n        if gpu_support:\n            actions = actions if cp.get_array_module(actions) == np else cp.asnumpy(actions)\n            next_positions = next_positions if cp.get_array_module(next_positions) == np else cp.asnumpy(next_positions)\n            observations = observations if cp.get_array_module(observations) == np else cp.asnumpy(observations)\n            reached_source = reached_source if cp.get_array_module(reached_source) == np else cp.asnumpy(reached_source)\n            interupt = interupt if cp.get_array_module(interupt) == np else cp.asnumpy(interupt)\n\n        # Actions tracking\n        action_all_sims = np.full((self.n, (layered + self.environment_dimensions)), fill_value=-1)\n        action_all_sims[self._running_sims] = actions\n        self.actions.append(action_all_sims)\n\n        # Next states tracking\n        next_position_all_sims = np.full((self.n, self.environment_dimensions), fill_value=-1)\n        next_position_all_sims[self._running_sims] = next_positions\n        self.positions.append(next_position_all_sims)\n\n        # Observation tracking\n        observation_all_sims = np.full((self.n,), fill_value=-1, dtype=float)\n        observation_all_sims[self._running_sims] = observations\n        self.observations.append(observation_all_sims)\n\n        # Recording at which step the simulation is done if it is done and whether it reached the source\n        self.done_at_step[self._running_sims[reached_source | interupt]] = len(self.positions)\n        self.reached_source[self._running_sims[reached_source]] = True\n\n        # Updating the list of running sims\n        self._running_sims = self._running_sims[~reached_source &amp; ~interupt]\n\n\n    def compute_distance_to_source(self) -&gt; np.ndarray:\n        '''\n        Function to compute the optimal distance to the source of each starting point according to the optimal_distance_metric attribute.\n\n        Returns\n        -------\n        distance : np.ndarray\n            The optimal distances to the source point.\n        '''\n        point = self.start_points\n\n        # Handling the case we have a single point\n        is_single_point = (len(point.shape) == 1)\n        if is_single_point:\n            point = point[None,:]\n\n        # Computing dist\n        dist = None\n        # if self.optimal_distance_metric == 'manhattan': # TODO Allow for other metrics to be used\n        dist = np.sum(np.abs(self.environment_source_position[None,:] - point), axis=-1) - self.environment_source_radius\n\n        if dist is None: # Meaning it was not computed\n            raise NotImplementedError('This distance metric has not yet been implemented')\n\n        return float(dist[0]) if is_single_point else dist\n\n\n    @property\n    def runs_analysis_df(self) -&gt; pd.DataFrame:\n        '''\n        A Pandas DataFrame analyzing the results of the simulations.\n        It aggregates the simulations in single rows, recording:\n\n         - &lt;axis&gt;:              The starting positions at the given axis\n         - optimal_steps_count: The minimal amount of steps to reach the source\n         - converged:           Whether or not the simulation reached the source\n         - reached_horizon:     Whether the failed simulation reached to horizon\n         - steps_taken:         The amount of steps the agent took to reach the source, (horizon if the simulation did not reach the source)\n         - discounted_rewards:  The discounted reward received by the agent over the course of the simulation\n         - extra_steps:         The amount of extra steps compared to the optimal trajectory\n         - t_min_over_t:        Normalized version of the extra steps measure, where it tends to 1 the least amount of time the agent took to reach the source compared to an optimal trajectory.\n        '''\n        # Get axes labels\n        axes_labels = None\n        if self.environment_dimensions &lt;= 3:\n            axes_labels = ['z', 'y', 'x'][-self.environment_dimensions:]\n        else:\n            axes_labels = [f'x{i}' for i in range(self.environment_dimensions)]\n\n        # Dataframe creation\n        df = pd.DataFrame(self.start_points, columns=axes_labels)\n        df['optimal_steps_count'] = self.compute_distance_to_source()\n        df['converged'] = self.reached_source\n        df['reached_horizon'] = np.all(self.positions[-1] != -1, axis=1) &amp; ~self.reached_source &amp; (len(self.positions) == self.horizon)\n        df['steps_taken'] = np.where(self.done_at_step &gt;= 0, self.done_at_step, len(self.positions))\n        df['discounted_rewards'] = self.reward_discount ** df['steps_taken']\n        df['extra_steps'] = df['steps_taken'] - df['optimal_steps_count']\n        df['t_min_over_t'] = df['optimal_steps_count'] / df['steps_taken']\n\n        # Reindex\n        runs_list = [f'run_{i}' for i in range(self.n)]\n        df.index = runs_list\n\n        return df\n\n\n    @property\n    def general_analysis_df(self) -&gt; pd.DataFrame:\n        '''\n        A Pandas DataFrame analyzing the results of the simulations.\n        Summarizing the performance of all the simulations with the following metrics:\n\n         - converged:           Whether or not the simulation reached the source\n         - reached_horizon:     Whether the failed simulation reached to horizon\n         - steps_taken:         The amount of steps the agent took to reach the source, (horizon if the simulation did not reach the source)\n         - discounted_rewards:  The discounted reward received by the agent over the course of the simulation\n         - extra_steps:         The amount of extra steps compared to the optimal trajectory\n         - t_min_over_t:        Normalized version of the extra steps measure, where it tends to 1 the least amount of time the agent took to reach the source compared to an optimal trajectory.\n\n        For the measures (converged, steps_taken, discounted_rewards, extra_steps, t_min_over_t), the average and standard deviations are computed in rows at the top.\n        '''\n        df = self.runs_analysis_df\n\n        # Analysis aggregations\n        columns_to_analyze = ['converged', 'reached_horizon', 'steps_taken', 'discounted_rewards', 'extra_steps', 't_min_over_t']\n        row_names = [['mean', 'standard_deviation', 'success_mean', 'success_standard_deviation']]\n        general_analysis_data = [\n            df[columns_to_analyze].mean(),\n            df[columns_to_analyze].std(),\n            df.loc[df['converged'], columns_to_analyze].mean(),\n            df.loc[df['converged'], columns_to_analyze].std()\n        ]\n\n        return pd.DataFrame(data=general_analysis_data, index=row_names, columns=columns_to_analyze)\n\n\n    @property\n    def done_count(self) -&gt; int:\n        '''\n        Returns how many simulations are terminated (whether they reached the source or not).\n        '''\n        return self.n - len(self._running_sims)\n\n\n    @property\n    def successful_simulation(self) -&gt; np.ndarray:\n        return self.reached_source\n\n\n    @property\n    def success_count(self) -&gt; int:\n        '''\n        Returns how many simulations reached the source.\n        '''\n        return int(np.sum(self.successful_simulation))\n\n\n    @property\n    def simulations_at_horizon(self) -&gt; np.ndarray:\n        '''\n        Returns a boolean array of which simulations reached the horizon.\n        '''\n        last_position_exists = np.all(self.positions[-1] != -1, axis=1)\n        simulation_reached_horizon = (len(self.positions) == self.horizon)\n        return last_position_exists &amp; ~self.reached_source &amp; simulation_reached_horizon\n\n\n    @property\n    def summary(self) -&gt; str:\n        '''\n        A string summarizing the performances of all the simulations.\n        The metrics used are averages of:\n\n         - Step count\n         - Extra steps\n         - Discounted rewards\n         - Tmin / T\n\n        Along with the respective the standard deviations and equally for only for the successful simulations.\n        '''\n        success_sim_count = self.success_count\n        failed_count = self.n - success_sim_count\n        reached_horizon_count = int(np.sum(self.simulations_at_horizon))\n        summary_str = f'Simulations reached goal: {success_sim_count}/{self.n} ({failed_count} failures (reached horizon: {reached_horizon_count})) ({(success_sim_count*100)/self.n:.2f}% success)'\n\n        if success_sim_count == 0:\n            return summary_str\n\n        # Metrics\n        df = self.general_analysis_df\n\n        summary_str += f\"\\n - {'Average step count:':&lt;35} {df.loc['mean','steps_taken'].item():.3f} +- {df.loc['standard_deviation','steps_taken'].item():.2f} \"\n        summary_str += f\"(Successful only: {df.loc['success_mean','steps_taken'].item():.3f} +- {df.loc['success_standard_deviation','steps_taken'].item():.2f})\"\n\n        summary_str += f\"\\n - {'Extra steps:':&lt;35} {df.loc['mean','extra_steps'].item():.3f} +- {df.loc['standard_deviation','extra_steps'].item():.2f} \"\n        summary_str += f\"(Successful only: {df.loc['success_mean','extra_steps'].item():.3f} +- {df.loc['success_standard_deviation','extra_steps'].item():.2f})\"\n\n        summary_str += f\"\\n - {'Average discounted rewards (ADR):':&lt;35} {df.loc['mean','discounted_rewards'].item():.3f} +- {df.loc['standard_deviation','discounted_rewards'].item():.2f} \"\n        summary_str += f\"(Successful only: {df.loc['success_mean','discounted_rewards'].item():.3f} +- {df.loc['success_standard_deviation','discounted_rewards'].item():.2f})\"\n\n        summary_str += f\"\\n - {'Tmin/T:':&lt;35} {df.loc['mean','t_min_over_t'].item():.3f} +- {df.loc['standard_deviation','t_min_over_t'].item():.2f} \"\n        summary_str += f\"(Successful only: {df.loc['success_mean','t_min_over_t'].item():.3f} +- {df.loc['success_standard_deviation','t_min_over_t'].item():.2f})\"\n\n        return summary_str\n\n\n    @property\n    def start_time(self) -&gt; datetime:\n        '''\n        The time at which the first simulation was started.\n        '''\n        return self.timestamps[0][0]\n\n\n    @property\n    def simulation_dfs(self) -&gt; list[pd.DataFrame]:\n        '''\n        A list of the pandas DataFrame where each dataframe is a single simulation history.\n        Each row is a different time instant of simulation process with each column being:\n\n         - time (of the simulation data)\n         - [position] (z,) y, x  OR  x0, x1, ... xn\n         - (layer)\n         - [movement] (dz,) dy, dx  OR  dx0, dx1, ... dxn\n         - o (pure, not thresholded)\n         - reached_source (boolean)\n        '''\n        if self._simulation_dfs is None:\n            self._simulation_dfs = []\n\n            # Converting state, actions and observation to numpy arrays\n            states_array = np.array(self.positions)\n            action_array = np.array(self.actions)\n            observation_array = np.array(self.observations)\n\n            # Get axes labels\n            axes_labels = None\n            if self.environment_dimensions &lt;= 3:\n                axes_labels = ['z', 'y', 'x'][-self.environment_dimensions:]\n            else:\n                axes_labels = [f'x{i}' for i in range(self.environment_dimensions)]\n\n            # Loop through the n simulations\n            for i in range(self.n):\n                length = self.done_at_step[i] if self.done_at_step[i] &gt;= 0 else len(states_array)\n\n                # Creation of the dataframe\n                df = {}\n                df['time'] = np.arange(length+1) + self.time_shift[i]\n\n                # - Position variables\n                for axis_i, axis in enumerate(axes_labels):\n                    df[axis] = np.hstack([self.start_points[i, axis_i], states_array[:length, i, axis_i]])\n\n                # - Action variables\n                if self.environment_layer_labels is not None:\n                    df['layer'] = np.hstack([[None], action_array[:length, i, 0]])\n\n                for axis_i, axis in enumerate(axes_labels):\n                    axis_i += (0 if self.environment_layer_labels is None else 1)\n                    df['d' + axis]   = np.hstack([[None], action_array[:length, i, axis_i]])\n\n                # - Other variables\n                df['o'] = np.hstack([[None], observation_array[:length, i]])\n                df['reached_source'] = np.hstack([[None], np.where(np.arange(1,length+1) == self.done_at_step[i], (1 if self.reached_source[i] else 0), 0)])\n\n                # Append\n                self._simulation_dfs.append(pd.DataFrame(df))\n\n        return self._simulation_dfs\n\n\n    def __add__(self, other_hist: 'SimulationHistory'):\n        # Asserting the SimulationHistory objects are compatible\n        assert self.horizon == other_hist.horizon, \"The 'horizon' parameters must match between the two SimulationHistory objects...\"\n        assert self.reward_discount == other_hist.reward_discount, \"The 'reward_discount' parameters must match between the two SimulationHistory objects...\"\n        assert self.environment_dimensions == other_hist.environment_dimensions, \"The 'environment_dimensions' parameters must match between the two SimulationHistory objects...\"\n        assert self.environment_shape == other_hist.environment_shape, \"The 'environment_shape' parameters must match between the two SimulationHistory objects...\"\n        assert self.environment_layer_labels == other_hist.environment_layer_labels, \"The 'environment_layer_labels' parameters must match between the two SimulationHistory objects...\"\n        assert all(self.environment_source_position == other_hist.environment_source_position), \"The 'environment_source_position' parameters must match between the two SimulationHistory objects...\"\n        assert self.environment_source_radius == other_hist.environment_source_radius, \"The 'environment_source_radius' parameters must match between the two SimulationHistory objects...\"\n        assert all(self.agent_thresholds == other_hist.agent_thresholds), \"The 'agent_thresholds' parameters must match between the two SimulationHistory objects...\"\n\n        # Combining arrays\n        combined_start_points = np.vstack([self.start_points,\n                                           other_hist.start_points])\n        combined_time_shifts = np.hstack([self.time_shift,\n                                          other_hist.time_shift])\n        combined_reached_source = np.hstack([self.reached_source,\n                                             other_hist.reached_source])\n        combined_done_at_step = np.hstack([self.done_at_step,\n                                           other_hist.done_at_step])\n\n        combined_actions = []\n        combined_positions = []\n        combined_observations = []\n        for step_i in range(max([len(self.actions), len(other_hist.actions)])):\n            self_in_range = (step_i &lt; len(self.actions))\n            other_in_range = (step_i &lt; len(other_hist.actions))\n            combined_actions.append(np.vstack([self.actions[step_i] if self_in_range else np.full_like(self.actions[0], fill_value=-1),\n                                               other_hist.actions[step_i] if other_in_range else np.full_like(other_hist.actions[0], fill_value=-1)]))\n            combined_positions.append(np.vstack([self.positions[step_i] if self_in_range else np.full_like(self.positions[0], fill_value=-1),\n                                                 other_hist.positions[step_i] if other_in_range else np.full_like(other_hist.positions[0], fill_value=-1)]))\n            combined_observations.append(np.hstack([self.observations[step_i] if self_in_range else np.full_like(self.observations[0], fill_value=-1),\n                                                    other_hist.observations[step_i] if other_in_range else np.full_like(other_hist.observations[0], fill_value=-1)]))\n\n        # Combining timestamps\n        combined_timestamps = self.timestamps | {k + self.n: v for k,v in other_hist.timestamps.items()}\n\n        # Creating the combined simulation history object\n        combined_hist = SimulationHistory.__new__(SimulationHistory)\n\n        combined_hist.n = self.n + other_hist.n\n        combined_hist.environment = self.environment.cpu_version if self.environment is not None else (other_hist.environment.cpu_version if other_hist.environment is not None else None)\n        combined_hist.agent = self.agent.cpu_version if self.agent is not None else (other_hist.agent.cpu_version if other_hist.agent is not None else None)\n        combined_hist.time_shift = combined_time_shifts\n        combined_hist.horizon = self.horizon\n        combined_hist.reward_discount = self.reward_discount\n\n        combined_hist.start_points = combined_start_points\n        combined_hist._running_sims = None\n\n        combined_hist.positions = combined_positions\n        combined_hist.actions = combined_actions\n        combined_hist.observations = combined_observations\n        combined_hist.reached_source = combined_reached_source\n        combined_hist.done_at_step = combined_done_at_step\n        combined_hist.timestamps = combined_timestamps\n\n        # Other attributes\n        combined_hist.environment_dimensions = self.environment_dimensions\n        combined_hist.environment_shape = self.environment_shape\n        combined_hist.environment_source_position = self.environment_source_position\n        combined_hist.environment_source_radius = self.environment_source_radius\n        combined_hist.environment_layer_labels = self.environment_layer_labels\n        combined_hist.agent_thresholds = self.agent_thresholds\n        combined_hist._simulation_dfs = None\n\n        return combined_hist\n\n\n    def save(self,\n             file: str | None = None,\n             folder: str | None = None,\n             save_analysis: bool = True,\n             save_components: bool = False\n             ) -&gt; None:\n        '''\n        Function to save the simulation history to a csv file in a given folder.\n        Additionally, an analysis of the runs can be saved if the save_analysis is enabled.\n        The environment and agent used can be saved in the saved folder by enabling the 'save_component' parameter.\n\n        Parameters\n        ----------\n        file : str, optional\n            The name of the file the simulation histories will be saved to.\n            If it is not provided, it will be by default \"Simulations-&lt;env_name&gt;-n_&lt;sim_count&gt;-&lt;sim_start_timestamp&gt;-horizon_&lt;max_sim_length&gt;.csv\"\n        folder : str, optional\n            Folder to save the simulation histories to.\n            If the folder name is not provided the current folder will be used.\n        save_analysis : bool, default=True\n            Whether to save an additional csv file with an analysis of the runs of the simulation.\n            It will contain the amount of steps taken, the amount of extra steps compared to optimality, the discounted rewards and the ratio between optimal trajectory and the steps taken.\n            The means and standard deviations of all the runs are also computed.\n            The file will have the same name as the simulation history file with an additional '-analysis' tag at the end.\n        save_components : bool, default=False\n            Whether or not to save the environment and agent along with the simulation histories in the given folder.\n        '''\n        assert (self.environment is not None) and (self.agent is not None), \"Function not available, the agent and/or the environment is not set.\"\n\n        # Handle file name\n        if file is None:\n            env_name = f's_' + '_'.join([str(axis_shape) for axis_shape in self.environment_shape])\n            file = f'Simulations-{env_name}-n_{self.n}-{self.timestamps[0][0].strftime(\"%Y%m%d_%H%M%S\")}-horizon_{len(self.positions)}.csv'\n\n        if not file.endswith('.csv'):\n            file += '.csv'\n\n        # Handle folder\n        if folder is None:\n            folder = './'\n\n        if '/' not in folder:\n            folder = './' + folder\n\n        if not os.path.exists(folder):\n            os.mkdir(folder)\n\n        if not folder.endswith('/'):\n            folder += '/'\n\n        # Save components if requested\n        if save_components:\n            if (self.environment.saved_at is None) or (folder not in self.environment.saved_at):\n                self.environment.save(folder=folder)\n\n            if (self.agent.saved_at is None) or (folder not in self.agent.saved_at):\n                self.agent.save(folder=folder)\n\n        # Create csv file\n        combined_df = pd.concat(self.simulation_dfs)\n\n        # timestamps information\n        simulation_lengths = np.array([len(df) for df in self.simulation_dfs])\n        timestamps_column = [None] * len(combined_df)\n        for n_start, run_timestamps in self.timestamps.items():\n            i_start = np.sum(simulation_lengths[:n_start])\n            for ts_i, ts in enumerate(run_timestamps):\n                timestamps_column[i_start + ts_i] = (ts.strftime('%Y%m%d_%H%M%S%f') if ts_i == 0 else ts.strftime('%H%M%S%f'))\n        combined_df['timestamps'] = timestamps_column\n\n        # Adding other useful info\n        padding = [None] * len(combined_df)\n        combined_df['horizon'] = [self.horizon] + padding[:-1]\n        combined_df['reward_discount'] = [self.reward_discount] + padding[:-1]\n\n        environment_info = [\n            self.environment.name,\n            self.environment.saved_at,\n            str(self.environment_dimensions), # int\n            '_'.join(str(axis_size) for axis_size in self.environment_shape),\n            '_'.join(str(axis_position) for axis_position in self.environment_source_position),\n            str(self.environment_source_radius), # float\n            '' if (self.environment_layer_labels is None) else '&amp;'.join(self.environment_layer_labels) # Using '&amp;' as splitter as '_' could be used in the labels themselves\n        ]\n        combined_df['environment'] = (environment_info + padding[:-len(environment_info)])\n\n        # Converting the thresholds array to a string to be saved\n        thresholds_string = ''\n        if len(self.agent_thresholds.shape) == 2:\n            thresholds_string = '&amp;'.join(['_'.join([str(item) for item in row]) for row_i, row in enumerate(self.agent_thresholds[:,1:-1])]) # Using '&amp;' as layer splitter as '-' can be used for negative thresholds\n        else:\n            thresholds_string = '_'.join([str(item) for item in self.agent_thresholds])\n\n        agent_info = [\n            self.agent.name,\n            self.agent.class_name,\n            self.agent.saved_at,\n            thresholds_string\n        ]\n        combined_df['agent'] = (agent_info + padding[:-len(agent_info)])\n\n        # Saving csv\n        combined_df.to_csv(folder + file, index=False)\n\n        print(f'Simulations saved to: {folder + file}')\n\n        if save_analysis:\n            runs_analysis_file_name = file.replace('.csv', '-runs_analysis.csv')\n            self.runs_analysis_df.to_csv(folder + runs_analysis_file_name)\n            print(f\"Simulation's runs analysis saved to: {folder + runs_analysis_file_name}\")\n\n            general_analysis_file_name = file.replace('.csv', '-general_analysis.csv')\n            self.general_analysis_df.to_csv(folder + general_analysis_file_name)\n            print(f\"Simulation's general analysis saved to: {folder + general_analysis_file_name}\")\n\n\n    @classmethod\n    def load_from_file(cls,\n                       file: str,\n                       environment: bool | Environment = False,\n                       agent: bool | Agent = False\n                       ) -&gt; 'SimulationHistory':\n        return cls.load(file, environment, agent)\n\n\n    @classmethod\n    def load(cls,\n             file: str,\n             environment: bool | Environment = False,\n             agent: bool | Agent = False\n             ) -&gt; 'SimulationHistory':\n        '''\n        Function to load the simulation history from a file.\n        This can be useful to use the plot functions on the simulations saved in such file.\n\n        The environment and agent can provided as a backup in the case they cannot be loaded from the file.\n\n        Parameters\n        ----------\n        file : str\n            A file (with the path) of the simulation histories csv. (the analysis file cannot be used for this)\n        environment : bool or Environment, default=False\n            If set to True, it will try to load the environment that was used for the simulation (if the save path is available).\n            Or, an environment instance to be linked with the simulation history object.\n        agent : bool or Agent, default=False\n            If set to True, it will try to load the agent that was used for the simulation (if the save path is available).\n            An agent instance to be linked with the simulation history object.\n\n        Returns\n        -------\n        hist : SimulationHistory\n            The loaded instance of a simulation history object.\n        '''\n        # Retrieving columns\n        with open(file, 'r') as f:\n            header = f.readline()\n        columns = header.replace('\\n','').split(',')\n\n        # Setting the datatypes of columns\n        column_dtypes = {col: float for col in columns}\n        column_dtypes['time'] = int\n        if 'layer' in columns:\n            column_dtypes['layer'] = int\n        column_dtypes['timestamps'] = str\n        column_dtypes['environment'] = str\n        column_dtypes['agent'] = str\n\n        # Retrieving the combined dataframe\n        combined_df = pd.read_csv(file, dtype=column_dtypes)\n\n        # Retrieving horizon and reward discount\n        horizon = int(combined_df['horizon'][0])\n        reward_discount = combined_df['reward_discount'][0]\n\n        # Retrieving environment\n        if (not isinstance(environment, Environment)) and (environment == True):\n            environment_name = combined_df['environment'][0]\n            environment_path = combined_df['environment'][1]\n\n            environment_path_check = (environment_path is not None) and (not np.isnan(environment_path))\n            assert environment_path_check, \"Environment was not saved at the time of the saving of the simulation history. Input an environment to the environment parameter or toggle the parameter to False.\"\n\n            try:\n                environment = Environment.load(environment_path)\n            except:\n                print(f'Failed to retrieve \"{environment_name}\" environment from memory')\n\n        # Retrieving agent\n        if (not isinstance(agent, Agent)) and (agent == True):\n            agent_name = combined_df['environment'][0]\n            agent_class = combined_df['environment'][1]\n            agent_path = combined_df['environment'][2]\n\n            agent_path_check = (agent_path is not None) and (not np.isnan(agent_path))\n            assert agent_path_check, \"Agent was not saved at the time of the saving of the simulation history. Input an agent to the agent parameter or toggle the parameter to False.\"\n\n            try:\n                class_instance = None\n                for (class_name, class_obj) in inspect.getmembers(sys.modules[__name__], inspect.isclass):\n                    if class_name == agent_class:\n                        class_instance = class_obj\n                        break\n                agent = class_instance.load(combined_df['agent'][2])\n            except:\n                print(f'Failed to retrieve \"{agent_name}\" agent from memory')\n\n        # Other attributes\n        environment_dimensions = int(combined_df['environment'][2])\n        environment_shape = tuple([int(axis_shape) for axis_shape in combined_df['environment'][3].split('_')])\n        environment_source_position = np.array([float(pos_axis) for pos_axis in combined_df['environment'][4].split('_')])\n        environment_source_radius = float(combined_df['environment'][5])\n        layer_entery = combined_df['environment'][6]\n        environment_layer_labels = (None if ((not isinstance(layer_entery, str)) or (len(layer_entery) == 0)) else layer_entery.split('&amp;'))\n\n        # Processing the threshold string\n        thresholds_string = str(combined_df['agent'][3])\n        if '&amp;' in thresholds_string:\n            rows_thresholds_string = thresholds_string.split('&amp;')\n            layer_thresholds = []\n            for row in rows_thresholds_string:\n                layer_thresholds.append(np.array(row.split('_')).astype(float))\n            agent_thresholds = np.array(layer_thresholds)\n\n        else:\n            agent_thresholds = np.array(np.array(thresholds_string.split('_')).astype(float))\n\n        # Columns to retrieve\n        columns = [col for col in columns if col not in ['reward_discount', 'environment', 'agent']]\n\n        # Checking how many dimensions there are\n        has_layers = (((len(columns) - 5) % 2) == 1)\n        dimensions = int((len(columns) - 5) / 2)\n\n        # Recreation of list of simulations\n        sim_start_rows = np.argwhere(combined_df[['reached_source']].isnull())[1:,0]\n\n        simulation_arrays = np.split(combined_df[columns].to_numpy(), sim_start_rows)\n        simulation_dfs = [pd.DataFrame(sim_array, columns=columns) for sim_array in simulation_arrays]\n\n        # Making a combined numpy array with all the simulations\n        sizes = np.array([len(sim_array) for sim_array in simulation_arrays])\n        max_length = sizes.max()\n        paddings = max_length - sizes\n\n        padded_simulation_arrays = [np.pad(sim_arr, ((0,pad),(0,0)), constant_values=-1) for sim_arr, pad in zip(simulation_arrays, paddings)]\n        all_simulation_arrays = np.array(padded_simulation_arrays).transpose((1,0,2))\n\n        # Timeshift\n        time_shift = all_simulation_arrays[0,:,0].astype(int)\n\n        # Gathering start states\n        start_points = all_simulation_arrays[0,:,1:(1+dimensions)].astype(int)\n\n        # Recreating action, state and observations\n        positions = all_simulation_arrays[1:, :, 1:(1+dimensions)]\n        actions = all_simulation_arrays[1:, :, (1+dimensions):((1+dimensions) + (1 if has_layers else 0) + dimensions)]\n        observations = all_simulation_arrays[1:, :, ((1+dimensions) + (1 if has_layers else 0) + dimensions)]\n        reached_source = np.array([(df['reached_source'][len(df)-1] == 1) for df in simulation_dfs])\n        done_at_step = np.where((sizes-1 &lt; horizon), sizes-1, -1)\n\n        # Building SimulationHistory instance\n        hist = cls.__new__(cls)\n\n        hist.n = len(start_points)\n        hist.environment = environment.cpu_version if isinstance(environment, Environment) else None\n        hist.agent = agent.cpu_version if isinstance(agent, Agent) else None\n        hist.time_shift = time_shift\n        hist.horizon = horizon\n        hist.reward_discount = reward_discount\n\n        hist.start_points = start_points\n        hist._running_sims = None\n\n        hist.positions = [*positions]\n        hist.actions = [*actions]\n        hist.observations = [*observations]\n        hist.reached_source = reached_source\n        hist.done_at_step = done_at_step\n\n        # Reading timestamps\n        timestamp_column = combined_df['timestamps']\n        timestamp_groups = np.concatenate([np.argwhere(timestamp_column.str.contains('_') == True)[:,0], [len(timestamp_column)]])\n        timestamps = {}\n\n        # Reading each group of timestamps (representing of each run)\n        for group_i, (group_start, group_end) in enumerate(zip(timestamp_groups[:-1], timestamp_groups[1:])):\n            timestamp_group = timestamp_column[group_start:group_end]\n\n            # Initial read of the group\n            first_timestamp = timestamp_group.iloc[0]\n            timestamp_day = first_timestamp[:9]\n            timestamp_count = np.sum(timestamp_group.notna())\n            timestamp_string_list = timestamp_group[:timestamp_count].to_list()\n\n            day_delta = timedelta(days=0)\n            timestamp_list = [datetime.strptime(timestamp_string_list[0], '%Y%m%d_%H%M%S%f')]\n\n            # Reading each timestamp of the list\n            for timestamp_string in timestamp_string_list[1:]:\n                timestamp_string = timestamp_day + str(timestamp_string)\n                timestamp = datetime.strptime(timestamp_string, '%Y%m%d_%H%M%S%f') + day_delta\n\n                # If timestamp is smaller than the previous one, it means it is a new day and the day_delta has to be increased\n                if timestamp &lt; timestamp_list[-1]:\n                    day_delta += timedelta(days=1)\n                    timestamp += timedelta(days=1)\n\n                timestamp_list.append(timestamp)\n\n            # Adding the timestamps to the general dictionary\n            associate_run_i = np.argwhere(np.concatenate([[0], sim_start_rows]) == group_start)[0,0]\n            timestamps[associate_run_i] = timestamp_list\n\n        # Warn if no timestamps were found\n        if len(timestamps) == 0:\n            print('[Warning] No timestamps were found in the loaded simulation history...')\n\n        hist.timestamps = timestamps\n\n        # Other attributes\n        hist.environment_dimensions = environment_dimensions\n        hist.environment_shape = environment_shape\n        hist.environment_source_position = environment_source_position\n        hist.environment_source_radius = environment_source_radius\n        hist.environment_layer_labels = environment_layer_labels\n        hist.agent_thresholds = agent_thresholds\n\n        # Saving simulation dfs back\n        hist._simulation_dfs = simulation_dfs\n\n        return hist\n\n\n    def plot(self,\n             sim_id: int = 0,\n             ax: plt.Axes | None = None\n             ) -&gt; None:\n        '''\n        Function to plot a the trajectory of a given simulation.\n        An ax can be use to plot it on.\n\n        Parameters\n        ----------\n        sim_id : int, default=0\n            The id of the simulation to plot.\n        ax : plt.Axes, optional\n            The ax on which to plot the path. (If not provided, a new axis will be created)\n        '''\n        # TODO: Setup 3D plotting\n        assert self.environment_dimensions == 2, \"Plotting function only available for 2D environments for now...\"\n\n        # Generate ax is not provided\n        if ax is None:\n            _, ax = plt.subplots(figsize=(18,3))\n\n        # Retrieving sim\n        sim = self.simulation_dfs[sim_id]\n\n        # Plot setup\n        env_shape = self.environment_shape\n        ax.imshow(np.zeros(self.environment_shape), cmap='Greys', zorder=-100)\n        ax.set_xlim(0, env_shape[1])\n        ax.set_ylim(env_shape[0], 0)\n\n        # Start\n        start_coord = sim[['x', 'y']].to_numpy()[0]\n        ax.scatter(start_coord[0], start_coord[1], c='green', label='Start')\n\n        # Source circle\n        goal_circle = Circle(self.environment_source_position[::-1], self.environment_source_radius, color='r', fill=False, label='Source')\n        ax.add_patch(goal_circle)\n\n        # Until step\n        seq = sim[['x','y']].to_numpy()\n\n        # Path\n        ax.plot(seq[:,0], seq[:,1], zorder=-1, c='black', label='Path')\n\n        # Layer observations\n        if self.environment_layer_labels is not None:\n            obs_layer = sim[['layer']][1:].to_numpy()\n            layer_colors = np.array(list(colors.TABLEAU_COLORS.values()))\n\n            for layer_i, layer_label in enumerate(self.environment_layer_labels[1:]):\n                layer_i += 1\n                layer_mask = (obs_layer == layer_i)[:,0] # Reshaping to a single vector and not an n by 1 array\n                ax.scatter(seq[1:][layer_mask,0], seq[1:][layer_mask,1], # X, Y\n                           marker='x',\n                           color=layer_colors[(layer_i-1) % len(layer_colors)], # Looping over the colors in case there are more layers than colors\n                           zorder=2,\n                           label=layer_label)\n\n        # Process odor cues\n        odor_cues = sim['o'][1:].to_numpy()\n        observation_ids = None\n        if (self.environment_layer_labels is not None) and len(self.agent_thresholds.shape) == 2:\n            layer_ids = sim[['layer']][1:].to_numpy()\n            action_layer_thresholds = self.agent_thresholds[layer_ids]\n            observation_ids = np.argwhere((odor_cues[:,None] &gt;= action_layer_thresholds[:,:-1]) &amp; (odor_cues[:,None] &lt; action_layer_thresholds[:,1:]))[:,1]\n        else:\n            # Setting observation ids\n            observation_ids = np.argwhere((odor_cues[:,None] &gt;= self.agent_thresholds[:-1][None,:]) &amp; (odor_cues[:,None] &lt; self.agent_thresholds[1:][None,:]))[:,1]\n\n        # Check whether the odor detection is binary or by level\n        odor_bins = self.agent_thresholds.shape[-1] - 1\n        if odor_bins &gt; 2:\n            odor_levels = np.arange(odor_bins - 1) + 1\n            for level in odor_levels:\n                cues_at_level = (observation_ids == level)\n                ax.scatter(seq[1:][cues_at_level,0], seq[1:][cues_at_level,1],\n                           zorder=1,\n                           alpha=(level / odor_bins),\n                           label=f'Sensed level {level}')\n        else:\n            something_sensed = (observation_ids == 1)\n            ax.scatter(seq[1:][something_sensed,0], seq[1:][something_sensed,1],\n                       zorder=1,\n                       label='Something observed')\n\n        # Generate legend\n        ax.legend()\n\n\n    def plot_runtimes(self,\n                      ax: plt.Axes | None = None\n                      ) -&gt; None:\n        '''\n        Function to plot the runtimes over the iterations.\n\n        Parameters\n        ----------\n        ax : plt.Axes, optional\n            The ax on which to plot the path. (If not provided, a new axis will be created)\n        '''\n        # Generate ax is not provided\n        if ax is None:\n            _, ax = plt.subplots(figsize=(18,3))\n\n        # Computing differences and plotting\n        x_start = 0\n        for i, (_, consecutive_timestamps) in enumerate(self.timestamps.items()):\n            time_differences_ms = np.array([t_diff.total_seconds() for t_diff in np.diff(consecutive_timestamps)]) / 1000\n            time_differences_count = len(time_differences_ms)\n            xs = x_start + np.arange(time_differences_count)\n\n            ax.plot(xs, time_differences_ms, label=f'Simulation {i}')\n\n            x_start += time_differences_count\n\n        # Axes\n        ax.set_xlabel('Iteration')\n        ax.set_ylabel('Runtime (ms)')\n\n\n    def plot_successes(self,\n                       ax: plt.Axes | None = None\n                       ) -&gt; None:\n        '''\n        Function to plot a 2D map of whether a given starting point was successfull or not (and whether it died early).\n\n        Parameters\n        ----------\n        ax : plt.Axes, optional\n            The ax on which to plot the path. (If not provided, a new axis will be created)\n        '''\n        assert self.environment_dimensions == 2, \"Only implemented for 2D environments...\"\n\n        # Generate ax is not provided\n        if ax is None:\n            _, ax = plt.subplots(figsize=(18,3))\n\n        # Setting up an empty grid of the starting points\n        start_points_grid = np.zeros(self.environment_shape)\n\n        # Compute the successful, failed and the ones that reached the horizon\n        success_points = self.start_points[self.successful_simulation]\n        failed_points = self.start_points[~self.successful_simulation]\n        failed_not_at_horizon_points = self.start_points[~self.successful_simulation &amp; ~self.simulations_at_horizon]\n\n        start_points_grid[failed_points[:,0], failed_points[:,1]] = -1\n        start_points_grid[success_points[:,0], success_points[:,1]] = 1\n\n        ax.imshow(start_points_grid, cmap='RdBu')\n\n        # The crosses where the points did not reach the horizon\n        ax.scatter(failed_not_at_horizon_points[:,1], failed_not_at_horizon_points[:,0], marker='x', color='black', s=10, label='Died early')\n        ax.legend()\n</code></pre>"},{"location":"reference/#olfactory_navigation.SimulationHistory.done_count","title":"<code>done_count</code>  <code>property</code>","text":"<p>Returns how many simulations are terminated (whether they reached the source or not).</p>"},{"location":"reference/#olfactory_navigation.SimulationHistory.general_analysis_df","title":"<code>general_analysis_df</code>  <code>property</code>","text":"<p>A Pandas DataFrame analyzing the results of the simulations. Summarizing the performance of all the simulations with the following metrics:</p> <ul> <li>converged:           Whether or not the simulation reached the source</li> <li>reached_horizon:     Whether the failed simulation reached to horizon</li> <li>steps_taken:         The amount of steps the agent took to reach the source, (horizon if the simulation did not reach the source)</li> <li>discounted_rewards:  The discounted reward received by the agent over the course of the simulation</li> <li>extra_steps:         The amount of extra steps compared to the optimal trajectory</li> <li>t_min_over_t:        Normalized version of the extra steps measure, where it tends to 1 the least amount of time the agent took to reach the source compared to an optimal trajectory.</li> </ul> <p>For the measures (converged, steps_taken, discounted_rewards, extra_steps, t_min_over_t), the average and standard deviations are computed in rows at the top.</p>"},{"location":"reference/#olfactory_navigation.SimulationHistory.runs_analysis_df","title":"<code>runs_analysis_df</code>  <code>property</code>","text":"<p>A Pandas DataFrame analyzing the results of the simulations. It aggregates the simulations in single rows, recording:</p> <ul> <li>:              The starting positions at the given axis <li>optimal_steps_count: The minimal amount of steps to reach the source</li> <li>converged:           Whether or not the simulation reached the source</li> <li>reached_horizon:     Whether the failed simulation reached to horizon</li> <li>steps_taken:         The amount of steps the agent took to reach the source, (horizon if the simulation did not reach the source)</li> <li>discounted_rewards:  The discounted reward received by the agent over the course of the simulation</li> <li>extra_steps:         The amount of extra steps compared to the optimal trajectory</li> <li>t_min_over_t:        Normalized version of the extra steps measure, where it tends to 1 the least amount of time the agent took to reach the source compared to an optimal trajectory.</li>"},{"location":"reference/#olfactory_navigation.SimulationHistory.simulation_dfs","title":"<code>simulation_dfs</code>  <code>property</code>","text":"<p>A list of the pandas DataFrame where each dataframe is a single simulation history. Each row is a different time instant of simulation process with each column being:</p> <ul> <li>time (of the simulation data)</li> <li>[position] (z,) y, x  OR  x0, x1, ... xn</li> <li>(layer)</li> <li>[movement] (dz,) dy, dx  OR  dx0, dx1, ... dxn</li> <li>o (pure, not thresholded)</li> <li>reached_source (boolean)</li> </ul>"},{"location":"reference/#olfactory_navigation.SimulationHistory.simulations_at_horizon","title":"<code>simulations_at_horizon</code>  <code>property</code>","text":"<p>Returns a boolean array of which simulations reached the horizon.</p>"},{"location":"reference/#olfactory_navigation.SimulationHistory.start_time","title":"<code>start_time</code>  <code>property</code>","text":"<p>The time at which the first simulation was started.</p>"},{"location":"reference/#olfactory_navigation.SimulationHistory.success_count","title":"<code>success_count</code>  <code>property</code>","text":"<p>Returns how many simulations reached the source.</p>"},{"location":"reference/#olfactory_navigation.SimulationHistory.summary","title":"<code>summary</code>  <code>property</code>","text":"<p>A string summarizing the performances of all the simulations. The metrics used are averages of:</p> <ul> <li>Step count</li> <li>Extra steps</li> <li>Discounted rewards</li> <li>Tmin / T</li> </ul> <p>Along with the respective the standard deviations and equally for only for the successful simulations.</p>"},{"location":"reference/#olfactory_navigation.SimulationHistory.add_step","title":"<code>add_step(actions, next_positions, observations, reached_source, interupt)</code>","text":"<p>Function to add a step in the simulation history.</p> <p>Parameters:</p> Name Type Description Default <code>actions</code> <code>ndarray</code> <p>The actions that were taken by the agents.</p> required <code>next_positions</code> <code>ndarray</code> <p>The positions that were reached by the agents after having taken actions.</p> required <code>observations</code> <code>ndarray</code> <p>The observations the agents receive after having taken actions.</p> required <code>reached_source</code> <code>ndarray</code> <p>A boolean array of whether each agent has reached the source or not.</p> required <code>interupt</code> <code>ndarray</code> <p>A boolean array of whether each agent has to be terminated even if it hasnt reached the source yet.</p> required Source code in <code>olfactory_navigation/simulation.py</code> <pre><code>def add_step(self,\n             actions: np.ndarray,\n             next_positions: np.ndarray,\n             observations: np.ndarray,\n             reached_source: np.ndarray,\n             interupt: np.ndarray\n             ) -&gt; None:\n    '''\n    Function to add a step in the simulation history.\n\n    Parameters\n    ----------\n    actions : np.ndarray\n        The actions that were taken by the agents.\n    next_positions : np.ndarray\n        The positions that were reached by the agents after having taken actions.\n    observations : np.ndarray\n        The observations the agents receive after having taken actions.\n    reached_source : np.ndarray\n        A boolean array of whether each agent has reached the source or not.\n    interupt : np.ndarray\n        A boolean array of whether each agent has to be terminated even if it hasnt reached the source yet.\n    '''\n    self._simulation_dfs = None\n\n    # Time tracking\n    self.timestamps[0].append(datetime.now())\n\n    # Check if environment if layered and/or 3D\n    layered = 0 if self.environment_layer_labels is None else 1\n\n    # Handle case cupy arrays are provided\n    if gpu_support:\n        actions = actions if cp.get_array_module(actions) == np else cp.asnumpy(actions)\n        next_positions = next_positions if cp.get_array_module(next_positions) == np else cp.asnumpy(next_positions)\n        observations = observations if cp.get_array_module(observations) == np else cp.asnumpy(observations)\n        reached_source = reached_source if cp.get_array_module(reached_source) == np else cp.asnumpy(reached_source)\n        interupt = interupt if cp.get_array_module(interupt) == np else cp.asnumpy(interupt)\n\n    # Actions tracking\n    action_all_sims = np.full((self.n, (layered + self.environment_dimensions)), fill_value=-1)\n    action_all_sims[self._running_sims] = actions\n    self.actions.append(action_all_sims)\n\n    # Next states tracking\n    next_position_all_sims = np.full((self.n, self.environment_dimensions), fill_value=-1)\n    next_position_all_sims[self._running_sims] = next_positions\n    self.positions.append(next_position_all_sims)\n\n    # Observation tracking\n    observation_all_sims = np.full((self.n,), fill_value=-1, dtype=float)\n    observation_all_sims[self._running_sims] = observations\n    self.observations.append(observation_all_sims)\n\n    # Recording at which step the simulation is done if it is done and whether it reached the source\n    self.done_at_step[self._running_sims[reached_source | interupt]] = len(self.positions)\n    self.reached_source[self._running_sims[reached_source]] = True\n\n    # Updating the list of running sims\n    self._running_sims = self._running_sims[~reached_source &amp; ~interupt]\n</code></pre>"},{"location":"reference/#olfactory_navigation.SimulationHistory.compute_distance_to_source","title":"<code>compute_distance_to_source()</code>","text":"<p>Function to compute the optimal distance to the source of each starting point according to the optimal_distance_metric attribute.</p> <p>Returns:</p> Name Type Description <code>distance</code> <code>ndarray</code> <p>The optimal distances to the source point.</p> Source code in <code>olfactory_navigation/simulation.py</code> <pre><code>def compute_distance_to_source(self) -&gt; np.ndarray:\n    '''\n    Function to compute the optimal distance to the source of each starting point according to the optimal_distance_metric attribute.\n\n    Returns\n    -------\n    distance : np.ndarray\n        The optimal distances to the source point.\n    '''\n    point = self.start_points\n\n    # Handling the case we have a single point\n    is_single_point = (len(point.shape) == 1)\n    if is_single_point:\n        point = point[None,:]\n\n    # Computing dist\n    dist = None\n    # if self.optimal_distance_metric == 'manhattan': # TODO Allow for other metrics to be used\n    dist = np.sum(np.abs(self.environment_source_position[None,:] - point), axis=-1) - self.environment_source_radius\n\n    if dist is None: # Meaning it was not computed\n        raise NotImplementedError('This distance metric has not yet been implemented')\n\n    return float(dist[0]) if is_single_point else dist\n</code></pre>"},{"location":"reference/#olfactory_navigation.SimulationHistory.load","title":"<code>load(file, environment=False, agent=False)</code>  <code>classmethod</code>","text":"<p>Function to load the simulation history from a file. This can be useful to use the plot functions on the simulations saved in such file.</p> <p>The environment and agent can provided as a backup in the case they cannot be loaded from the file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>A file (with the path) of the simulation histories csv. (the analysis file cannot be used for this)</p> required <code>environment</code> <code>bool or Environment</code> <p>If set to True, it will try to load the environment that was used for the simulation (if the save path is available). Or, an environment instance to be linked with the simulation history object.</p> <code>False</code> <code>agent</code> <code>bool or Agent</code> <p>If set to True, it will try to load the agent that was used for the simulation (if the save path is available). An agent instance to be linked with the simulation history object.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>hist</code> <code>SimulationHistory</code> <p>The loaded instance of a simulation history object.</p> Source code in <code>olfactory_navigation/simulation.py</code> <pre><code>@classmethod\ndef load(cls,\n         file: str,\n         environment: bool | Environment = False,\n         agent: bool | Agent = False\n         ) -&gt; 'SimulationHistory':\n    '''\n    Function to load the simulation history from a file.\n    This can be useful to use the plot functions on the simulations saved in such file.\n\n    The environment and agent can provided as a backup in the case they cannot be loaded from the file.\n\n    Parameters\n    ----------\n    file : str\n        A file (with the path) of the simulation histories csv. (the analysis file cannot be used for this)\n    environment : bool or Environment, default=False\n        If set to True, it will try to load the environment that was used for the simulation (if the save path is available).\n        Or, an environment instance to be linked with the simulation history object.\n    agent : bool or Agent, default=False\n        If set to True, it will try to load the agent that was used for the simulation (if the save path is available).\n        An agent instance to be linked with the simulation history object.\n\n    Returns\n    -------\n    hist : SimulationHistory\n        The loaded instance of a simulation history object.\n    '''\n    # Retrieving columns\n    with open(file, 'r') as f:\n        header = f.readline()\n    columns = header.replace('\\n','').split(',')\n\n    # Setting the datatypes of columns\n    column_dtypes = {col: float for col in columns}\n    column_dtypes['time'] = int\n    if 'layer' in columns:\n        column_dtypes['layer'] = int\n    column_dtypes['timestamps'] = str\n    column_dtypes['environment'] = str\n    column_dtypes['agent'] = str\n\n    # Retrieving the combined dataframe\n    combined_df = pd.read_csv(file, dtype=column_dtypes)\n\n    # Retrieving horizon and reward discount\n    horizon = int(combined_df['horizon'][0])\n    reward_discount = combined_df['reward_discount'][0]\n\n    # Retrieving environment\n    if (not isinstance(environment, Environment)) and (environment == True):\n        environment_name = combined_df['environment'][0]\n        environment_path = combined_df['environment'][1]\n\n        environment_path_check = (environment_path is not None) and (not np.isnan(environment_path))\n        assert environment_path_check, \"Environment was not saved at the time of the saving of the simulation history. Input an environment to the environment parameter or toggle the parameter to False.\"\n\n        try:\n            environment = Environment.load(environment_path)\n        except:\n            print(f'Failed to retrieve \"{environment_name}\" environment from memory')\n\n    # Retrieving agent\n    if (not isinstance(agent, Agent)) and (agent == True):\n        agent_name = combined_df['environment'][0]\n        agent_class = combined_df['environment'][1]\n        agent_path = combined_df['environment'][2]\n\n        agent_path_check = (agent_path is not None) and (not np.isnan(agent_path))\n        assert agent_path_check, \"Agent was not saved at the time of the saving of the simulation history. Input an agent to the agent parameter or toggle the parameter to False.\"\n\n        try:\n            class_instance = None\n            for (class_name, class_obj) in inspect.getmembers(sys.modules[__name__], inspect.isclass):\n                if class_name == agent_class:\n                    class_instance = class_obj\n                    break\n            agent = class_instance.load(combined_df['agent'][2])\n        except:\n            print(f'Failed to retrieve \"{agent_name}\" agent from memory')\n\n    # Other attributes\n    environment_dimensions = int(combined_df['environment'][2])\n    environment_shape = tuple([int(axis_shape) for axis_shape in combined_df['environment'][3].split('_')])\n    environment_source_position = np.array([float(pos_axis) for pos_axis in combined_df['environment'][4].split('_')])\n    environment_source_radius = float(combined_df['environment'][5])\n    layer_entery = combined_df['environment'][6]\n    environment_layer_labels = (None if ((not isinstance(layer_entery, str)) or (len(layer_entery) == 0)) else layer_entery.split('&amp;'))\n\n    # Processing the threshold string\n    thresholds_string = str(combined_df['agent'][3])\n    if '&amp;' in thresholds_string:\n        rows_thresholds_string = thresholds_string.split('&amp;')\n        layer_thresholds = []\n        for row in rows_thresholds_string:\n            layer_thresholds.append(np.array(row.split('_')).astype(float))\n        agent_thresholds = np.array(layer_thresholds)\n\n    else:\n        agent_thresholds = np.array(np.array(thresholds_string.split('_')).astype(float))\n\n    # Columns to retrieve\n    columns = [col for col in columns if col not in ['reward_discount', 'environment', 'agent']]\n\n    # Checking how many dimensions there are\n    has_layers = (((len(columns) - 5) % 2) == 1)\n    dimensions = int((len(columns) - 5) / 2)\n\n    # Recreation of list of simulations\n    sim_start_rows = np.argwhere(combined_df[['reached_source']].isnull())[1:,0]\n\n    simulation_arrays = np.split(combined_df[columns].to_numpy(), sim_start_rows)\n    simulation_dfs = [pd.DataFrame(sim_array, columns=columns) for sim_array in simulation_arrays]\n\n    # Making a combined numpy array with all the simulations\n    sizes = np.array([len(sim_array) for sim_array in simulation_arrays])\n    max_length = sizes.max()\n    paddings = max_length - sizes\n\n    padded_simulation_arrays = [np.pad(sim_arr, ((0,pad),(0,0)), constant_values=-1) for sim_arr, pad in zip(simulation_arrays, paddings)]\n    all_simulation_arrays = np.array(padded_simulation_arrays).transpose((1,0,2))\n\n    # Timeshift\n    time_shift = all_simulation_arrays[0,:,0].astype(int)\n\n    # Gathering start states\n    start_points = all_simulation_arrays[0,:,1:(1+dimensions)].astype(int)\n\n    # Recreating action, state and observations\n    positions = all_simulation_arrays[1:, :, 1:(1+dimensions)]\n    actions = all_simulation_arrays[1:, :, (1+dimensions):((1+dimensions) + (1 if has_layers else 0) + dimensions)]\n    observations = all_simulation_arrays[1:, :, ((1+dimensions) + (1 if has_layers else 0) + dimensions)]\n    reached_source = np.array([(df['reached_source'][len(df)-1] == 1) for df in simulation_dfs])\n    done_at_step = np.where((sizes-1 &lt; horizon), sizes-1, -1)\n\n    # Building SimulationHistory instance\n    hist = cls.__new__(cls)\n\n    hist.n = len(start_points)\n    hist.environment = environment.cpu_version if isinstance(environment, Environment) else None\n    hist.agent = agent.cpu_version if isinstance(agent, Agent) else None\n    hist.time_shift = time_shift\n    hist.horizon = horizon\n    hist.reward_discount = reward_discount\n\n    hist.start_points = start_points\n    hist._running_sims = None\n\n    hist.positions = [*positions]\n    hist.actions = [*actions]\n    hist.observations = [*observations]\n    hist.reached_source = reached_source\n    hist.done_at_step = done_at_step\n\n    # Reading timestamps\n    timestamp_column = combined_df['timestamps']\n    timestamp_groups = np.concatenate([np.argwhere(timestamp_column.str.contains('_') == True)[:,0], [len(timestamp_column)]])\n    timestamps = {}\n\n    # Reading each group of timestamps (representing of each run)\n    for group_i, (group_start, group_end) in enumerate(zip(timestamp_groups[:-1], timestamp_groups[1:])):\n        timestamp_group = timestamp_column[group_start:group_end]\n\n        # Initial read of the group\n        first_timestamp = timestamp_group.iloc[0]\n        timestamp_day = first_timestamp[:9]\n        timestamp_count = np.sum(timestamp_group.notna())\n        timestamp_string_list = timestamp_group[:timestamp_count].to_list()\n\n        day_delta = timedelta(days=0)\n        timestamp_list = [datetime.strptime(timestamp_string_list[0], '%Y%m%d_%H%M%S%f')]\n\n        # Reading each timestamp of the list\n        for timestamp_string in timestamp_string_list[1:]:\n            timestamp_string = timestamp_day + str(timestamp_string)\n            timestamp = datetime.strptime(timestamp_string, '%Y%m%d_%H%M%S%f') + day_delta\n\n            # If timestamp is smaller than the previous one, it means it is a new day and the day_delta has to be increased\n            if timestamp &lt; timestamp_list[-1]:\n                day_delta += timedelta(days=1)\n                timestamp += timedelta(days=1)\n\n            timestamp_list.append(timestamp)\n\n        # Adding the timestamps to the general dictionary\n        associate_run_i = np.argwhere(np.concatenate([[0], sim_start_rows]) == group_start)[0,0]\n        timestamps[associate_run_i] = timestamp_list\n\n    # Warn if no timestamps were found\n    if len(timestamps) == 0:\n        print('[Warning] No timestamps were found in the loaded simulation history...')\n\n    hist.timestamps = timestamps\n\n    # Other attributes\n    hist.environment_dimensions = environment_dimensions\n    hist.environment_shape = environment_shape\n    hist.environment_source_position = environment_source_position\n    hist.environment_source_radius = environment_source_radius\n    hist.environment_layer_labels = environment_layer_labels\n    hist.agent_thresholds = agent_thresholds\n\n    # Saving simulation dfs back\n    hist._simulation_dfs = simulation_dfs\n\n    return hist\n</code></pre>"},{"location":"reference/#olfactory_navigation.SimulationHistory.plot","title":"<code>plot(sim_id=0, ax=None)</code>","text":"<p>Function to plot a the trajectory of a given simulation. An ax can be use to plot it on.</p> <p>Parameters:</p> Name Type Description Default <code>sim_id</code> <code>int</code> <p>The id of the simulation to plot.</p> <code>0</code> <code>ax</code> <code>Axes</code> <p>The ax on which to plot the path. (If not provided, a new axis will be created)</p> <code>None</code> Source code in <code>olfactory_navigation/simulation.py</code> <pre><code>def plot(self,\n         sim_id: int = 0,\n         ax: plt.Axes | None = None\n         ) -&gt; None:\n    '''\n    Function to plot a the trajectory of a given simulation.\n    An ax can be use to plot it on.\n\n    Parameters\n    ----------\n    sim_id : int, default=0\n        The id of the simulation to plot.\n    ax : plt.Axes, optional\n        The ax on which to plot the path. (If not provided, a new axis will be created)\n    '''\n    # TODO: Setup 3D plotting\n    assert self.environment_dimensions == 2, \"Plotting function only available for 2D environments for now...\"\n\n    # Generate ax is not provided\n    if ax is None:\n        _, ax = plt.subplots(figsize=(18,3))\n\n    # Retrieving sim\n    sim = self.simulation_dfs[sim_id]\n\n    # Plot setup\n    env_shape = self.environment_shape\n    ax.imshow(np.zeros(self.environment_shape), cmap='Greys', zorder=-100)\n    ax.set_xlim(0, env_shape[1])\n    ax.set_ylim(env_shape[0], 0)\n\n    # Start\n    start_coord = sim[['x', 'y']].to_numpy()[0]\n    ax.scatter(start_coord[0], start_coord[1], c='green', label='Start')\n\n    # Source circle\n    goal_circle = Circle(self.environment_source_position[::-1], self.environment_source_radius, color='r', fill=False, label='Source')\n    ax.add_patch(goal_circle)\n\n    # Until step\n    seq = sim[['x','y']].to_numpy()\n\n    # Path\n    ax.plot(seq[:,0], seq[:,1], zorder=-1, c='black', label='Path')\n\n    # Layer observations\n    if self.environment_layer_labels is not None:\n        obs_layer = sim[['layer']][1:].to_numpy()\n        layer_colors = np.array(list(colors.TABLEAU_COLORS.values()))\n\n        for layer_i, layer_label in enumerate(self.environment_layer_labels[1:]):\n            layer_i += 1\n            layer_mask = (obs_layer == layer_i)[:,0] # Reshaping to a single vector and not an n by 1 array\n            ax.scatter(seq[1:][layer_mask,0], seq[1:][layer_mask,1], # X, Y\n                       marker='x',\n                       color=layer_colors[(layer_i-1) % len(layer_colors)], # Looping over the colors in case there are more layers than colors\n                       zorder=2,\n                       label=layer_label)\n\n    # Process odor cues\n    odor_cues = sim['o'][1:].to_numpy()\n    observation_ids = None\n    if (self.environment_layer_labels is not None) and len(self.agent_thresholds.shape) == 2:\n        layer_ids = sim[['layer']][1:].to_numpy()\n        action_layer_thresholds = self.agent_thresholds[layer_ids]\n        observation_ids = np.argwhere((odor_cues[:,None] &gt;= action_layer_thresholds[:,:-1]) &amp; (odor_cues[:,None] &lt; action_layer_thresholds[:,1:]))[:,1]\n    else:\n        # Setting observation ids\n        observation_ids = np.argwhere((odor_cues[:,None] &gt;= self.agent_thresholds[:-1][None,:]) &amp; (odor_cues[:,None] &lt; self.agent_thresholds[1:][None,:]))[:,1]\n\n    # Check whether the odor detection is binary or by level\n    odor_bins = self.agent_thresholds.shape[-1] - 1\n    if odor_bins &gt; 2:\n        odor_levels = np.arange(odor_bins - 1) + 1\n        for level in odor_levels:\n            cues_at_level = (observation_ids == level)\n            ax.scatter(seq[1:][cues_at_level,0], seq[1:][cues_at_level,1],\n                       zorder=1,\n                       alpha=(level / odor_bins),\n                       label=f'Sensed level {level}')\n    else:\n        something_sensed = (observation_ids == 1)\n        ax.scatter(seq[1:][something_sensed,0], seq[1:][something_sensed,1],\n                   zorder=1,\n                   label='Something observed')\n\n    # Generate legend\n    ax.legend()\n</code></pre>"},{"location":"reference/#olfactory_navigation.SimulationHistory.plot_runtimes","title":"<code>plot_runtimes(ax=None)</code>","text":"<p>Function to plot the runtimes over the iterations.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The ax on which to plot the path. (If not provided, a new axis will be created)</p> <code>None</code> Source code in <code>olfactory_navigation/simulation.py</code> <pre><code>def plot_runtimes(self,\n                  ax: plt.Axes | None = None\n                  ) -&gt; None:\n    '''\n    Function to plot the runtimes over the iterations.\n\n    Parameters\n    ----------\n    ax : plt.Axes, optional\n        The ax on which to plot the path. (If not provided, a new axis will be created)\n    '''\n    # Generate ax is not provided\n    if ax is None:\n        _, ax = plt.subplots(figsize=(18,3))\n\n    # Computing differences and plotting\n    x_start = 0\n    for i, (_, consecutive_timestamps) in enumerate(self.timestamps.items()):\n        time_differences_ms = np.array([t_diff.total_seconds() for t_diff in np.diff(consecutive_timestamps)]) / 1000\n        time_differences_count = len(time_differences_ms)\n        xs = x_start + np.arange(time_differences_count)\n\n        ax.plot(xs, time_differences_ms, label=f'Simulation {i}')\n\n        x_start += time_differences_count\n\n    # Axes\n    ax.set_xlabel('Iteration')\n    ax.set_ylabel('Runtime (ms)')\n</code></pre>"},{"location":"reference/#olfactory_navigation.SimulationHistory.plot_successes","title":"<code>plot_successes(ax=None)</code>","text":"<p>Function to plot a 2D map of whether a given starting point was successfull or not (and whether it died early).</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The ax on which to plot the path. (If not provided, a new axis will be created)</p> <code>None</code> Source code in <code>olfactory_navigation/simulation.py</code> <pre><code>def plot_successes(self,\n                   ax: plt.Axes | None = None\n                   ) -&gt; None:\n    '''\n    Function to plot a 2D map of whether a given starting point was successfull or not (and whether it died early).\n\n    Parameters\n    ----------\n    ax : plt.Axes, optional\n        The ax on which to plot the path. (If not provided, a new axis will be created)\n    '''\n    assert self.environment_dimensions == 2, \"Only implemented for 2D environments...\"\n\n    # Generate ax is not provided\n    if ax is None:\n        _, ax = plt.subplots(figsize=(18,3))\n\n    # Setting up an empty grid of the starting points\n    start_points_grid = np.zeros(self.environment_shape)\n\n    # Compute the successful, failed and the ones that reached the horizon\n    success_points = self.start_points[self.successful_simulation]\n    failed_points = self.start_points[~self.successful_simulation]\n    failed_not_at_horizon_points = self.start_points[~self.successful_simulation &amp; ~self.simulations_at_horizon]\n\n    start_points_grid[failed_points[:,0], failed_points[:,1]] = -1\n    start_points_grid[success_points[:,0], success_points[:,1]] = 1\n\n    ax.imshow(start_points_grid, cmap='RdBu')\n\n    # The crosses where the points did not reach the horizon\n    ax.scatter(failed_not_at_horizon_points[:,1], failed_not_at_horizon_points[:,0], marker='x', color='black', s=10, label='Died early')\n    ax.legend()\n</code></pre>"},{"location":"reference/#olfactory_navigation.SimulationHistory.save","title":"<code>save(file=None, folder=None, save_analysis=True, save_components=False)</code>","text":"<p>Function to save the simulation history to a csv file in a given folder. Additionally, an analysis of the runs can be saved if the save_analysis is enabled. The environment and agent used can be saved in the saved folder by enabling the 'save_component' parameter.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>The name of the file the simulation histories will be saved to. If it is not provided, it will be by default \"Simulations--n_--horizon_.csv\" <code>None</code> <code>folder</code> <code>str</code> <p>Folder to save the simulation histories to. If the folder name is not provided the current folder will be used.</p> <code>None</code> <code>save_analysis</code> <code>bool</code> <p>Whether to save an additional csv file with an analysis of the runs of the simulation. It will contain the amount of steps taken, the amount of extra steps compared to optimality, the discounted rewards and the ratio between optimal trajectory and the steps taken. The means and standard deviations of all the runs are also computed. The file will have the same name as the simulation history file with an additional '-analysis' tag at the end.</p> <code>True</code> <code>save_components</code> <code>bool</code> <p>Whether or not to save the environment and agent along with the simulation histories in the given folder.</p> <code>False</code> Source code in <code>olfactory_navigation/simulation.py</code> <pre><code>def save(self,\n         file: str | None = None,\n         folder: str | None = None,\n         save_analysis: bool = True,\n         save_components: bool = False\n         ) -&gt; None:\n    '''\n    Function to save the simulation history to a csv file in a given folder.\n    Additionally, an analysis of the runs can be saved if the save_analysis is enabled.\n    The environment and agent used can be saved in the saved folder by enabling the 'save_component' parameter.\n\n    Parameters\n    ----------\n    file : str, optional\n        The name of the file the simulation histories will be saved to.\n        If it is not provided, it will be by default \"Simulations-&lt;env_name&gt;-n_&lt;sim_count&gt;-&lt;sim_start_timestamp&gt;-horizon_&lt;max_sim_length&gt;.csv\"\n    folder : str, optional\n        Folder to save the simulation histories to.\n        If the folder name is not provided the current folder will be used.\n    save_analysis : bool, default=True\n        Whether to save an additional csv file with an analysis of the runs of the simulation.\n        It will contain the amount of steps taken, the amount of extra steps compared to optimality, the discounted rewards and the ratio between optimal trajectory and the steps taken.\n        The means and standard deviations of all the runs are also computed.\n        The file will have the same name as the simulation history file with an additional '-analysis' tag at the end.\n    save_components : bool, default=False\n        Whether or not to save the environment and agent along with the simulation histories in the given folder.\n    '''\n    assert (self.environment is not None) and (self.agent is not None), \"Function not available, the agent and/or the environment is not set.\"\n\n    # Handle file name\n    if file is None:\n        env_name = f's_' + '_'.join([str(axis_shape) for axis_shape in self.environment_shape])\n        file = f'Simulations-{env_name}-n_{self.n}-{self.timestamps[0][0].strftime(\"%Y%m%d_%H%M%S\")}-horizon_{len(self.positions)}.csv'\n\n    if not file.endswith('.csv'):\n        file += '.csv'\n\n    # Handle folder\n    if folder is None:\n        folder = './'\n\n    if '/' not in folder:\n        folder = './' + folder\n\n    if not os.path.exists(folder):\n        os.mkdir(folder)\n\n    if not folder.endswith('/'):\n        folder += '/'\n\n    # Save components if requested\n    if save_components:\n        if (self.environment.saved_at is None) or (folder not in self.environment.saved_at):\n            self.environment.save(folder=folder)\n\n        if (self.agent.saved_at is None) or (folder not in self.agent.saved_at):\n            self.agent.save(folder=folder)\n\n    # Create csv file\n    combined_df = pd.concat(self.simulation_dfs)\n\n    # timestamps information\n    simulation_lengths = np.array([len(df) for df in self.simulation_dfs])\n    timestamps_column = [None] * len(combined_df)\n    for n_start, run_timestamps in self.timestamps.items():\n        i_start = np.sum(simulation_lengths[:n_start])\n        for ts_i, ts in enumerate(run_timestamps):\n            timestamps_column[i_start + ts_i] = (ts.strftime('%Y%m%d_%H%M%S%f') if ts_i == 0 else ts.strftime('%H%M%S%f'))\n    combined_df['timestamps'] = timestamps_column\n\n    # Adding other useful info\n    padding = [None] * len(combined_df)\n    combined_df['horizon'] = [self.horizon] + padding[:-1]\n    combined_df['reward_discount'] = [self.reward_discount] + padding[:-1]\n\n    environment_info = [\n        self.environment.name,\n        self.environment.saved_at,\n        str(self.environment_dimensions), # int\n        '_'.join(str(axis_size) for axis_size in self.environment_shape),\n        '_'.join(str(axis_position) for axis_position in self.environment_source_position),\n        str(self.environment_source_radius), # float\n        '' if (self.environment_layer_labels is None) else '&amp;'.join(self.environment_layer_labels) # Using '&amp;' as splitter as '_' could be used in the labels themselves\n    ]\n    combined_df['environment'] = (environment_info + padding[:-len(environment_info)])\n\n    # Converting the thresholds array to a string to be saved\n    thresholds_string = ''\n    if len(self.agent_thresholds.shape) == 2:\n        thresholds_string = '&amp;'.join(['_'.join([str(item) for item in row]) for row_i, row in enumerate(self.agent_thresholds[:,1:-1])]) # Using '&amp;' as layer splitter as '-' can be used for negative thresholds\n    else:\n        thresholds_string = '_'.join([str(item) for item in self.agent_thresholds])\n\n    agent_info = [\n        self.agent.name,\n        self.agent.class_name,\n        self.agent.saved_at,\n        thresholds_string\n    ]\n    combined_df['agent'] = (agent_info + padding[:-len(agent_info)])\n\n    # Saving csv\n    combined_df.to_csv(folder + file, index=False)\n\n    print(f'Simulations saved to: {folder + file}')\n\n    if save_analysis:\n        runs_analysis_file_name = file.replace('.csv', '-runs_analysis.csv')\n        self.runs_analysis_df.to_csv(folder + runs_analysis_file_name)\n        print(f\"Simulation's runs analysis saved to: {folder + runs_analysis_file_name}\")\n\n        general_analysis_file_name = file.replace('.csv', '-general_analysis.csv')\n        self.general_analysis_df.to_csv(folder + general_analysis_file_name)\n        print(f\"Simulation's general analysis saved to: {folder + general_analysis_file_name}\")\n</code></pre>"},{"location":"reference/#olfactory_navigation.run_test","title":"<code>run_test(agent, n=None, start_points=None, environment=None, time_shift=0, time_loop=True, horizon=1000, initialization_values={}, reward_discount=0.99, print_progress=True, print_stats=True, print_warning=True, use_gpu=False, batches=-1)</code>","text":"<p>Function to run n simulations for a given agent in its environment (or a given modified environment). The simulations start either from random start points or provided trough the start_points parameter. The simulation can have shifted initial times (in the olfactory simulation).</p> <p>The simulation will run for at most 'horizon' steps, after which the simulations will be considered failed.</p> <p>Some statistics can be printed at end of the simulation with the 'print_stats' parameter. It will print some performance statisitcs about the simulations such as the average discounter reward. The reward discount can be set by the 'reward_discount' parameter.</p> <p>To speedup the simulations, it can be run on the gpu by toggling the 'use_gpu' parameter. This will have the consequence to send the various arrays to the gpu memory. This will only work if the agent has the support for to work with cupy arrays.</p> <p>This method returns a SimulationHistory object that saves all the positions the agent went through, the actions the agent took, and the observation the agent received. It also provides the possibility the save the results to a csv file and plot the various trajectories.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>The agent to be tested</p> required <code>n</code> <code>int</code> <p>How many simulation to run in parallel. n is optional but it needs to match with what is provided in start_points.</p> <code>None</code> <code>start_points</code> <code>ndarray</code> <p>The starting points of the simulation in 2d space. If not provided, n random points will be generated based on the start probabilities of the environment. Else, the amount of start_points need to match to n, if it is provided.</p> <code>None</code> <code>environment</code> <code>Environment</code> <p>The environment to run the simulations in. By default, the environment linked to the agent will used. This parameter is intended if the environment needs to be modified compared to environment the agent was trained on.</p> <code>None</code> <code>time_shift</code> <code>int or ndarray</code> <p>The time at which to start the olfactory simulation array. It can be either a single value, or n values.</p> <code>0</code> <code>time_loop</code> <code>bool</code> <p>Whether to loop the time if reaching the end. (starts back at 0)</p> <code>True</code> <code>horizon</code> <code>int</code> <p>The amount of steps to run the simulation for before killing the remaining simulations.</p> <code>1000</code> <code>initialization_values</code> <code>dict</code> <p>In the case the agent is to be initialized with custom values, the paramaters to be passed on the initialize_state function can be set here.</p> <code>{}</code> <code>reward_discount</code> <code>float</code> <p>How much a given reward is discounted based on how long it took to get it. It is purely used to compute the Average Discount Reward (ADR) after the simulation.</p> <code>0.99</code> <code>print_progress</code> <code>bool</code> <p>Whether to show a progress bar of what step the simulations are at.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether to print the stats at the end of the run.</p> <code>True</code> <code>print_warning</code> <code>bool</code> <p>Whether to print warnings when they occur or not.</p> <code>True</code> <code>use_gpu</code> <code>bool</code> <p>Whether to run the simulations on the GPU or not.</p> <code>False</code> <code>batches</code> <code>int</code> <p>In how many batches the simulations should be run. This is useful in the case there are too many simulations and the memory can fill up. The value of batches=-1 will make it that different batches amount are tried in increasing order if a MemoryError is encountered.</p> <code>-1</code> <p>Returns:</p> Name Type Description <code>hist</code> <code>SimulationHistory</code> <p>A SimulationHistory object that tracked all the positions, actions and observations.</p> Source code in <code>olfactory_navigation/simulation.py</code> <pre><code>def run_test(agent: Agent,\n             n: int | None = None,\n             start_points: np.ndarray | None = None,\n             environment: Environment | None = None,\n             time_shift: int | np.ndarray = 0,\n             time_loop: bool = True,\n             horizon: int = 1000,\n             initialization_values: dict = {},\n             reward_discount: float = 0.99,\n             print_progress: bool = True,\n             print_stats: bool = True,\n             print_warning: bool = True,\n             use_gpu: bool = False,\n             batches: int = -1\n             ) -&gt; SimulationHistory:\n    '''\n    Function to run n simulations for a given agent in its environment (or a given modified environment).\n    The simulations start either from random start points or provided trough the start_points parameter.\n    The simulation can have shifted initial times (in the olfactory simulation).\n\n    The simulation will run for at most 'horizon' steps, after which the simulations will be considered failed.\n\n    Some statistics can be printed at end of the simulation with the 'print_stats' parameter.\n    It will print some performance statisitcs about the simulations such as the average discounter reward.\n    The reward discount can be set by the 'reward_discount' parameter.\n\n    To speedup the simulations, it can be run on the gpu by toggling the 'use_gpu' parameter.\n    This will have the consequence to send the various arrays to the gpu memory.\n    This will only work if the agent has the support for to work with cupy arrays.\n\n    This method returns a SimulationHistory object that saves all the positions the agent went through,\n    the actions the agent took, and the observation the agent received.\n    It also provides the possibility the save the results to a csv file and plot the various trajectories.\n\n    Parameters\n    ----------\n    agent : Agent\n        The agent to be tested\n    n : int, optional\n        How many simulation to run in parallel.\n        n is optional but it needs to match with what is provided in start_points.\n    start_points : np.ndarray, optional\n        The starting points of the simulation in 2d space.\n        If not provided, n random points will be generated based on the start probabilities of the environment.\n        Else, the amount of start_points need to match to n, if it is provided.\n    environment : Environment, optional\n        The environment to run the simulations in.\n        By default, the environment linked to the agent will used.\n        This parameter is intended if the environment needs to be modified compared to environment the agent was trained on.\n    time_shift : int or np.ndarray, default=0\n        The time at which to start the olfactory simulation array.\n        It can be either a single value, or n values.\n    time_loop : bool, default=True\n        Whether to loop the time if reaching the end. (starts back at 0)\n    horizon : int, default=1000\n        The amount of steps to run the simulation for before killing the remaining simulations.\n    initialization_values : dict, default={}\n        In the case the agent is to be initialized with custom values,\n        the paramaters to be passed on the initialize_state function can be set here.\n    reward_discount : float, default=0.99\n        How much a given reward is discounted based on how long it took to get it.\n        It is purely used to compute the Average Discount Reward (ADR) after the simulation.\n    print_progress : bool, default=True\n        Whether to show a progress bar of what step the simulations are at.\n    print_stats : bool, default=True\n        Whether to print the stats at the end of the run.\n    print_warning : bool, default=True\n        Whether to print warnings when they occur or not.\n    use_gpu : bool, default=False\n        Whether to run the simulations on the GPU or not.\n    batches : int, default=-1\n        In how many batches the simulations should be run.\n        This is useful in the case there are too many simulations and the memory can fill up.\n        The value of batches=-1 will make it that different batches amount are tried in increasing order if a MemoryError is encountered.\n\n    Returns\n    -------\n    hist : SimulationHistory\n        A SimulationHistory object that tracked all the positions, actions and observations.\n    '''\n    # Gathering n\n    if n is None:\n        if (start_points is None) or (len(start_points.shape) == 1):\n            n = 1\n        else:\n            n = len(start_points)\n\n    # Handle the case an specific environment is given\n    if (environment is not None) and print_warning:\n        if environment.shape != agent.environment.shape:\n            print(\"[Warning] The provided environment's shape doesn't match the environment has been trained on...\")\n        print('Using the provided environment, not the agent environment.')\n    else:\n        environment = agent.environment\n\n    # Timeshift\n    if isinstance(time_shift, int):\n        time_shift = np.ones(n) * time_shift\n    else:\n        time_shift = np.array(time_shift)\n        assert time_shift.shape == (n,), f\"time_shift array has a wrong shape (Given: {time_shift.shape}, expected ({n},))\"\n    time_shift = time_shift.astype(int)\n\n    # Auto batches selector where the amount of batches increases if a memory error is detected\n    if batches &lt; 0:\n        all_try_batches = (2**np.arange(np.log2(11000), dtype=int))\n        for try_batches in all_try_batches:\n            try:\n                hist = run_test(agent = agent,\n                                n = n,\n                                start_points = start_points,\n                                environment = environment,\n                                time_shift = time_shift,\n                                time_loop = time_loop,\n                                horizon = horizon,\n                                initialization_values = initialization_values,\n                                reward_discount = reward_discount,\n                                print_progress = print_progress,\n                                print_stats = print_stats,\n                                print_warning = False, # If there was any, it would have been printed already\n                                use_gpu = use_gpu,\n                                batches = try_batches)\n                return hist\n            except MemoryError as e:\n                print(f'Memory full: {e}')\n                print('Increasing the amount of batches...')\n\n    # If more than one batch is selected, split the starting point arrays by the amounts of simulations in each batch\n    elif batches &gt; 1:\n        # Computing the amount of simulations to be in each batch\n        n_batches = np.array([n / batches] * batches).astype(int)\n        n_batches[:(n%batches)] += 1\n        n_start = 0\n\n        # Full SimulationHistory object\n        combined_hist = None\n\n        # Time tracking\n        all_sim_start_ts = datetime.now()\n\n        # Batches loop\n        batch_iterator = tqdm(n_batches, desc='Batches') if print_progress else n_batches\n        for b_n in batch_iterator:\n            b_hist = run_test(agent = agent,\n                              n = b_n,\n                              start_points = start_points[n_start:n_start+b_n],\n                              environment = environment,\n                              time_shift = time_shift[n_start:n_start+b_n],\n                              time_loop = time_loop,\n                              horizon = horizon,\n                              initialization_values = initialization_values,\n                              reward_discount = reward_discount,\n                              print_progress = print_progress,\n                              print_stats = False, # Forced false to not print too many things\n                              print_warning = False, # If there was any, it would have been printed already\n                              use_gpu = use_gpu,\n                              batches = 1)\n            n_start += b_n\n\n            # Combining SimulationHistory objects\n            if combined_hist is None:\n                combined_hist = b_hist\n            else:\n                combined_hist += b_hist\n\n        # Print stats of the complete history is asked\n        if print_stats:\n            all_sim_end_ts = datetime.now()\n            print(f'Simulations done in {(all_sim_end_ts - all_sim_start_ts).total_seconds():.3f}s:')\n            print(combined_hist.summary)\n\n        return combined_hist\n\n    # Move things to GPU if needed\n    xp = np\n    if use_gpu:\n        assert gpu_support, f\"GPU support is not enabled, the use_gpu option is not available.\"\n        xp = cp\n\n        # Move instances to GPU\n        agent = agent.gpu_version\n        environment = environment.gpu_version\n        time_shift = cp.array(time_shift)\n\n        if start_points is not None:\n            start_points = cp.array(start_points)\n\n    # Set start positions\n    agent_position = None\n    if start_points is not None:\n        assert start_points.shape == (n, environment.dimensions), f'The provided start_points are of the wrong shape (expected {environment.dimensions}; received {start_points.shape[1]})'\n        agent_position = start_points\n    else:\n        # Generating random starts\n        agent_position = environment.random_start_points(n)\n\n    # Initialize agent's state\n    agent.initialize_state(n, **initialization_values)\n\n    # Create simulation history tracker\n    hist = SimulationHistory(\n        start_points=agent_position,\n        environment=environment,\n        agent=agent,\n        time_shift=time_shift,\n        horizon=horizon,\n        reward_discount=reward_discount\n    )\n\n    # Track begin of simulation ts\n    sim_start_ts = datetime.now()\n\n    # Simulation loop\n    iterator = trange(horizon) if print_progress else range(horizon)\n    for i in iterator:\n        # Letting agent choose the action to take based on it's curent state\n        action = agent.choose_action()\n\n        # Updating the agent's actual position (hidden to him)\n        agent_position = environment.move(pos=agent_position,\n                                          movement=(action if not environment.has_layers else action[:,1:])) # Getting only the physical component of the action vector if environment has layers.\n\n        # Get an observation based on the new position of the agent\n        observation = environment.get_observation(pos=agent_position,\n                                                  time=(time_shift + i),\n                                                  layer=(0 if not environment.has_layers else action[:,0])) # Getting the layer information column of the action matrix.\n\n        # Check if the source is reached\n        source_reached = environment.source_reached(agent_position)\n\n        # Add the position to the observation if the agent is space aware\n        if agent.space_aware:\n            observation = xp.hstack((observation[:,None], agent_position))\n\n        # Return the observation to the agent\n        update_succeeded = agent.update_state(action=action,\n                                              observation=observation,\n                                              source_reached=source_reached)\n        if update_succeeded is None:\n            update_succeeded = xp.ones(len(source_reached), dtype=bool)\n\n        # Handling the case where simulations have reached the end\n        sims_at_end = ((time_shift + i + 1) &gt;= (math.inf if time_loop else environment.timesteps))\n\n        # Agents to terminate\n        to_terminate = source_reached | sims_at_end | ~update_succeeded\n\n        # Send the values to the tracker\n        hist.add_step(\n            actions=action,\n            next_positions=agent_position,\n            observations=observation[:,0] if agent.space_aware else observation,\n            reached_source=source_reached,\n            interupt=to_terminate\n        )\n\n        # Interupt agents that reached the end\n        agent_position = agent_position[~to_terminate]\n        time_shift = time_shift[~to_terminate]\n        agent.kill(simulations_to_kill=to_terminate)\n\n        # Early stopping if all agents done\n        if len(agent_position) == 0:\n            break\n\n        # Update progress bar\n        if print_progress:\n            done_count = hist.done_count\n            success_count = hist.success_count\n            success_percentage = (success_count/done_count)*100 if done_count &gt; 0 else 100\n            dead_percentage = ((done_count-success_count)/done_count)*100 if done_count &gt; 0 else 0\n            iterator.set_postfix({\n                'done ': f' {done_count}/{n} ({(done_count/n)*100:.1f}%)',\n                'success ': f' {success_count}/{done_count} ({success_percentage:.1f}%)',\n                'dead ': f' {done_count-success_count}/{done_count} ({dead_percentage:.1f}%)'\n            })\n\n    # If requested print the simulation start\n    if print_stats:\n        sim_end_ts = datetime.now()\n        print(f'Simulations done in {(sim_end_ts - sim_start_ts).total_seconds():.3f}s:')\n        print(hist.summary)\n\n    return hist\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>olfactory_navigation<ul> <li>agent</li> <li>agents<ul> <li>fsvi_agent</li> <li>hsvi_agent</li> <li>infotaxis_agent</li> <li>model_based_util<ul> <li>belief</li> <li>belief_value_mapping</li> <li>environment_converter</li> <li>mdp</li> <li>pomdp</li> <li>value_function</li> <li>vi_solver</li> </ul> </li> <li>pbvi_agent</li> <li>pbvi_ger_agent</li> <li>pbvi_ra_agent</li> <li>pbvi_ssea_agent</li> <li>pbvi_ssga_agent</li> <li>pbvi_ssra_agent</li> <li>perseus_agent</li> <li>q_agent</li> <li>qmdp_agent</li> </ul> </li> <li>build_environment_gui</li> <li>environment</li> <li>simulation</li> <li>test_setups</li> <li>visualization</li> </ul> </li> </ul>"},{"location":"reference/agent/","title":"agent","text":""},{"location":"reference/agent/#olfactory_navigation.agent.Agent","title":"<code>Agent</code>","text":"<p>A generic agent class.</p> <p>It is meant to define the general structure for an agent meant to evolve in a environment of olfactory cues. To define such agent, a set of methods need to be implemented. This methods can be seperated into 3 categories:</p> <ol> <li>Training methods</li> <li>Simulation methods</li> <li>General methods</li> </ol> <p>The training methods are meant to train the agent before testing their performance in a simulation. A single method is needed for this:</p> <ul> <li>train()</li> </ul> <p>The simulation methods are meant for the agent to make choices and receiving observations during a simulation. The following methods are required for this:</p> <ul> <li>initialize_state(): This method is meant for the state of the agent(s) to be initialized before the simulation loop starts. The state of the agent can be an internal clock, a belief or something else arbitrary.</li> <li>choose_action(): Here the agent(s) is asked to choose an action to play based on its internal state.</li> <li>update_state(): Then, after the agent(s) has taken an action, the observation it makes along with whether he reached the source or not is returned to him using this method. This allows the agent to update its internal state.</li> <li>kill(): Finally, the method asks for a set of agents to be terminated. The basic case happens when the agent reaches the source but it can also be asked to terminate if it has reached the end of the simulation without success.</li> </ul> <p>The general methods are methods to perform general actions with the agent. These methods are:</p> <ul> <li>save(): To save the agent to long term storage.</li> <li>load(): To load the agent from long term storage.</li> <li>modify_environment(): To provide an equivalent agent with a different environment linked to it. If the agent has previously been trained, the trained components needs to be adapted to this new environment.</li> <li>to_gpu(): To create an alternative version of the agent whether the array instances are stored on the GPU memory instead of the CPU memory.</li> <li>to_cpu(): To create an alternative version of the agent whether the array instances are stored on the CPU memory instead of the GPU memory.</li> </ul> <p>For a user to implement an agent, the main methods to define are the Simulation methods! The training method is, as stated, optional, as some agent definitions do not require it. And the General methods all have some default behavior and are therefore only needed to be overwritten in specific cases.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment the agent is meant to evolve in.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name for the agent. If it is not provided it will be named like \"-thresh_\". <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>saved_at</code> <code>str</code> <p>If the agent has been saved, the path at which it is saved is recorded in this variable.</p> <code>on_gpu</code> <code>bool</code> <p>Whether the arrays are on the GPU memory or not. For this, the support for Cupy needs to be enabled and the agent needs to have been moved to the GPU using the to_gpu() function.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> Source code in <code>olfactory_navigation/agent.py</code> <pre><code>class Agent:\n    '''\n    A generic agent class.\n\n    It is meant to define the general structure for an agent meant to evolve in a environment of olfactory cues.\n    To define such agent, a set of methods need to be implemented. This methods can be seperated into 3 categories:\n\n    1. Training methods\n    2. Simulation methods\n    3. General methods\n\n    The training methods are meant to train the agent before testing their performance in a simulation. A single method is needed for this:\n\n    - train()\n\n    The simulation methods are meant for the agent to make choices and receiving observations during a simulation. The following methods are required for this:\n\n    - initialize_state(): This method is meant for the state of the agent(s) to be initialized before the simulation loop starts. The state of the agent can be an internal clock, a belief or something else arbitrary.\n    - choose_action(): Here the agent(s) is asked to choose an action to play based on its internal state.\n    - update_state(): Then, after the agent(s) has taken an action, the observation it makes along with whether he reached the source or not is returned to him using this method. This allows the agent to update its internal state.\n    - kill(): Finally, the method asks for a set of agents to be terminated. The basic case happens when the agent reaches the source but it can also be asked to terminate if it has reached the end of the simulation without success.\n\n    The general methods are methods to perform general actions with the agent. These methods are:\n\n    - save(): To save the agent to long term storage.\n    - load(): To load the agent from long term storage.\n    - modify_environment(): To provide an equivalent agent with a different environment linked to it. If the agent has previously been trained, the trained components needs to be adapted to this new environment.\n    - to_gpu(): To create an alternative version of the agent whether the array instances are stored on the GPU memory instead of the CPU memory.\n    - to_cpu(): To create an alternative version of the agent whether the array instances are stored on the CPU memory instead of the GPU memory.\n\n    For a user to implement an agent, the main methods to define are the Simulation methods! The training method is, as stated, optional, as some agent definitions do not require it.\n    And the General methods all have some default behavior and are therefore only needed to be overwritten in specific cases.\n\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment the agent is meant to evolve in.\n\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name for the agent. If it is not provided it will be named like \"&lt;class_name&gt;-thresh_&lt;threshold&gt;\".\n    seed : int, default=12131415\n        For reproducible randomness.\n\n    Attributes\n    ----------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    saved_at : str\n        If the agent has been saved, the path at which it is saved is recorded in this variable.\n    on_gpu : bool\n        Whether the arrays are on the GPU memory or not. For this, the support for Cupy needs to be enabled and the agent needs to have been moved to the GPU using the to_gpu() function.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    '''\n    def __init__(self,\n                 environment: Environment,\n                 thresholds: float | list[float] | dict[str, float] | dict[str, list[float]] = 3e-6,\n                 space_aware: bool = False,\n                 spacial_subdivisions: np.ndarray | None = None,\n                 actions: dict[str, np.ndarray] | np.ndarray | None = None,\n                 name: str | None = None,\n                 seed: int = 12131415\n                 ) -&gt; None:\n        self.environment = environment\n        self.space_aware = space_aware\n\n        # Handle thresholds\n        if isinstance(thresholds, float):\n            thresholds = [thresholds]\n\n        if isinstance(thresholds, list):\n            # Ensure -inf and +inf begin and end the thresholds list\n            if -np.inf not in thresholds:\n                thresholds = [-np.inf] + thresholds\n\n            if np.inf not in thresholds:\n                thresholds = thresholds + [np.inf]\n\n            self.thresholds = np.array(thresholds)\n\n        # Handle the case where a dict of thresholds is provided in the case of a layered environment and ensuring they are ordered.\n        elif isinstance(thresholds, dict):\n            assert self.environment.has_layers, \"Thresholds can only be provided as a dict if the environment is layered.\"\n            assert len(thresholds) == len(self.environment.layer_labels), \"Thresholds must be given for each layers.\"\n\n            if all(isinstance(layer_thresholds, list) for layer_thresholds in thresholds.values()):\n                layer_thresholds_count = len(thresholds.values()[0])\n                assert all(len(layer_thresholds) == layer_thresholds_count for layer_thresholds in thresholds.values()), \"If provided as lists, the threshold lists must all be of the same length.\"\n            else:\n                assert all(isinstance(layer_threshold, float) for layer_threshold in thresholds.values()), \"The thresholds provided in a dictionary must all be list or float, not a combination of both.\"\n\n            # Processing layers of thresholds\n            layer_thresholds_list = []\n            for layer_label in enumerate(self.environment.layer_labels):\n                assert layer_label in thresholds, f\"Environment's layer [{layer_label}] was not matched to any layers of the environment.\"\n                layer_thresholds = thresholds[layer_label]\n\n                if not isinstance(layer_thresholds, list):\n                    layer_thresholds = [layer_thresholds]\n\n                # Ensure -inf and +inf begin and end the thresholds list\n                if -np.inf not in layer_thresholds:\n                    layer_thresholds = [-np.inf] + layer_thresholds\n\n                if np.inf not in layer_thresholds:\n                    layer_thresholds = layer_thresholds + [np.inf]\n\n                layer_thresholds_list.append(layer_thresholds)\n\n            # Building an array with the layers of thresholds\n            self.thresholds = np.array(layer_thresholds_list)\n\n        # Ensuring the thresholds are in ascending order\n        self.thresholds.sort()\n\n        # Spacial subdivisions\n        if spacial_subdivisions is None:\n            self.spacial_subdivisions = np.array(self.environment.shape)\n        else:\n            self.spacial_subdivisions = np.array(spacial_subdivisions)\n        assert len(self.spacial_subdivisions) == self.environment.dimensions, \"The amount of spacial divisions must match the amount of dimensions of the environment.\"\n\n        # Mapping environment to spacial subdivisions\n        env_shape = np.array(self.environment.shape)\n\n        std_size = (env_shape / self.spacial_subdivisions).astype(int)\n        overflows = (env_shape % self.spacial_subdivisions)\n\n        cell_sizes = [(np.repeat(size, partitions) + np.array([np.floor(overflow / 2), *np.zeros(partitions-2), np.ceil(overflow / 2)])).astype(int)\n                    for partitions, size, overflow in zip(self.spacial_subdivisions, std_size, overflows)]\n\n        # Finding the edges of the cells and filling a grid with ids\n        cell_edges = [np.concatenate(([0], np.cumsum(ax_sizes))) for ax_sizes in cell_sizes]\n\n        lower_bounds = np.array([ax_arr.ravel() for ax_arr in np.meshgrid(*[bounds_arr[:-1] for bounds_arr in cell_edges], indexing='ij')]).T\n        upper_bounds = np.array([ax_arr.ravel() for ax_arr in np.meshgrid(*[bounds_arr[1 :] for bounds_arr in cell_edges], indexing='ij')]).T\n\n        self._environment_to_subdivision_mapping = np.full(self.environment.shape, -1)\n        for i, (lower_b, upper_b) in enumerate(zip(lower_bounds, upper_bounds)):\n            slices = [slice(ax_lower, ax_upper) for ax_lower, ax_upper in zip(lower_b, upper_b)]\n\n            # Grid to cell mapping\n            self._environment_to_subdivision_mapping[*slices] = i\n\n        # Allowed actions\n        self.action_labels = None\n        if actions is None:\n            if environment.dimensions == 2:\n                self.action_set = np.array([\n                    [-1,  0], # North\n                    [ 0,  1], # East\n                    [ 1,  0], # South\n                    [ 0, -1]  # West\n                ])\n                self.action_labels = [\n                    'North',\n                    'East',\n                    'South',\n                    'West'\n                ]\n            elif environment.dimensions == 3:\n                self.action_set = np.array([\n                    [ 0, -1,  0], # North\n                    [ 0,  0,  1], # East\n                    [ 0,  1,  0], # South\n                    [ 0,  0, -1], # West\n                    [ 1,  0,  0], # Up\n                    [-1,  0,  0]  # Down\n                ])\n                self.action_labels = [\n                    'North',\n                    'East',\n                    'South',\n                    'West',\n                    'Up',\n                    'Down'\n                ]\n            else: # ND\n                self.action_set = np.zeros((2*environment.dimensions, environment.dimensions))\n                self.action_labels = []\n                for dim in range(environment.dimensions):\n                    # Increase in dimension 'dim'\n                    self.action_set[dim*2, -dim-1] = 1\n                    self.action_labels.append(f'd{dim}+1')\n\n                    # Decrease in dimension 'dim'\n                    self.action_set[(dim*2) + 1, -dim-1] = -1\n                    self.action_labels.append(f'd{dim}-1')\n\n            # Layered\n            if environment.has_layers:\n                self.action_set = np.array([[layer, *action_vector] for layer in environment.layers for action_vector in self.action_set])\n                self.action_labels = [f'l_{layer}_{action}' for  layer in environment.layer_labels for action in self.action_labels]\n\n        # Actions provided as numpy array\n        elif isinstance(actions, np.ndarray):\n            self.action_set = actions\n            self.action_labels = ['a_' + '_'.join([str(dim_a) for dim_a in action_vector]) for action_vector in self.action_set]\n\n        # Actions provided as dict\n        else:\n            self.action_set = np.ndarray(list(actions.values()))\n            self.action_labels = list(actions.keys())\n\n        # Asertion that the shape of the actions set if right\n        layered = 0 if not environment.has_layers else 1\n        assert self.action_set.shape[1] == (layered + environment.dimensions), f\"The shape of the action_set provided is not right. (Found {self.action_set.shape}; expected (., {layered + environment.dimensions}))\"\n\n        # setup name\n        if name is None:\n            self.name = self.class_name\n            if len(self.thresholds.shape) == 2:\n                thresh_string = '-'.join(['_'.join([f'l{row_i}'] + [str(item) for item in row]) for row_i, row in enumerate(self.thresholds[:,1:-1])])\n            else:\n                thresh_string = '_'.join([str(item) for item in self.thresholds])\n            self.name += f'-tresholds-' + thresh_string\n            self.name += '-space_aware' if self.space_aware else ''\n        else:\n            self.name = name\n\n        # Other variables\n        self.saved_at = None\n\n        self.on_gpu = False\n        self._alternate_version = None\n\n        # random state\n        self.seed = seed\n        self.rnd_state = np.random.RandomState(seed = seed)\n\n\n    @property\n    def class_name(self):\n        '''\n        The name of the class of the agent.\n        '''\n        return self.__class__.__name__\n\n\n    # ----------------\n    # Training methods\n    # ----------------\n    def train(self) -&gt; None:\n        '''\n        Optional function to train the agent in the olfactory environment it is in.\n        This function is optional as some agents have some fixed behavior and therefore dont require training.\n        '''\n        raise NotImplementedError('The train function is not implemented, make an agent subclass to implement the method')\n\n\n    # ------------------\n    # Simulation methods\n    # ------------------\n    def initialize_state(self,\n                         n: int = 1\n                         ) -&gt; None:\n        '''\n        Function to initialize the internal state of the agent(s) for the simulation process. The internal state can be concepts such as the \"memory\" or \"belief\" of the agent.\n        The n parameter corresponds to how many \"instances\" need to instanciated. This is meant so that we work with a \"group\" of agents instead of individual instances.\n\n        This is done with the purpose that the state of the group of agents be stored in (Numpy) arrays to allow vectorization instead of sequential loops.\n\n        Parameters\n        ----------\n        n : int, default=1\n            How many agents to initialize.\n        '''\n        raise NotImplementedError('The initialize_state function is not implemented, make an agent subclass to implement the method')\n\n\n    def choose_action(self) -&gt; np.ndarray:\n        '''\n        Function to allow for the agent(s) to choose an action to take based on its current state.\n\n        It should return a 2D array of shape n by 2 (or 3, or 4 depending of whether the environment has layers and/or a 3rd dimension),\n        where n is how many agents are to choose an action. It should be n 2D vectors of (the layer and) the change in the (z,) y, and x positions.\n\n        Returns\n        -------\n        movement_vector : np.ndarray\n            An array of n vectors in 2D space of the movement(s) the agent(s) will take.\n        '''\n        raise NotImplementedError('The choose_action function is not implemented, make an agent subclass to implement the method')\n\n\n    def discretize_observations(self,\n                                observation: np.ndarray,\n                                action: np.ndarray,\n                                source_reached: np.ndarray\n                                ) -&gt; np.ndarray:\n        '''\n        Function to convert a set of observations to discrete observation ids.\n        It uses the olfaction thresholds of the agent to discretize the odor concentrations.\n\n        In the case where the agent is also aware of it's own position in space, in which case the observation matrix is of size n by 1 + environment.dimensions,\n        the agent first converts the points on the grid to position ids and then multiply the id by olfactory observation id.\n\n        Parameters\n        ----------\n        observation : np.ndarray\n            The observations the agent receives, in the case the agent is space_aware, the position point is also included.\n        action: np.ndarray\n            The action the agent did. This parameter is used in the particular case where the environment has layers and the odor thresholds are layer dependent.\n        source_reached : np.ndarray\n            A 1D array of boolean values signifying whether each agent reached or not the source.\n\n        Returns\n        -------\n        discrete_observations: np.ndarray\n            An integer array of discrete observations\n        '''\n        # GPU support\n        xp = np if not self.on_gpu else cp\n\n        n = len(observation)\n        discrete_observations = xp.ones(n, dtype=int) * -1\n\n        # Gather olfactory observation\n        olfactory_observation = observation if not self.space_aware else observation[:,0]\n\n        # Compute the amount of observations available\n        observation_count = self.thresholds.shape[-1] - 1 # |thresholds| - 1 observation buckets\n\n        # Handle the special case where we have a layered environment and different thresholds for these layers\n        if self.environment.has_layers and len(self.thresholds.shape) == 2:\n            layer_ids = action[:,0] # First column of actions is the layer\n            action_layer_thresholds = self.thresholds[layer_ids]\n            observation_ids = xp.argwhere((olfactory_observation[:,None] &gt;= action_layer_thresholds[:,:-1]) &amp; (olfactory_observation[:,None] &lt; action_layer_thresholds[:,1:]))[:,1]\n        else:\n            # Setting observation ids\n            observation_ids = xp.argwhere((olfactory_observation[:,None] &gt;= self.thresholds[:-1][None,:]) &amp; (olfactory_observation[:,None] &lt; self.thresholds[1:][None,:]))[:,1]\n\n        # If needed, multiply observation indices by position indices\n        if not self.space_aware:\n            discrete_observations = observation_ids\n        else:\n            position_clipped = xp.clip(observation[:,1:], a_min=0, a_max=(xp.array(self.environment.shape)-1))\n            position_count = int(xp.prod(self.spacial_subdivisions))\n            position_ids = self._environment_to_subdivision_mapping[*position_clipped.astype(int).T]\n\n            # Add the amount of possible positions to the observation count\n            observation_count *= position_count\n\n            # Combine with observation ids\n            discrete_observations = (observation_ids * position_count) + position_ids\n\n        # Adding the goal observation\n        discrete_observations[source_reached] = observation_count\n\n        return discrete_observations\n\n\n    def update_state(self,\n                     action: np.ndarray,\n                     observation: np.ndarray,\n                     source_reached: np.ndarray\n                     ) -&gt; None | np.ndarray:\n        '''\n        Function to update the internal state(s) of the agent(s) based on the action(s) taken and the observation(s) received.\n        The observations are then compared with the thresholds to decide whether something was sensed or not or to what level.\n\n        Parameters\n        ----------\n        action : np.ndarray\n            A 2D array of n movement vectors. If the environment is layered, the 1st component should be the layer.\n        observation : np.ndarray\n            A n by 1 (or 1 + environment.dimensions if space_aware) array of odor cues (float values) retrieved from the environment.\n        source_reached : np.array\n            A 1D array of boolean values signifying whether each agent reached or not the source.\n\n        Returns\n        -------\n        update_successfull : np.ndarray, optional\n            If nothing is returned, it means all the agent's state updates have been successfull.\n            Else, a boolean np.ndarray of size n can be returned confirming for each agent whether the update has been successful or not.\n        '''\n        raise NotImplementedError('The update_state function is not implemented, make an agent subclass to implement the method')\n\n\n    def kill(self,\n             simulations_to_kill: np.ndarray\n             ) -&gt; None:\n        '''\n        Function to kill any agents that either reached the source or failed by not reaching the source before the horizon or failing to update its own state.\n        The agents where the simulations_to_kill paramater is True have to removed from the list of agents.\n        It is necessary because their reference will also be removed from the simulation loop. Therefore, if they are not removed, the array sizes will not match anymore.\n\n        Parameters\n        ----------\n        simulations_to_kill : np.ndarray\n            An array of size n containing boolean values of whether or not agent's simulations are terminated and therefore should be removed.\n        '''\n        raise NotImplementedError('The kill function is not implemented, make an agent subclass to implement the method')\n\n\n    # ---------------\n    # General methods\n    # ---------------\n    def save(self,\n             folder: str | None = None,\n             force: bool = False,\n             save_environment: bool = False\n             ) -&gt; None:\n        '''\n        Function to save a trained agent to long term storage.\n        By default, the agent is saved in its entirety using pickle.\n\n        However, it is strongly advised to overwrite this method to only save save the necessary components of the agents in order to be able to load it and reproduce its behavior.\n        For instance, if the agent is saved after the simulation is run, the state would also be saved within the pickle which is not wanted.\n\n        Parameters\n        ----------\n        folder : str, optional\n            The folder in which the agent's data should be saved.\n        force : bool, default=False\n            If the agent is already saved at the folder provided, the saving should fail.\n            If the already saved agent should be overwritten, this parameter should be toggled to True.\n        save_environment : bool, default=False\n            Whether to save the agent's linked environment alongside the agent itself.\n        '''\n        if self.on_gpu:\n            cpu_agent = self.to_cpu()\n            cpu_agent.save(folder=folder, force=force, save_environment=save_environment)\n            return\n\n        # Adding env name to folder path\n        if folder is None:\n            folder = f'./Agent-{self.name}'\n        else:\n            folder += f'/Agent-{self.name}'\n\n        # Checking the folder exists or creates it\n        if not os.path.exists(folder):\n            os.mkdir(folder)\n        elif len(os.listdir(folder)) &gt; 0:\n            if force:\n                shutil.rmtree(folder)\n                os.mkdir(folder)\n            else:\n                raise Exception(f'{folder} is not empty. If you want to overwrite the saved agent, enable \"force\".')\n\n        # Send self to pickle\n        with open(folder + '/binary.pkl', 'wb') as f:\n            pickle.dump(self, f)\n\n        # Save environment in folder too if requested\n        if save_environment:\n            self.environment.save(folder=(folder + f'/Env-{self.environment.name}'))\n\n\n    @classmethod\n    def load(cls,\n             folder: str\n             ) -&gt; 'Agent':\n        '''\n        Function to load a trained agent from long term storage.\n        By default, as for the save function, it will load the agent from the folder assuming it is a pickle file.\n\n        Parameters\n        ----------\n        folder : str\n            The folder in which the agent was saved.\n\n        Returns\n        -------\n        loaded_agent : Agent\n            The agent loaded from the folder.\n        '''\n        from olfactory_navigation import agents\n\n        for name, obj in inspect.getmembers(agents):\n            if inspect.isclass(obj) and (name in folder) and issubclass(obj, cls) and (obj != cls):\n                return obj.load(folder)\n\n        # Default loading with pickle\n        with open(folder + '/binary.pkl', 'rb') as f:\n            return pickle.load(f)\n\n\n    def modify_environment(self,\n                           new_environment: Environment\n                           ) -&gt; 'Agent':\n        '''\n        Function to modify the environment of the agent.\n\n        Note: By default, a new agent is created with the same thresholds and name but with a this new environment!\n        If there are any trained elements to the agent, they are to be modified in this method to be adapted to this new environment.\n\n        Parameters\n        ----------\n        new_environment : Environment\n            The new environment to replace the agent in an equivalent agent.\n\n        Returns\n        -------\n        modified_agent : Agent\n            A new Agent whose environment has been replaced.\n        '''\n        # TODO: Fix this to account for other init parameters\n        modified_agent = self.__class__(environment=new_environment,\n                                        thresholds=self.thresholds,\n                                        name=self.name)\n        return modified_agent\n\n\n    def to_gpu(self) -&gt; 'Agent':\n        '''\n        Function to send the numpy arrays of the agent to the gpu.\n        It returns a new instance of the Agent class with the arrays on the gpu.\n\n        Returns\n        -------\n        gpu_agent : Agent\n            A new environment instance where the arrays are on the gpu memory.\n        '''\n        # Check whether the agent is already on the gpu or not\n        if self.on_gpu:\n            return self\n\n        # Warn and overwrite alternate_version in case it already exists\n        if self._alternate_version is not None:\n            print('[warning] A GPU instance already existed and is being recreated.')\n            self._alternate_version = None\n\n        assert gpu_support, \"GPU support is not enabled, Cupy might need to be installed...\"\n\n        # Generating a new instance\n        cls = self.__class__\n        gpu_agent = cls.__new__(cls)\n\n        # Copying arguments to gpu\n        for arg, val in self.__dict__.items():\n            if isinstance(val, np.ndarray):\n                setattr(gpu_agent, arg, cp.array(val))\n            elif arg == 'rnd_state':\n                setattr(gpu_agent, arg, cp.random.RandomState(self.seed))\n            else:\n                setattr(gpu_agent, arg, val)\n\n        # Self reference instances\n        self._alternate_version = gpu_agent\n        gpu_agent._alternate_version = self\n\n        gpu_agent.on_gpu = True\n        return gpu_agent\n\n\n    def to_cpu(self) -&gt; 'Agent':\n        '''\n        Function to send the numpy arrays of the agent to the cpu.\n        It returns a new instance of the Agent class with the arrays on the cpu.\n\n        Returns\n        -------\n        cpu_agent : Agent\n            A new environment instance where the arrays are on the cpu memory.\n        '''\n        # Check whether the agent is already on the cpu or not\n        if not self.on_gpu:\n            return self\n\n        if self._alternate_version is not None:\n            print('[warning] A CPU instance already existed and is being recreated.')\n            self._alternate_version = None\n\n        # Generating a new instance\n        cls = self.__class__\n        cpu_agent = cls.__new__(cls)\n\n        # Copying arguments to gpu\n        for arg, val in self.__dict__.items():\n            if isinstance(val, cp.ndarray):\n                setattr(cpu_agent, arg, cp.asnumpy(val))\n            elif arg == 'rnd_state':\n                setattr(cpu_agent, arg, np.random.RandomState(self.seed))\n            else:\n                setattr(cpu_agent, arg, val)\n\n        # Self reference instances\n        self._alternate_version = cpu_agent\n        cpu_agent._alternate_version = self\n\n        cpu_agent.on_gpu = True\n        return cpu_agent\n\n\n    @property\n    def gpu_version(self):\n        '''\n        A version of the Agent on the GPU.\n        If the agent is already on the GPU it returns itself, otherwise the to_gpu function is called to generate a new one.\n        '''\n        if self.on_gpu:\n            return self\n        else:\n            if self._alternate_version is not None: # Check if an alternate version already exists\n                return self._alternate_version\n            else: # Generate an alternate version on the gpu\n                return self.to_gpu()\n\n\n    @property\n    def cpu_version(self):\n        '''\n        A version of the Agent on the CPU.\n        If the agent is already on the CPU it returns itself, otherwise the to_cpu function is called to generate a new one.\n        '''\n        if not self.on_gpu:\n            return self\n        else:\n            if self._alternate_version is not None: # Check if an alternate version already exists\n                return self._alternate_version\n            else: # Generate an alternate version on the cpu\n                return self.to_cpu()\n</code></pre>"},{"location":"reference/agent/#olfactory_navigation.agent.Agent.class_name","title":"<code>class_name</code>  <code>property</code>","text":"<p>The name of the class of the agent.</p>"},{"location":"reference/agent/#olfactory_navigation.agent.Agent.cpu_version","title":"<code>cpu_version</code>  <code>property</code>","text":"<p>A version of the Agent on the CPU. If the agent is already on the CPU it returns itself, otherwise the to_cpu function is called to generate a new one.</p>"},{"location":"reference/agent/#olfactory_navigation.agent.Agent.gpu_version","title":"<code>gpu_version</code>  <code>property</code>","text":"<p>A version of the Agent on the GPU. If the agent is already on the GPU it returns itself, otherwise the to_gpu function is called to generate a new one.</p>"},{"location":"reference/agent/#olfactory_navigation.agent.Agent.choose_action","title":"<code>choose_action()</code>","text":"<p>Function to allow for the agent(s) to choose an action to take based on its current state.</p> <p>It should return a 2D array of shape n by 2 (or 3, or 4 depending of whether the environment has layers and/or a 3rd dimension), where n is how many agents are to choose an action. It should be n 2D vectors of (the layer and) the change in the (z,) y, and x positions.</p> <p>Returns:</p> Name Type Description <code>movement_vector</code> <code>ndarray</code> <p>An array of n vectors in 2D space of the movement(s) the agent(s) will take.</p> Source code in <code>olfactory_navigation/agent.py</code> <pre><code>def choose_action(self) -&gt; np.ndarray:\n    '''\n    Function to allow for the agent(s) to choose an action to take based on its current state.\n\n    It should return a 2D array of shape n by 2 (or 3, or 4 depending of whether the environment has layers and/or a 3rd dimension),\n    where n is how many agents are to choose an action. It should be n 2D vectors of (the layer and) the change in the (z,) y, and x positions.\n\n    Returns\n    -------\n    movement_vector : np.ndarray\n        An array of n vectors in 2D space of the movement(s) the agent(s) will take.\n    '''\n    raise NotImplementedError('The choose_action function is not implemented, make an agent subclass to implement the method')\n</code></pre>"},{"location":"reference/agent/#olfactory_navigation.agent.Agent.discretize_observations","title":"<code>discretize_observations(observation, action, source_reached)</code>","text":"<p>Function to convert a set of observations to discrete observation ids. It uses the olfaction thresholds of the agent to discretize the odor concentrations.</p> <p>In the case where the agent is also aware of it's own position in space, in which case the observation matrix is of size n by 1 + environment.dimensions, the agent first converts the points on the grid to position ids and then multiply the id by olfactory observation id.</p> <p>Parameters:</p> Name Type Description Default <code>observation</code> <code>ndarray</code> <p>The observations the agent receives, in the case the agent is space_aware, the position point is also included.</p> required <code>action</code> <code>ndarray</code> <p>The action the agent did. This parameter is used in the particular case where the environment has layers and the odor thresholds are layer dependent.</p> required <code>source_reached</code> <code>ndarray</code> <p>A 1D array of boolean values signifying whether each agent reached or not the source.</p> required <p>Returns:</p> Name Type Description <code>discrete_observations</code> <code>ndarray</code> <p>An integer array of discrete observations</p> Source code in <code>olfactory_navigation/agent.py</code> <pre><code>def discretize_observations(self,\n                            observation: np.ndarray,\n                            action: np.ndarray,\n                            source_reached: np.ndarray\n                            ) -&gt; np.ndarray:\n    '''\n    Function to convert a set of observations to discrete observation ids.\n    It uses the olfaction thresholds of the agent to discretize the odor concentrations.\n\n    In the case where the agent is also aware of it's own position in space, in which case the observation matrix is of size n by 1 + environment.dimensions,\n    the agent first converts the points on the grid to position ids and then multiply the id by olfactory observation id.\n\n    Parameters\n    ----------\n    observation : np.ndarray\n        The observations the agent receives, in the case the agent is space_aware, the position point is also included.\n    action: np.ndarray\n        The action the agent did. This parameter is used in the particular case where the environment has layers and the odor thresholds are layer dependent.\n    source_reached : np.ndarray\n        A 1D array of boolean values signifying whether each agent reached or not the source.\n\n    Returns\n    -------\n    discrete_observations: np.ndarray\n        An integer array of discrete observations\n    '''\n    # GPU support\n    xp = np if not self.on_gpu else cp\n\n    n = len(observation)\n    discrete_observations = xp.ones(n, dtype=int) * -1\n\n    # Gather olfactory observation\n    olfactory_observation = observation if not self.space_aware else observation[:,0]\n\n    # Compute the amount of observations available\n    observation_count = self.thresholds.shape[-1] - 1 # |thresholds| - 1 observation buckets\n\n    # Handle the special case where we have a layered environment and different thresholds for these layers\n    if self.environment.has_layers and len(self.thresholds.shape) == 2:\n        layer_ids = action[:,0] # First column of actions is the layer\n        action_layer_thresholds = self.thresholds[layer_ids]\n        observation_ids = xp.argwhere((olfactory_observation[:,None] &gt;= action_layer_thresholds[:,:-1]) &amp; (olfactory_observation[:,None] &lt; action_layer_thresholds[:,1:]))[:,1]\n    else:\n        # Setting observation ids\n        observation_ids = xp.argwhere((olfactory_observation[:,None] &gt;= self.thresholds[:-1][None,:]) &amp; (olfactory_observation[:,None] &lt; self.thresholds[1:][None,:]))[:,1]\n\n    # If needed, multiply observation indices by position indices\n    if not self.space_aware:\n        discrete_observations = observation_ids\n    else:\n        position_clipped = xp.clip(observation[:,1:], a_min=0, a_max=(xp.array(self.environment.shape)-1))\n        position_count = int(xp.prod(self.spacial_subdivisions))\n        position_ids = self._environment_to_subdivision_mapping[*position_clipped.astype(int).T]\n\n        # Add the amount of possible positions to the observation count\n        observation_count *= position_count\n\n        # Combine with observation ids\n        discrete_observations = (observation_ids * position_count) + position_ids\n\n    # Adding the goal observation\n    discrete_observations[source_reached] = observation_count\n\n    return discrete_observations\n</code></pre>"},{"location":"reference/agent/#olfactory_navigation.agent.Agent.initialize_state","title":"<code>initialize_state(n=1)</code>","text":"<p>Function to initialize the internal state of the agent(s) for the simulation process. The internal state can be concepts such as the \"memory\" or \"belief\" of the agent. The n parameter corresponds to how many \"instances\" need to instanciated. This is meant so that we work with a \"group\" of agents instead of individual instances.</p> <p>This is done with the purpose that the state of the group of agents be stored in (Numpy) arrays to allow vectorization instead of sequential loops.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>How many agents to initialize.</p> <code>1</code> Source code in <code>olfactory_navigation/agent.py</code> <pre><code>def initialize_state(self,\n                     n: int = 1\n                     ) -&gt; None:\n    '''\n    Function to initialize the internal state of the agent(s) for the simulation process. The internal state can be concepts such as the \"memory\" or \"belief\" of the agent.\n    The n parameter corresponds to how many \"instances\" need to instanciated. This is meant so that we work with a \"group\" of agents instead of individual instances.\n\n    This is done with the purpose that the state of the group of agents be stored in (Numpy) arrays to allow vectorization instead of sequential loops.\n\n    Parameters\n    ----------\n    n : int, default=1\n        How many agents to initialize.\n    '''\n    raise NotImplementedError('The initialize_state function is not implemented, make an agent subclass to implement the method')\n</code></pre>"},{"location":"reference/agent/#olfactory_navigation.agent.Agent.kill","title":"<code>kill(simulations_to_kill)</code>","text":"<p>Function to kill any agents that either reached the source or failed by not reaching the source before the horizon or failing to update its own state. The agents where the simulations_to_kill paramater is True have to removed from the list of agents. It is necessary because their reference will also be removed from the simulation loop. Therefore, if they are not removed, the array sizes will not match anymore.</p> <p>Parameters:</p> Name Type Description Default <code>simulations_to_kill</code> <code>ndarray</code> <p>An array of size n containing boolean values of whether or not agent's simulations are terminated and therefore should be removed.</p> required Source code in <code>olfactory_navigation/agent.py</code> <pre><code>def kill(self,\n         simulations_to_kill: np.ndarray\n         ) -&gt; None:\n    '''\n    Function to kill any agents that either reached the source or failed by not reaching the source before the horizon or failing to update its own state.\n    The agents where the simulations_to_kill paramater is True have to removed from the list of agents.\n    It is necessary because their reference will also be removed from the simulation loop. Therefore, if they are not removed, the array sizes will not match anymore.\n\n    Parameters\n    ----------\n    simulations_to_kill : np.ndarray\n        An array of size n containing boolean values of whether or not agent's simulations are terminated and therefore should be removed.\n    '''\n    raise NotImplementedError('The kill function is not implemented, make an agent subclass to implement the method')\n</code></pre>"},{"location":"reference/agent/#olfactory_navigation.agent.Agent.load","title":"<code>load(folder)</code>  <code>classmethod</code>","text":"<p>Function to load a trained agent from long term storage. By default, as for the save function, it will load the agent from the folder assuming it is a pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>The folder in which the agent was saved.</p> required <p>Returns:</p> Name Type Description <code>loaded_agent</code> <code>Agent</code> <p>The agent loaded from the folder.</p> Source code in <code>olfactory_navigation/agent.py</code> <pre><code>@classmethod\ndef load(cls,\n         folder: str\n         ) -&gt; 'Agent':\n    '''\n    Function to load a trained agent from long term storage.\n    By default, as for the save function, it will load the agent from the folder assuming it is a pickle file.\n\n    Parameters\n    ----------\n    folder : str\n        The folder in which the agent was saved.\n\n    Returns\n    -------\n    loaded_agent : Agent\n        The agent loaded from the folder.\n    '''\n    from olfactory_navigation import agents\n\n    for name, obj in inspect.getmembers(agents):\n        if inspect.isclass(obj) and (name in folder) and issubclass(obj, cls) and (obj != cls):\n            return obj.load(folder)\n\n    # Default loading with pickle\n    with open(folder + '/binary.pkl', 'rb') as f:\n        return pickle.load(f)\n</code></pre>"},{"location":"reference/agent/#olfactory_navigation.agent.Agent.modify_environment","title":"<code>modify_environment(new_environment)</code>","text":"<p>Function to modify the environment of the agent.</p> <p>Note: By default, a new agent is created with the same thresholds and name but with a this new environment! If there are any trained elements to the agent, they are to be modified in this method to be adapted to this new environment.</p> <p>Parameters:</p> Name Type Description Default <code>new_environment</code> <code>Environment</code> <p>The new environment to replace the agent in an equivalent agent.</p> required <p>Returns:</p> Name Type Description <code>modified_agent</code> <code>Agent</code> <p>A new Agent whose environment has been replaced.</p> Source code in <code>olfactory_navigation/agent.py</code> <pre><code>def modify_environment(self,\n                       new_environment: Environment\n                       ) -&gt; 'Agent':\n    '''\n    Function to modify the environment of the agent.\n\n    Note: By default, a new agent is created with the same thresholds and name but with a this new environment!\n    If there are any trained elements to the agent, they are to be modified in this method to be adapted to this new environment.\n\n    Parameters\n    ----------\n    new_environment : Environment\n        The new environment to replace the agent in an equivalent agent.\n\n    Returns\n    -------\n    modified_agent : Agent\n        A new Agent whose environment has been replaced.\n    '''\n    # TODO: Fix this to account for other init parameters\n    modified_agent = self.__class__(environment=new_environment,\n                                    thresholds=self.thresholds,\n                                    name=self.name)\n    return modified_agent\n</code></pre>"},{"location":"reference/agent/#olfactory_navigation.agent.Agent.save","title":"<code>save(folder=None, force=False, save_environment=False)</code>","text":"<p>Function to save a trained agent to long term storage. By default, the agent is saved in its entirety using pickle.</p> <p>However, it is strongly advised to overwrite this method to only save save the necessary components of the agents in order to be able to load it and reproduce its behavior. For instance, if the agent is saved after the simulation is run, the state would also be saved within the pickle which is not wanted.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>The folder in which the agent's data should be saved.</p> <code>None</code> <code>force</code> <code>bool</code> <p>If the agent is already saved at the folder provided, the saving should fail. If the already saved agent should be overwritten, this parameter should be toggled to True.</p> <code>False</code> <code>save_environment</code> <code>bool</code> <p>Whether to save the agent's linked environment alongside the agent itself.</p> <code>False</code> Source code in <code>olfactory_navigation/agent.py</code> <pre><code>def save(self,\n         folder: str | None = None,\n         force: bool = False,\n         save_environment: bool = False\n         ) -&gt; None:\n    '''\n    Function to save a trained agent to long term storage.\n    By default, the agent is saved in its entirety using pickle.\n\n    However, it is strongly advised to overwrite this method to only save save the necessary components of the agents in order to be able to load it and reproduce its behavior.\n    For instance, if the agent is saved after the simulation is run, the state would also be saved within the pickle which is not wanted.\n\n    Parameters\n    ----------\n    folder : str, optional\n        The folder in which the agent's data should be saved.\n    force : bool, default=False\n        If the agent is already saved at the folder provided, the saving should fail.\n        If the already saved agent should be overwritten, this parameter should be toggled to True.\n    save_environment : bool, default=False\n        Whether to save the agent's linked environment alongside the agent itself.\n    '''\n    if self.on_gpu:\n        cpu_agent = self.to_cpu()\n        cpu_agent.save(folder=folder, force=force, save_environment=save_environment)\n        return\n\n    # Adding env name to folder path\n    if folder is None:\n        folder = f'./Agent-{self.name}'\n    else:\n        folder += f'/Agent-{self.name}'\n\n    # Checking the folder exists or creates it\n    if not os.path.exists(folder):\n        os.mkdir(folder)\n    elif len(os.listdir(folder)) &gt; 0:\n        if force:\n            shutil.rmtree(folder)\n            os.mkdir(folder)\n        else:\n            raise Exception(f'{folder} is not empty. If you want to overwrite the saved agent, enable \"force\".')\n\n    # Send self to pickle\n    with open(folder + '/binary.pkl', 'wb') as f:\n        pickle.dump(self, f)\n\n    # Save environment in folder too if requested\n    if save_environment:\n        self.environment.save(folder=(folder + f'/Env-{self.environment.name}'))\n</code></pre>"},{"location":"reference/agent/#olfactory_navigation.agent.Agent.to_cpu","title":"<code>to_cpu()</code>","text":"<p>Function to send the numpy arrays of the agent to the cpu. It returns a new instance of the Agent class with the arrays on the cpu.</p> <p>Returns:</p> Name Type Description <code>cpu_agent</code> <code>Agent</code> <p>A new environment instance where the arrays are on the cpu memory.</p> Source code in <code>olfactory_navigation/agent.py</code> <pre><code>def to_cpu(self) -&gt; 'Agent':\n    '''\n    Function to send the numpy arrays of the agent to the cpu.\n    It returns a new instance of the Agent class with the arrays on the cpu.\n\n    Returns\n    -------\n    cpu_agent : Agent\n        A new environment instance where the arrays are on the cpu memory.\n    '''\n    # Check whether the agent is already on the cpu or not\n    if not self.on_gpu:\n        return self\n\n    if self._alternate_version is not None:\n        print('[warning] A CPU instance already existed and is being recreated.')\n        self._alternate_version = None\n\n    # Generating a new instance\n    cls = self.__class__\n    cpu_agent = cls.__new__(cls)\n\n    # Copying arguments to gpu\n    for arg, val in self.__dict__.items():\n        if isinstance(val, cp.ndarray):\n            setattr(cpu_agent, arg, cp.asnumpy(val))\n        elif arg == 'rnd_state':\n            setattr(cpu_agent, arg, np.random.RandomState(self.seed))\n        else:\n            setattr(cpu_agent, arg, val)\n\n    # Self reference instances\n    self._alternate_version = cpu_agent\n    cpu_agent._alternate_version = self\n\n    cpu_agent.on_gpu = True\n    return cpu_agent\n</code></pre>"},{"location":"reference/agent/#olfactory_navigation.agent.Agent.to_gpu","title":"<code>to_gpu()</code>","text":"<p>Function to send the numpy arrays of the agent to the gpu. It returns a new instance of the Agent class with the arrays on the gpu.</p> <p>Returns:</p> Name Type Description <code>gpu_agent</code> <code>Agent</code> <p>A new environment instance where the arrays are on the gpu memory.</p> Source code in <code>olfactory_navigation/agent.py</code> <pre><code>def to_gpu(self) -&gt; 'Agent':\n    '''\n    Function to send the numpy arrays of the agent to the gpu.\n    It returns a new instance of the Agent class with the arrays on the gpu.\n\n    Returns\n    -------\n    gpu_agent : Agent\n        A new environment instance where the arrays are on the gpu memory.\n    '''\n    # Check whether the agent is already on the gpu or not\n    if self.on_gpu:\n        return self\n\n    # Warn and overwrite alternate_version in case it already exists\n    if self._alternate_version is not None:\n        print('[warning] A GPU instance already existed and is being recreated.')\n        self._alternate_version = None\n\n    assert gpu_support, \"GPU support is not enabled, Cupy might need to be installed...\"\n\n    # Generating a new instance\n    cls = self.__class__\n    gpu_agent = cls.__new__(cls)\n\n    # Copying arguments to gpu\n    for arg, val in self.__dict__.items():\n        if isinstance(val, np.ndarray):\n            setattr(gpu_agent, arg, cp.array(val))\n        elif arg == 'rnd_state':\n            setattr(gpu_agent, arg, cp.random.RandomState(self.seed))\n        else:\n            setattr(gpu_agent, arg, val)\n\n    # Self reference instances\n    self._alternate_version = gpu_agent\n    gpu_agent._alternate_version = self\n\n    gpu_agent.on_gpu = True\n    return gpu_agent\n</code></pre>"},{"location":"reference/agent/#olfactory_navigation.agent.Agent.train","title":"<code>train()</code>","text":"<p>Optional function to train the agent in the olfactory environment it is in. This function is optional as some agents have some fixed behavior and therefore dont require training.</p> Source code in <code>olfactory_navigation/agent.py</code> <pre><code>def train(self) -&gt; None:\n    '''\n    Optional function to train the agent in the olfactory environment it is in.\n    This function is optional as some agents have some fixed behavior and therefore dont require training.\n    '''\n    raise NotImplementedError('The train function is not implemented, make an agent subclass to implement the method')\n</code></pre>"},{"location":"reference/agent/#olfactory_navigation.agent.Agent.update_state","title":"<code>update_state(action, observation, source_reached)</code>","text":"<p>Function to update the internal state(s) of the agent(s) based on the action(s) taken and the observation(s) received. The observations are then compared with the thresholds to decide whether something was sensed or not or to what level.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>ndarray</code> <p>A 2D array of n movement vectors. If the environment is layered, the 1st component should be the layer.</p> required <code>observation</code> <code>ndarray</code> <p>A n by 1 (or 1 + environment.dimensions if space_aware) array of odor cues (float values) retrieved from the environment.</p> required <code>source_reached</code> <code>array</code> <p>A 1D array of boolean values signifying whether each agent reached or not the source.</p> required <p>Returns:</p> Name Type Description <code>update_successfull</code> <code>(ndarray, optional)</code> <p>If nothing is returned, it means all the agent's state updates have been successfull. Else, a boolean np.ndarray of size n can be returned confirming for each agent whether the update has been successful or not.</p> Source code in <code>olfactory_navigation/agent.py</code> <pre><code>def update_state(self,\n                 action: np.ndarray,\n                 observation: np.ndarray,\n                 source_reached: np.ndarray\n                 ) -&gt; None | np.ndarray:\n    '''\n    Function to update the internal state(s) of the agent(s) based on the action(s) taken and the observation(s) received.\n    The observations are then compared with the thresholds to decide whether something was sensed or not or to what level.\n\n    Parameters\n    ----------\n    action : np.ndarray\n        A 2D array of n movement vectors. If the environment is layered, the 1st component should be the layer.\n    observation : np.ndarray\n        A n by 1 (or 1 + environment.dimensions if space_aware) array of odor cues (float values) retrieved from the environment.\n    source_reached : np.array\n        A 1D array of boolean values signifying whether each agent reached or not the source.\n\n    Returns\n    -------\n    update_successfull : np.ndarray, optional\n        If nothing is returned, it means all the agent's state updates have been successfull.\n        Else, a boolean np.ndarray of size n can be returned confirming for each agent whether the update has been successful or not.\n    '''\n    raise NotImplementedError('The update_state function is not implemented, make an agent subclass to implement the method')\n</code></pre>"},{"location":"reference/build_environment_gui/","title":"build_environment_gui","text":""},{"location":"reference/build_environment_gui/#olfactory_navigation.build_environment_gui.buildWindow","title":"<code>buildWindow()</code>","text":"<p>Main method to build an environment builder GUI.</p> Source code in <code>olfactory_navigation/build_environment_gui.py</code> <pre><code>def buildWindow():\n    '''\n    Main method to build an environment builder GUI.\n    '''\n\n    # GLOBAL VARIABLES\n    bold_font = 'Helvetica 12 bold'\n    frame_padding = 10\n\n    entry_fields = {}\n    linked_fields = {\n        'margin_all': ['shape_y', 'shape_y', 'shape_x', 'shape_x', 'margin_up', 'margin_down', 'margin_left', 'margin_right'],\n        'margin_ver': ['shape_y', 'shape_y', 'margin_up', 'margin_down'],\n        'margin_hor': ['shape_x', 'shape_x', 'margin_left', 'margin_right'],\n        'margin_up': ['shape_y'],\n        'margin_down': ['shape_y'],\n        'margin_left': ['shape_x'],\n        'margin_right': ['shape_x']\n    }\n\n    class EnvironmentConfig:\n        def __init__(self):\n            self.data_file = None\n            self._data = None\n            self.data_frame = None\n            self.config = {}\n\n            # Plotting\n            self.mpl_frame = None\n            self.canvas = None\n\n        @property\n        def data(self):\n            return self._data\n\n        @data.setter\n        def data(self, dat):\n            self._data = dat\n            self.data_frame = self._data[0]\n\n            # Shape\n            self.config['shape_y'] = str(self.data_frame.shape[0])\n            self.config['shape_x'] = str(self.data_frame.shape[1])\n\n            # Source\n            self.config['data_source_y'] = \"0\"\n            self.config['data_source_x'] = \"0\"\n            self.config['source_radius'] = \"1\"\n\n            # Margins\n            self.config['margin_all'] = \"\"\n            self.config['margin_ver'] = \"\"\n            self.config['margin_hor'] = \"\"\n\n            self.config['margin_left'] = \"0\"\n            self.config['margin_right'] = \"0\"\n            self.config['margin_up'] = \"0\"\n            self.config['margin_down'] = \"0\"\n\n            # Multiplier\n            self.config['multiplier_y'] = \"100\"\n            self.config['multiplier_x'] = \"100\"\n\n            # Other\n            self.config['interpolation'] = \"Linear\"\n            self.config['boundary'] = \"stop\"\n            self.config['start_zone'] = \"odor_present\"\n            self.config['threshold'] = \"3e-6\"\n            self.config['name'] = \"\"\n            self.config['seed'] = \"12131415\"\n\n            # Matplotlib frame\n            self.mpl_frame, _ = plt.subplots(figsize=(10,3))\n\n\n        def refresh(self):\n            # REFRESH PLOT\n            ax = self.mpl_frame.get_axes()[0]\n            ax.clear()\n\n            # Basics\n            shape = np.array([int(self.config['shape_y']), int(self.config['shape_x'])])\n            margins = np.array([\n                [int(self.config['margin_up']), int(self.config['margin_down'])],\n                [int(self.config['margin_left']), int(self.config['margin_right'])]\n            ])\n            data_source_position = np.array([int(self.config['data_source_y']), int(self.config['data_source_x'])])\n\n\n            # Computing bounds\n            data_bounds = np.array([\n                [margins[0,0], shape[0] - margins[0,1]],\n                [margins[1,0], shape[1] - margins[1,1]]\n            ])\n            new_data_shape = np.diff(data_bounds, axis=1)[:,0].astype(int)\n\n            # Multiplier\n            multiplier = np.array([int(self.config['multiplier_y'])/100, int(self.config['multiplier_x'])/100])\n            new_data_shape = (new_data_shape * multiplier).astype(int)\n\n            # New source position and margins based on multiplier\n            new_source_position = (data_source_position * multiplier).astype(int)\n\n            margins[:,0] -= (new_source_position - data_source_position)\n            margins[:,1] = (shape - (margins[:,0] + new_data_shape))\n\n            data_source_position = new_source_position\n\n            # Source position\n            source_position = data_source_position + margins[:,0]\n            source_radius = int(self.config['source_radius'])\n\n            # Recomputing bounds\n            data_bounds = np.array([\n                [margins[0,0], shape[0] - margins[0,1]],\n                [margins[1,0], shape[1] - margins[1,1]]\n            ])\n\n            # Interpolation of new data\n            interpolation_options = {\n                'Nearest': cv2.INTER_NEAREST,\n                'Linear': cv2.INTER_LINEAR,\n                'Cubic': cv2.INTER_CUBIC\n            }\n\n            new_data_frame = np.zeros(new_data_shape)\n            new_data_frame = cv2.resize(self.data_frame, new_data_shape[::-1], interpolation=interpolation_options[self.config['interpolation']])\n\n            # Computing start zone\n            start_probabilities = np.zeros(shape, dtype=float)\n            if self.config['start_zone'] == 'odor_present':\n                non_zero_obs = np.where(np.sum((self.data &gt; float(self.config['threshold'])).astype(float), axis=0) &gt; 0, 1.0, 0.0)\n                new_shape_non_zero_obs = cv2.resize(non_zero_obs, new_data_shape[::-1], interpolation=interpolation_options[self.config['interpolation']])\n\n                start_probabilities[data_bounds[0,0]:data_bounds[0,1], data_bounds[1,0]:data_bounds[1,1]] = new_shape_non_zero_obs\n            else:\n                start_probabilities[data_bounds[0,0]:data_bounds[0,1], data_bounds[1,0]:data_bounds[1,1]] = 1.0\n\n            source_mask = np.fromfunction(lambda x,y: ((x - source_position[0])**2 + (y - source_position[1])**2) &lt;= source_radius**2, shape=shape)\n            start_probabilities[source_mask] = 0\n\n            start_probabilities /= np.sum(start_probabilities)\n\n            # Odor grid\n            odor = plt.Rectangle([0,0], 1, 1, color='black', fill=True)\n            frame_data = (new_data_frame &gt; float(self.config['threshold'])).astype(float)\n            environment_frame = np.zeros(shape, dtype=float)\n            environment_frame[data_bounds[0,0]:data_bounds[0,1], data_bounds[1,0]:data_bounds[1,1]] = frame_data\n            ax.imshow(environment_frame, cmap='Greys')\n\n            # Start zone contour\n            start_zone = plt.Rectangle([0,0], 1, 1, color='blue', fill=False)\n            ax.contour(start_probabilities, levels=[0.0], colors='blue')\n\n            # Source circle\n            goal_circle = plt.Circle(source_position[::-1], source_radius, color='r', fill=False)\n            ax.add_patch(goal_circle)\n\n            # Legend\n            ax.legend([odor, start_zone, goal_circle], [f'Frame odor cues', 'Start zone', 'Source'])\n\n            # Crop to size\n            ax.set_ylim([shape[0]-1, 0])\n            ax.set_xlim([0, shape[1]-1])\n\n            # Add axis ticks\n            ax.set_yticks(np.arange(0, shape[0], step=10).tolist() + [shape[0]-1 if shape[0]-1 % 10 != 0 else None])\n            ax.set_xticks(np.arange(0, shape[1], step=10).tolist() + [shape[1]-1 if shape[1]-1 % 10 != 0 else None])\n\n            # Refresh canvas\n            self.canvas.draw()\n\n        def is_valid(self) -&gt; bool:\n            margins = np.array([[int(self.config['margin_up']), int(self.config['margin_down'])],\n                                [int(self.config['margin_left']), int(self.config['margin_right'])]])\n            axis_margins = np.sum(margins, axis=1)\n\n            data_source_position = np.array([int(self.config['data_source_y']), int(self.config['data_source_x'])])\n\n            shape = np.array([int(self.config['shape_y']), int(self.config['shape_x'])])\n            data_shape = shape - axis_margins\n\n            multiplier = np.array([int(self.config['multiplier_y']), int(self.config['multiplier_x'])]) / 100\n\n            # MARGINS\n            if np.any(margins &lt; 0):\n                return False\n\n            # SHAPE\n            if np.any(shape &lt; axis_margins):\n                return False\n\n            # DATA SOURCE\n            if np.any(data_source_position &lt; 0) or np.any(data_source_position &gt;= data_shape):\n                return False\n\n            # MULTIPLIER\n            if np.any(multiplier &lt; 0):\n                return False\n\n            with np.errstate(divide='ignore', invalid='ignore'):\n                low_max_mult = ((margins[:,0] / data_source_position) + 1)\n                high_max_mult = (1 + (margins[:,1] / (data_shape - data_source_position)))\n                max_mult = np.min(np.vstack([low_max_mult, high_max_mult]), axis=0)\n\n                if np.any(multiplier &gt; max_mult):\n                    return False\n\n            return True\n\n\n    data_config = EnvironmentConfig()\n\n    def gather_entries_and_refresh():\n        '''\n        Function to gather the values from all the entry fields and refresh the printed data\n        '''\n        old_config = {}\n        changed_config = {}\n\n        for k, entry in entry_fields.items():\n            old_config[k] = data_config.config[k]\n            data_config.config[k] = entry.get()\n\n            changed_config[k] = (old_config[k] != data_config.config[k])\n\n        if not data_config.is_valid():\n\n            # Resetting the changed configs\n            for k, entry in entry_fields.items():\n                if not changed_config[k]:\n                    continue\n\n                data_config.config[k] = old_config[k]\n\n                if isinstance(entry, tk.Entry):\n                    entry.delete(0, tk.END)\n                    entry.insert(0, old_config[k])\n                elif isinstance(entry, tk.StringVar):\n                    entry.set(old_config[k])\n                else:\n                    raise Exception(f'{k} entry not supported')\n\n            popFailWin(['Caused the config to fail:',\n                        *[f'- \"{k.replace(\"_\", \" \")}\"' for k, v in changed_config.items() if v],\n                        \"\",\n                        \"Values were reset to the last good value!\"])\n        else:\n            data_config.refresh()\n\n    # Base of the window\n    root = tk.Tk()\n    root.title('olfactory-navigation - Environment Builder')\n\n    root.bind('&lt;Return&gt;', lambda _: gather_entries_and_refresh())\n\n    def closeAction():\n        root.destroy()\n        quit()\n\n    root.protocol('WM_DELETE_WINDOW', closeAction)\n\n    root_panel = tk.Frame(root)\n    root_panel.pack(side=\"bottom\", fill=\"both\", expand=\"yes\")\n\n\n    # SUCCESS window\n    def popSuccessWin(to_print:str):\n        '''\n        Function to spawn a success popup window\n        '''\n        success_win = tk.Tk()\n\n        success_label = tk.Label(success_win, text=\"Success!\", font=\"Helvetica 12 bold\", fg='green')\n        success_label.pack(side=\"top\")\n\n        success_print_entry = tk.Entry(success_win, width=40)\n        success_print_entry.insert(0, to_print)\n        success_print_entry.pack(side=\"top\", pady=4)\n\n        success_close_button = tk.Button(success_win, text='OK', command=success_win.destroy)\n        success_close_button.pack(side=\"top\")\n\n        success_win.mainloop()\n\n\n    def popFailWin(lines:list[str]):\n        fail_win = tk.Tk()\n\n        fail_label = tk.Label(fail_win, text=\"Wrong config!\", font=\"Helvetica 12 bold\", fg='red')\n        fail_label.pack(side=\"top\")\n\n        fail_text = tk.Text(master=fail_win)\n        fail_text.insert(\"1.0\", '\\n'.join(lines))\n        fail_text.pack(side=\"top\")\n\n        fail_close_button = tk.Button(fail_win, text='OK', command=fail_win.destroy)\n        fail_close_button.pack(side=\"top\")\n\n        fail_win.mainloop()\n\n\n\n    # FILE CHOOSER\n    file_panel = tk.Frame(root_panel)\n    file_panel.grid(row=0, columnspan=3, sticky=\"w\", padx=frame_padding, pady=frame_padding)\n\n    file_chooser_label = tk.Label(master=file_panel, text='Base file:')\n    file_chooser_label.pack(side=\"left\")\n\n    file_path_entry = tk.Entry(master=file_panel, width=100)\n    file_path_entry.insert(0, \"G:/My Drive/Documents/Universita di Genova/Pimlb work/nose_data_27_123.npy\")\n    file_path_entry.pack(side=\"left\", fill=\"x\", padx=5)\n\n    def browseFiles():\n        '''\n        Function to spawn a file browser\n        '''\n        data_file = filedialog.askopenfilename(initialdir = \"./\",\n                                            title = \"Select a File\",\n                                            filetypes = ((\"Numpy files\",\n                                                            \"*.npy*\"),\n                                                        (\"all files\",\n                                                            \"*.*\")))\n\n        file_path_entry.delete(0, tk.END)\n        file_path_entry.insert(0, data_file)\n\n    browse_button = tk.Button(master=file_panel, text=\"Browse\", command=browseFiles)\n    browse_button.pack(side=\"left\", padx=5)\n\n    def loadFiles():\n        '''\n        Function to load the file whose path is given and spawn all the frames\n        '''\n        data_config.data_file = file_path_entry.get()\n        data_config.data = np.load(file_path_entry.get())\n        print(f'Data loaded with shape {data_config.data.shape}')\n\n        printDataInfo()\n        otherParameters()\n        totalSizeConfig()\n        sourceConfig()\n        marginConfig()\n        multiplierConfig()\n        finalizeFrame()\n        createPreviewWindow()\n\n    load_data_button = tk.Button(master=file_panel, text=\"Load\", command=loadFiles)\n    load_data_button.pack(side=\"left\", padx=5)\n\n    # Def print data info:\n    def printDataInfo():\n        '''\n        Create a frame where the basic information of the data is displayed\n        '''\n        data_info_frame = tk.Frame(root_panel)\n        data_info_frame.grid(row=1, column=0, sticky=\"nw\", padx=frame_padding, pady=frame_padding)\n\n        data_info_label = tk.Label(data_info_frame, text='Data info', font=bold_font)\n        data_info_label.grid(row=0, columnspan=2, sticky=\"w\", pady=5)\n\n        for i, cat in enumerate(['Timestamps', 'Height', 'Width']):\n\n            cat_label = tk.Label(master=data_info_frame, text=(cat + \": \"))\n            cat_label.grid(column=0, row=i+1, sticky=\"w\")\n\n            frame = tk.Frame(master=data_info_frame, relief=tk.SUNKEN, borderwidth=2)\n            frame.grid(column=1, row=i+1, sticky=\"w\")\n\n            info_label = tk.Label(master=frame, text=str(data_config.data.shape[i]))\n            info_label.pack(side=\"left\")\n\n\n    def createValueConfig(in_frame, at_row, name, config_name, entry_enabled=True):\n        '''\n        The basic setup for an entry with --, -, +, ++ buttons\n        '''\n        value_label = tk.Label(in_frame, text=(name + \":\"))\n        value_label.grid(row=at_row, column=0, sticky=\"w\")\n\n        value_entry_frame = tk.Frame(in_frame)\n        value_entry_frame.grid(row=at_row, column=1, sticky=\"w\")\n\n        value_entry = tk.Entry(value_entry_frame, width=4, validate=\"focusout\", validatecommand=gather_entries_and_refresh, bg=('black' if not entry_enabled else None))\n        if entry_enabled:\n            value_entry.insert(0, str(data_config.config[config_name])) # Set default value\n\n        entry_fields[config_name] = value_entry\n\n        def changeEntryValue(entry:tk.Entry, val:int):\n            if entry_enabled:\n                current_val = int(entry.get())\n                entry.delete(0, tk.END)\n\n                new_val = current_val + val\n                entry.insert(0, str(new_val))\n\n            if config_name in linked_fields:\n                for linked_config in linked_fields[config_name]:\n                    linked_entry = entry_fields[linked_config]\n\n                    current_val = int(linked_entry.get())\n                    linked_entry.delete(0, tk.END)\n\n                    new_val = current_val + val\n                    linked_entry.insert(0, str(new_val))\n\n            gather_entries_and_refresh()\n\n        value_decrease_10 = tk.Button(value_entry_frame, text=\"--\", command=(lambda: changeEntryValue(value_entry, -10)))\n        value_decrease_10.grid(row=0, column=0, sticky=\"w\", padx=2)\n        value_decrease_1 = tk.Button(value_entry_frame, text=\"-\", command=(lambda: changeEntryValue(value_entry, -1)))\n        value_decrease_1.grid(row=0, column=1, sticky=\"w\", padx=2)\n\n        value_entry.grid(row=0, column=2, sticky=\"w\", padx=2)\n\n        value_increase_1 = tk.Button(value_entry_frame, text=\"+\", command=(lambda: changeEntryValue(value_entry, 1)))\n        value_increase_1.grid(row=0, column=3, sticky=\"w\", padx=2)\n        value_increase_10 = tk.Button(value_entry_frame, text=\"++\", command=(lambda: changeEntryValue(value_entry, 10)))\n        value_increase_10.grid(row=0, column=4, sticky=\"w\", padx=2)\n\n\n    # FINAL (or TOTAL) SIZE CONFIG\n    def totalSizeConfig():\n        '''\n        Create a frame to configure the total size of the environment\n        '''\n        total_size_frame = tk.Frame(root_panel)\n        total_size_frame.grid(row=2, column=0, sticky=\"nw\", padx=frame_padding, pady=frame_padding)\n\n        total_size_label = tk.Label(master=total_size_frame, text=\"Total Size Configuration\", font=bold_font)\n        total_size_label.grid(row=0, columnspan=2, sticky=\"w\", pady=5)\n\n        createValueConfig(in_frame=total_size_frame, at_row=1, name=\"Total Height\", config_name=\"shape_y\")\n        createValueConfig(in_frame=total_size_frame, at_row=2, name=\"Total Width\", config_name=\"shape_x\")\n\n\n    # SOURCE CONFIG\n    def sourceConfig():\n        '''\n        Create a frame for the configuration of the source position and radius with regard to the data frame\n        '''\n        source_frame = tk.Frame(root_panel)\n        source_frame.grid(row=1, column=2, sticky=\"nw\", padx=frame_padding, pady=frame_padding)\n\n        source_label = tk.Label(master=source_frame, text=\"Source Configuration\", font=bold_font)\n        source_label.grid(row=0, columnspan=2, sticky=\"w\", pady=5)\n\n        createValueConfig(in_frame=source_frame, at_row=1, name=\"Source Y\", config_name=\"data_source_y\")\n        createValueConfig(in_frame=source_frame, at_row=2, name=\"Source X\", config_name=\"data_source_x\")\n        createValueConfig(in_frame=source_frame, at_row=3, name=\"Source radius\", config_name=\"source_radius\")\n\n\n    # MARGINS CONFIG\n    def marginConfig():\n        '''\n        Create a frame for the configuration of the margins\n        '''\n        margin_config_frame = tk.Frame(root_panel)\n        margin_config_frame.grid(row=1, column=1, rowspan=2, sticky=\"nw\", padx=frame_padding, pady=frame_padding)\n\n        margin_config_label = tk.Label(master=margin_config_frame, text=\"Margins Configuration\", font=bold_font)\n        margin_config_label.grid(row=0, columnspan=2, sticky=\"w\", pady=5)\n\n        createValueConfig(in_frame=margin_config_frame, at_row=1, name=\"All margins\", config_name=\"margin_all\", entry_enabled=False)\n        createValueConfig(in_frame=margin_config_frame, at_row=2, name=\"Margins Vertical\", config_name=\"margin_ver\", entry_enabled=False)\n        createValueConfig(in_frame=margin_config_frame, at_row=3, name=\"Margins Horizontal\", config_name=\"margin_hor\", entry_enabled=False)\n\n        createValueConfig(in_frame=margin_config_frame, at_row=4, name=\"Margin Up\", config_name=\"margin_up\")\n        createValueConfig(in_frame=margin_config_frame, at_row=5, name=\"Margin Down\", config_name=\"margin_down\")\n        createValueConfig(in_frame=margin_config_frame, at_row=6, name=\"Margin Left\", config_name=\"margin_left\")\n        createValueConfig(in_frame=margin_config_frame, at_row=7, name=\"Margin Right\", config_name=\"margin_right\")\n\n\n    # MULT CONFIG\n    def multiplierConfig():\n        '''\n        Create a frame with the multipliers\n        '''\n        mult_config_frame = tk.Frame(root_panel)\n        mult_config_frame.grid(row=2, column=2, sticky=\"nw\", padx=frame_padding, pady=frame_padding)\n\n        mult_config_label = tk.Label(master=mult_config_frame, text=\"Multiplier Configuration\", font=bold_font)\n        mult_config_label.grid(row=0, columnspan=2, sticky=\"w\", pady=5)\n\n        createValueConfig(in_frame=mult_config_frame, at_row=1, name=\"Height Multiplier (%)\", config_name=\"multiplier_y\")\n        createValueConfig(in_frame=mult_config_frame, at_row=2, name=\"Width Multiplier (%)\", config_name=\"multiplier_x\")\n\n\n    def otherParameters():\n        '''\n        Create a frame for the configuration of generatal other parameters that (some dont have a direct effect on the environment)\n        '''\n        other_params_frame = tk.Frame(root_panel)\n        other_params_frame.grid(row=1, column=3, rowspan=2, sticky=\"nw\", padx=frame_padding, pady=frame_padding)\n\n        other_params_label = tk.Label(other_params_frame, text=\"Other Parameters\", font=bold_font)\n        other_params_label.grid(row=0, columnspan=2, sticky=\"nw\", pady=5)\n\n        # Interpolation\n        interpolation_label = tk.Label(other_params_frame, text=\"Interpolation\")\n        interpolation_label.grid(row=1, column=0, sticky=\"nw\")\n\n        interpolation_variable = tk.StringVar(other_params_frame)\n        interpolation_variable.set(data_config.config['interpolation'])\n        interpolation_variable.trace_add(\"write\", lambda *args: gather_entries_and_refresh())\n\n        interpolation_choice = tk.OptionMenu(other_params_frame, interpolation_variable, *['Nearest', 'Linear', 'Cubic'])\n        interpolation_choice.grid(row=1, column=1, sticky=\"nw\")\n        entry_fields['interpolation'] = interpolation_variable\n\n        # Boundary\n        boundary_label = tk.Label(other_params_frame, text=\"Boundary\")\n        boundary_label.grid(row=2, column=0, sticky=\"nw\")\n\n        boundary_variable = tk.StringVar(other_params_frame)\n        boundary_variable.set(data_config.config['boundary'])\n\n        boundary_choice = tk.OptionMenu(other_params_frame, boundary_variable, *['stop', 'wrap', 'wrap_vertical', 'wrap_horizontal', 'clip', 'no'])\n        boundary_choice.grid(row=2, column=1, sticky=\"nw\")\n        entry_fields['boundary'] = boundary_variable\n\n        # Start\n        start_label = tk.Label(other_params_frame, text=\"Start zone\")\n        start_label.grid(row=3, column=0, sticky=\"nw\")\n\n        start_variable = tk.StringVar(other_params_frame)\n        start_variable.set(data_config.config['start_zone'])\n        start_variable.trace_add(\"write\", lambda *args: gather_entries_and_refresh())\n\n        start_choice = tk.OptionMenu(other_params_frame, start_variable, *['odor_present', 'data_zone'])\n        start_choice.grid(row=3, column=1, sticky=\"nw\")\n        entry_fields['start_zone'] = start_variable\n\n        # Odor Present\n        threshold_label = tk.Label(other_params_frame, text=\"Odor threshold\")\n        threshold_label.grid(row=4, column=0, sticky=\"nw\")\n\n        threshold_entry = tk.Entry(other_params_frame, width=5, validate=\"focusout\", validatecommand=gather_entries_and_refresh)\n        threshold_entry.grid(row=4, column=1, sticky=\"nw\")\n        threshold_entry.insert(0, data_config.config['threshold'])\n        entry_fields['threshold'] = threshold_entry\n\n        # Name\n        name_label = tk.Label(other_params_frame, text=\"Environment Name\")\n        name_label.grid(row=5, column=0, sticky=\"nw\")\n\n        name_entry = tk.Entry(other_params_frame, width=20)\n        name_entry.grid(row=5, column=1, sticky=\"nw\")\n        name_entry.insert(0, data_config.config['name'])\n        entry_fields['name'] = name_entry\n\n        # Seed\n        seed_label = tk.Label(other_params_frame, text=\"Seed\")\n        seed_label.grid(row=6, column=0, sticky=\"nw\")\n\n        seed_entry = tk.Entry(other_params_frame, width=10)\n        seed_entry.grid(row=6, column=1, sticky=\"nw\")\n        seed_entry.insert(0, data_config.config['seed'])\n        entry_fields['seed'] = seed_entry\n\n\n    # FINALIZE\n    def finalizeFrame():\n        '''\n        Create a frame with the buttons to finalize the environment\n        '''\n        finalize_frame = tk.Frame(root_panel)\n        finalize_frame.grid(row=0, column=3, padx=frame_padding, pady=frame_padding)\n\n        # SAVE TO FILE\n        def save_to_file():\n            save_path = filedialog.askdirectory()\n\n            environment = Environment(data_file=data_config.data_file,\n                                      data_source_position=[int(data_config.config['data_source_y']), int(data_config.config['data_source_x'])],\n                                      source_radius=int(data_config.config['source_radius']),\n                                      shape=[int(data_config.config['shape_y']), int(data_config.config['shape_x'])],\n                                      multiplier=[int(data_config.config['multiplier_y'])/100, int(data_config.config['multiplier_x'])/100],\n                                      interpolation_method=data_config.config['interpolation'],\n                                      margins=[[int(data_config.config['margin_up']), int(data_config.config['margin_down'])], [int(data_config.config['margin_left']), int(data_config.config['margin_right'])]],\n                                      boundary_condition=data_config.config['boundary'],\n                                      start_zone=data_config.config['start_zone'],\n                                      odor_present_threshold=float(data_config.config['threshold']),\n                                      name=(data_config.config.get('name') if (data_config.config['name'] is not None) and (len(data_config.config['name']) &gt; 0) else None),\n                                      seed=int(data_config.config['seed']))\n\n            environment.save(folder=save_path)\n\n            popSuccessWin('Environment saved!')\n\n        save_button = tk.Button(finalize_frame, text=\"Save\", font=bold_font, command=save_to_file)\n        save_button.pack(side=\"left\", padx=5)\n\n        # PRINT\n        def print_to_cmd():\n            '''\n            Function to print a statement to build an environment based on what was defined within the GUI.\n            It will print the statement in the cmd.\n            '''\n            print('Copy the following in your code to instantiate an environment based on the definition you made:\\n')\n\n            lines =  f\"environment = Environment(data_file='{data_config.data_file}',\\n\"\n            lines += f\"                          data_source_position=[{data_config.config['data_source_y']}, {data_config.config['data_source_x']}],\\n\"\n            lines += f\"                          source_radius={data_config.config['source_radius']},\\n\"\n            lines += f\"                          shape=[{data_config.config['shape_y']}, {data_config.config['shape_x']}],\\n\"\n            lines += f\"                          multiplier=[{str(int(data_config.config['multiplier_y'])/100)}, {str(int(data_config.config['multiplier_x'])/100)}],\\n\"\n            lines += f\"                          interpolation='{data_config.config['interpolation']}',\\n\"\n            lines += f\"                          margins=[[{data_config.config['margin_up']}, {data_config.config['margin_down']}], [{data_config.config['margin_left']}, {data_config.config['margin_right']}]],\\n\"\n            lines += f\"                          boundary_condition='{data_config.config['boundary']}',\\n\"\n            lines += f\"                          start_zone='{data_config.config['start_zone']}',\\n\"\n            lines += f\"                          odor_present_threshold={data_config.config['threshold']},\\n\"\n            if (data_config.config['name'] is not None) and (len(data_config.config['name']) &gt; 0):\n                lines += f\"                          name='{data_config.config['name']}',\\n\"\n            lines += f\"                          seed={data_config.config['seed']})\\n\"\n\n            print(lines)\n\n            # Print to new window\n            output_window = tk.Tk()\n            out_text = tk.Text(output_window)\n            out_text.insert(\"1.0\", lines)\n            out_text.pack()\n            output_window.mainloop()\n\n\n        print_button = tk.Button(finalize_frame, text=\"Print\", font=bold_font, command=print_to_cmd)\n        print_button.pack(side=\"left\", padx=5)\n\n\n    # PREVIEW WINDOW\n    def createPreviewWindow():\n        '''\n        Create a seperate preview window of the environment\n        '''\n        preview_frame = tk.Frame(root_panel)\n        preview_frame.grid(row=4, columnspan=4, sticky=\"nw\", padx=frame_padding, pady=frame_padding)\n\n        preview_label = tk.Label(preview_frame, text=\"Preview\", font=bold_font)\n        preview_label.pack(anchor=\"nw\", pady=5)\n\n        canvas = FigureCanvasTkAgg(data_config.mpl_frame, master=preview_frame)\n        canvas.draw()\n        canvas.get_tk_widget().pack(side=\"top\", fill=\"both\", expand=1)\n\n        data_config.canvas = canvas\n        data_config.refresh()\n\n    tk.mainloop()\n</code></pre>"},{"location":"reference/environment/","title":"environment","text":""},{"location":"reference/environment/#olfactory_navigation.environment.Environment","title":"<code>Environment</code>","text":"<p>Class to represent an olfactory environment.</p> <p>It is defined based on an olfactory data set provided as either a numpy file or an array directly with shape time, y, x. From this environment, the various parameters are applied in the following order:</p> <ol> <li>The source position is set</li> <li>The margins are added and the shape (total size) of the environment are set.</li> <li>The data file's x and y components are squished and streched the to fit the inter-marginal shape of the environment.</li> <li>The source's position is also moved to stay at the same position within the data.</li> <li>The multiplier is finally applied to modify the data file's x and y components a final time by growing or shrinking the margins to account for the multiplier. (The multiplication applies with the source position as a center point)</li> </ol> <p>Note: to modify the shape of the data file's x and y components the OpenCV library's resize function is used. And the interpolation method is controlled by the interpolation_method parameter.</p> <p>Then, the starting probability map is built. Either an array can be provided directly or preset option can be chosen:</p> <ul> <li>'data_zone': The agent can start at any point in the data_zone (after all the modification parameters have been applied)</li> <li>'odor_present': The agent can start at any point where an odor cue above the odor_present_threshold can be found at any timestep during the simulation</li> </ul> <p>Parameters:</p> Name Type Description Default <code>data_file</code> <code>str or ndarray</code> <p>The dataset containing the olfactory data. It can be provided as a path to a file containing said array.</p> required <code>data_source_position</code> <code>list or ndarray</code> <p>The center point of the source provided as a list or a 1D array with the components being x,y. This position is computed in the olfactory data zone (so excluding the margins).</p> required <code>source_radius</code> <code>float</code> <p>The radius from the center point of the source in which we consider the agent has reached the source.</p> <code>1.0</code> <code>layers</code> <code>bool or list[int] or list[str]</code> <p>Whether or not the data provided contains layers or not. If a list of strings is provided, it will be either used to name the layers found (if numpy data), or it is used to querry the datasets of the h5 file.</p> <code>False</code> <code>shape</code> <code>list or ndarray</code> <p>A 2-element array or list of how many units should be kept in the final array (including the margins). As it should include the margins, the shape should be strictly larger than the sum of the margins in each direction. By default, the shape of the olfactory data will be maintained.</p> <code>None</code> <code>margins</code> <code>int or list or ndarray</code> <p>How many units have to be added to the data as margins. (Before the multiplier is applied) If a unique element is provided, the margin will be this same value on each side. If a list or array of 2 elements is provided, the first number will be vertical margins (y-axis), while the other will be on the x-axis (horizontal).</p> <code>0</code> <code>multiplier</code> <code>list or ndarray</code> <p>A 2-element array or list of how much the odor field should be streched in each direction. If a value larger than 1 is provided, the margins will be reduced to accomodate for the larger size of the olfactory data size. And inversly, less than 1 will increase the margins. By default, the multipliers will be set to 1.0.</p> <code>[1.0,1.0]</code> <code>interpolation_method</code> <code>Nearest or Linear or Cubic</code> <p>The interpolation method to be used in the case the data needs to be reshaped to fit the shape, margins and multiplier parameters. By default, it uses Bi-linear interpolation. The interpolation is performed using the OpenCV library.</p> <code>'Linear'</code> <code>preprocess_data</code> <code>bool</code> <p>Applicable only for data_file being a path to a h5 file. Whether to reshape of the data at the creation of the environment. Reshaping the data ahead of time will require more processing at the creation and more memory overall. While if this is disabled, when gathering observations, more time will be required but less memory will need to be used at once.</p> <code>False</code> <code>boundary_condition</code> <code>stop or wrap or wrap_vertical or wrap_horizontal or clip</code> <p>How the agent should behave at the boundary. Stop means for the agent to stop at the boundary, if the agent tries to move north while being on the top edge, it will stay in the same state. Wrap means for the borders to be like portals, when entering on one side, it reappears on the other side. Wrap can be specified to be only vertically or horizontally</p> <code>'stop'</code> <code>start_zone</code> <code>odor_present or data_zone or ndarray</code> <p>Either an array or a string representing how the starting probabilities should be constructed. - odor_present: The start probabilities will be uniform where odor cues can be found above 0 (or a given odor_present_threshold) - data_zone: Uniform over the data zone, so without the margins. Note that the points within the source radius will be excluded from this probability grid.</p> <code>'data_zone'</code> <code>odor_present_threshold</code> <code>float</code> <p>An olfactory threshold, under which the odor is considered too low to be noticed. It is used only to build the starting zone if the 'odor_present' option is selected.</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to be given to the agent. If it is not provided, by default it will have the format: -marg_-edge_-start_-source__radius <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <p>Attributes:</p> Name Type Description <code>data</code> <code>ndarray</code> <p>An array containing the olfactory data after the modification parameters have been applied.</p> <code>data_file_path</code> <code>str</code> <p>If the data is loaded from a path, the path will be recorded here.</p> <code>data_source_position</code> <code>ndarray</code> <p>The position of the source in the original data file (after modifications have been applied).</p> <code>layers</code> <code>ndarray</code> <p>A numbered list of the IDs of the layers.</p> <code>layer_labels</code> <code>list[str]</code> <p>A list of how the layers are named.</p> <code>has_layers</code> <code>bool</code> <p>Whether or not the environment is made up of layers.</p> <code>margins</code> <code>ndarray</code> <p>An array of the margins vertically and horizontally (after multiplier is applied).</p> <code>timestamps</code> <code>int</code> <p>The amount of timeslices available in the environment.</p> <code>data_shape</code> <code>tuple[int]</code> <p>The shape of the data's odor field (after modifications have been applied).</p> <code>dimensions</code> <code>int</code> <p>The amount of dimensions of the physical space of the olfactory environment.</p> <code>shape</code> <code>tuple[int]</code> <p>The shape of the environment. It is a tuple of the size in each axis of the environment.</p> <code>data_bounds</code> <code>ndarray</code> <p>The bounds between which the original olfactory data stands in the coordinate system of the environment (after modifications have been applied).</p> <code>source_position</code> <code>ndarray</code> <p>The position of the source in the padded grid (after modifications have been applied).</p> <code>source_radius</code> <code>float</code> <p>The radius of the source.</p> <code>interpolation_method</code> <code>str</code> <p>The interpolation used to modify the shape of the original data.</p> <code>data_processed</code> <code>bool</code> <p>Whether the data was processed (ie the shape is at it should be) or not.</p> <code>boundary_condition</code> <code>str</code> <p>How the agent should behave when reaching the boundary.</p> <code>start_probabilities</code> <code>ndarray</code> <p>A probability map of where the agent is likely to start within the environment. Note: Zero within the source radius.</p> <code>start_type</code> <code>str</code> <p>The type of the start probability map building. For instance: 'data_zone', 'odor_present', or 'custom' (if an array is provided).</p> <code>odor_present_threshold</code> <code>float</code> <p>The threshold used to uild the start probabilities if the option 'odor_present' is used.</p> <code>name</code> <code>str</code> <p>The name set to the agent as defined in the parameters.</p> <code>saved_at</code> <code>str</code> <p>If the environment is saved, the path at which it is saved will be recorded here.</p> <code>on_gpu</code> <code>bool</code> <p>Whether the environment's arrays are on the gpu's memory or not.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Environment</code> <p>An instance of the environment on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Environment</code> <p>An instance of the environment on the CPU. If it already is, it returns itself.</p> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>class Environment:\n    '''\n    Class to represent an olfactory environment.\n\n    It is defined based on an olfactory data set provided as either a numpy file or an array directly with shape time, y, x.\n    From this environment, the various parameters are applied in the following order:\n\n    0. The source position is set\n    1. The margins are added and the shape (total size) of the environment are set.\n    2. The data file's x and y components are squished and streched the to fit the inter-marginal shape of the environment.\n    3. The source's position is also moved to stay at the same position within the data.\n    4. The multiplier is finally applied to modify the data file's x and y components a final time by growing or shrinking the margins to account for the multiplier. (The multiplication applies with the source position as a center point)\n\n    Note: to modify the shape of the data file's x and y components the OpenCV library's resize function is used. And the interpolation method is controlled by the interpolation_method parameter.\n\n\n    Then, the starting probability map is built. Either an array can be provided directly or preset option can be chosen:\n\n    - 'data_zone': The agent can start at any point in the data_zone (after all the modification parameters have been applied)\n    - 'odor_present': The agent can start at any point where an odor cue above the odor_present_threshold can be found at any timestep during the simulation\n\n    Parameters\n    ----------\n    data_file : str or np.ndarray\n        The dataset containing the olfactory data. It can be provided as a path to a file containing said array.\n    data_source_position : list or np.ndarray\n        The center point of the source provided as a list or a 1D array with the components being x,y.\n        This position is computed in the olfactory data zone (so excluding the margins).\n    source_radius : float, default=1.0\n        The radius from the center point of the source in which we consider the agent has reached the source.\n    layers : bool or list[int] or list[str], default=False\n        Whether or not the data provided contains layers or not.\n        If a list of strings is provided, it will be either used to name the layers found (if numpy data), or it is used to querry the datasets of the h5 file.\n    shape : list or np.ndarray, optional\n        A 2-element array or list of how many units should be kept in the final array (including the margins).\n        As it should include the margins, the shape should be strictly larger than the sum of the margins in each direction.\n        By default, the shape of the olfactory data will be maintained.\n    margins : int or list or np.ndarray, default=0\n        How many units have to be added to the data as margins. (Before the multiplier is applied)\n        If a unique element is provided, the margin will be this same value on each side.\n        If a list or array of 2 elements is provided, the first number will be vertical margins (y-axis), while the other will be on the x-axis (horizontal).\n    multiplier : list or np.ndarray, default=[1.0,1.0]\n        A 2-element array or list of how much the odor field should be streched in each direction.\n        If a value larger than 1 is provided, the margins will be reduced to accomodate for the larger size of the olfactory data size.\n        And inversly, less than 1 will increase the margins.\n        By default, the multipliers will be set to 1.0.\n    interpolation_method : 'Nearest' or 'Linear' or 'Cubic', default='Linear'\n        The interpolation method to be used in the case the data needs to be reshaped to fit the shape, margins and multiplier parameters.\n        By default, it uses Bi-linear interpolation. The interpolation is performed using the OpenCV library.\n    preprocess_data : bool, default=False\n        Applicable only for data_file being a path to a h5 file.\n        Whether to reshape of the data at the creation of the environment.\n        Reshaping the data ahead of time will require more processing at the creation and more memory overall.\n        While if this is disabled, when gathering observations, more time will be required but less memory will need to be used at once.\n    boundary_condition : 'stop' or 'wrap' or 'wrap_vertical' or 'wrap_horizontal' or 'clip', default='stop'\n        How the agent should behave at the boundary.\n        Stop means for the agent to stop at the boundary, if the agent tries to move north while being on the top edge, it will stay in the same state.\n        Wrap means for the borders to be like portals, when entering on one side, it reappears on the other side.\n        Wrap can be specified to be only vertically or horizontally\n    start_zone : 'odor_present' or 'data_zone' or np.ndarray, default='data_zone'\n        Either an array or a string representing how the starting probabilities should be constructed.\n        - odor_present: The start probabilities will be uniform where odor cues can be found above 0 (or a given odor_present_threshold)\n        - data_zone: Uniform over the data zone, so without the margins.\n        Note that the points within the source radius will be excluded from this probability grid.\n    odor_present_threshold : float, optional\n        An olfactory threshold, under which the odor is considered too low to be noticed.\n        It is used only to build the starting zone if the 'odor_present' option is selected.\n    name : str, optional\n        A custom name to be given to the agent.\n        If it is not provided, by default it will have the format:\n        &lt;shape&gt;-marg_&lt;margins&gt;-edge_&lt;boundary_condition&gt;-start_&lt;start_zone&gt;-source_&lt;source_point&gt;_radius&lt;source_radius&gt;\n    seed : int, default=12131415\n        For reproducible randomness.\n\n    Attributes\n    ----------\n    data : np.ndarray\n        An array containing the olfactory data after the modification parameters have been applied.\n    data_file_path : str\n        If the data is loaded from a path, the path will be recorded here.\n    data_source_position : np.ndarray\n        The position of the source in the original data file (after modifications have been applied).\n    layers : np.ndarray\n        A numbered list of the IDs of the layers.\n    layer_labels : list[str]\n        A list of how the layers are named.\n    has_layers : bool\n        Whether or not the environment is made up of layers.\n    margins : np.ndarray\n        An array of the margins vertically and horizontally (after multiplier is applied).\n    timestamps : int\n        The amount of timeslices available in the environment.\n    data_shape : tuple[int]\n        The shape of the data's odor field (after modifications have been applied).\n    dimensions : int\n        The amount of dimensions of the physical space of the olfactory environment.\n    shape : tuple[int]\n        The shape of the environment. It is a tuple of the size in each axis of the environment.\n    data_bounds : np.ndarray\n        The bounds between which the original olfactory data stands in the coordinate system of the environment (after modifications have been applied).\n    source_position : np.ndarray\n        The position of the source in the padded grid (after modifications have been applied).\n    source_radius : float\n        The radius of the source.\n    interpolation_method : str\n        The interpolation used to modify the shape of the original data.\n    data_processed : bool\n        Whether the data was processed (ie the shape is at it should be) or not.\n    boundary_condition : str\n        How the agent should behave when reaching the boundary.\n    start_probabilities : np.ndarray\n        A probability map of where the agent is likely to start within the environment.\n        Note: Zero within the source radius.\n    start_type : str\n        The type of the start probability map building. For instance: 'data_zone', 'odor_present', or 'custom' (if an array is provided).\n    odor_present_threshold : float\n        The threshold used to uild the start probabilities if the option 'odor_present' is used.\n    name : str\n        The name set to the agent as defined in the parameters.\n    saved_at : str\n        If the environment is saved, the path at which it is saved will be recorded here.\n    on_gpu : bool\n        Whether the environment's arrays are on the gpu's memory or not.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Environment\n        An instance of the environment on the CPU. If it already is, it returns itself.\n    gpu_version : Environment\n        An instance of the environment on the CPU. If it already is, it returns itself.\n    '''\n    def __init__(self,\n                 data_file: str | np.ndarray,\n                 data_source_position: list | np.ndarray,\n                 source_radius: float = 1.0,\n                 layers: bool | list[str] = False,\n                 shape: list | np.ndarray | None = None,\n                 margins: int | list | np.ndarray = 0,\n                 multiplier: list| np.ndarray = [1.0, 1.0],\n                 interpolation_method: Literal['Nearest', 'Linear', 'Cubic'] = 'Linear',\n                 preprocess_data: bool = False,\n                 boundary_condition: Literal['stop', 'wrap', 'wrap_vertical', 'wrap_horizontal', 'clip', 'no'] = 'stop',\n                 start_zone: Literal['odor_present', 'data_zone'] | np.ndarray = 'data_zone',\n                 odor_present_threshold: float | None = None,\n                 name: str | None = None,\n                 seed: int = 12131415,\n                 ) -&gt; None:\n        self.saved_at: str = None\n\n        # Layer properties\n        self.layers = None\n        self.layer_labels = None\n        self.has_layers = False\n\n        if isinstance(layers, list):\n            self.has_layers = True\n            self.layers = np.arange(len(layers))\n            self.layer_labels = [layer for layer in layers]\n        elif isinstance(layers, bool):\n            self.has_layers = layers\n\n        # Load from file if string provided\n        self.data_file_path = None\n        self._preprocess_data: bool = preprocess_data\n\n        loaded_data = None\n        if isinstance(data_file, str):\n            self.data_file_path = data_file\n\n            # NUMPY\n            if data_file.endswith('.npy'):\n                loaded_data = np.load(data_file)\n\n                # Layered data\n                if self.has_layers:\n                    if self.layers is None:\n                        self.layers = np.arange(len(loaded_data))\n                        self.layer_labels = [str(layer) for layer in range(len(loaded_data))]\n                    else:\n                        assert (len(self.layers) == len(loaded_data)), \"The amount of layers provided dont match the amount in the dataset.\"\n\n                        # Re-ordering the layers\n                        loaded_data = loaded_data[self.layers]\n\n            # H5\n            elif data_file.endswith('.h5'):\n                loaded_data = h5py.File(data_file,'r')\n\n                # Layered data\n                if self.has_layers:\n\n                    # Converting layers to strings\n                    data_layer_labels = list(loaded_data.keys())\n                    if self.layers is None:\n                        self.layers = np.arange(len(data_layer_labels))\n                        self.layer_labels = data_layer_labels\n\n                    # Getting the labels based on the list of integers provided\n                    elif all(isinstance(layer, int) for layer in layers):\n                        self.layer_labels = [data_layer_labels[layer_id] for layer_id in self.layers]\n\n                    # Loading the list of slices from the data\n                    loaded_data = [[loaded_data[layer][f\"{t}\"] for t in range(len(loaded_data[layer]))] for layer in self.layer_labels]\n\n                else:\n                    loaded_data = [loaded_data[f\"{t}\"] for t in range(len(loaded_data))]\n\n            # Not supported\n            else:\n                raise NotImplementedError('File format loading not implemented')\n\n        elif not isinstance(data_file, np.ndarray):\n            raise NotImplementedError(\"Data file should be either a path or an object that is either an h5 object or a numpy array\")\n\n        self._data: np.ndarray = loaded_data if loaded_data is not None else data_file\n\n        # Unmodified sizes\n        self.timesteps = len(self._data if not self.has_layers else self._data[0])\n        self.data_shape = (self._data[0] if not self.has_layers else self._data[0][0]).shape\n        self.dimensions = len(self.data_shape)\n        self.data_source_position = np.array(data_source_position)\n        self.original_data_source_position = self.data_source_position\n\n        original_data_shape = self.data_shape\n\n        # Making margins a |dims|x2 array\n        if isinstance(margins, int):\n            self.margins = np.ones((self.dimensions, 2), dtype=int) * margins\n        elif isinstance(margins, list) or isinstance(margins, np.ndarray):\n            margins = np.array(margins)\n            if margins.shape == (self.dimensions,): # Symmetric min and max margins\n                self.margins = np.hstack((margins[:,None], margins[:,None]))\n            elif margins.shape == (self.dimensions,2):\n                self.margins = margins\n            else:\n                raise ValueError('The array or lists of Margins provided have a shape not supported. (Supported formats (2,) or (2,2))')\n        else:\n            raise ValueError('margins argument should be either an integer or a 1D or 2D array with either shape (2) or (2,2)')\n        assert (self.margins.dtype == int), 'margins should be integers'\n\n        # Process shape parameter\n        new_data_shape = None\n        if shape is not None:\n            shape = np.array(shape)\n\n            assert np.all(shape &gt; np.sum(self.margins, axis=1)), \"The shape of the environment must be strictly larger than the sum of margins.\"\n\n            # Computing the new shape of the data\n            new_data_shape: np.ndarray = (shape - np.sum(self.margins, axis=1)).astype(int)\n\n            # New source position\n            self.data_source_position = (self.data_source_position * (new_data_shape / self.data_shape)).astype(int)\n        else:\n            shape = self.data_shape + np.sum(self.margins, axis=1)\n\n        if new_data_shape is not None:\n            self.data_shape = (*new_data_shape,)\n\n        # Process multiplier\n        multiplier = np.array(multiplier)\n\n        # Assert multiplier value is correct\n        with np.errstate(divide='ignore'):\n            low_max_mult = ((self.margins[:,0] / self.data_source_position) + 1)\n            high_max_mult = (1 + (self.margins[:,1] / (self.data_shape - self.data_source_position)))\n            max_mult = np.min(np.vstack([low_max_mult, high_max_mult]), axis=0)\n\n            assert np.all(multiplier &lt;= max_mult), f\"The multiplier given is larger than allowed (the values should be lower than {max_mult})\"\n\n        # Compute new data shape with the multiplier\n        if new_data_shape is None:\n            new_data_shape = self.data_shape\n        new_data_shape = (new_data_shape * multiplier).astype(int)\n\n        # New source position based on multiplier\n        new_source_position = (self.data_source_position * multiplier).astype(int)\n\n        # Recomputing margins with new source position\n        self.margins[:,0] -= (new_source_position - self.data_source_position)\n        self.margins[:,1] = (shape - (self.margins[:,0] + new_data_shape))\n\n        # Re-Setting new source position\n        self.data_source_position = new_source_position\n\n        # Interpolation method choice\n        self.interpolation_method = interpolation_method\n\n        # Input the new shape of the data if set by custom shape or multiplier\n        if new_data_shape is not None:\n            self.data_shape: tuple[int] = (*new_data_shape,)\n\n        # Check if data is already processed by default\n        self.data_processed = (self.data_shape == original_data_shape)\n\n        # If requested process all the slices of data into a single\n        if preprocess_data and not self.data_processed:\n            assert self.dimensions == 2, \"Higher dimensional data doesnt support reshaping yet, ensure it is done beforehand..\"\n            if self.has_layers:\n                new_data = np.zeros((len(self.layers), self.timesteps, *self.data_shape))\n                for layer in self.layers:\n                    for i in range(self.timesteps):\n                        new_data[layer, i] = _resize_array(np.array(self._data[layer][i]),\n                                                           new_shape=self.data_shape,\n                                                           interpolation=self.interpolation_method.lower())\n            else:\n                new_data = np.zeros((self.timesteps, *self.data_shape))\n                for i in range(self.timesteps):\n                    new_data[i] = _resize_array(np.array(self._data[i]),\n                                                new_shape=self.data_shape,\n                                                interpolation=self.interpolation_method.lower())\n            self._data = new_data\n            self.data_processed = True\n\n        # Reading shape of data array\n        self.shape = (*(self.data_shape + np.sum(self.margins, axis=1)),)\n\n        # Converting the shape tuple to integer sets\n        self.shape: tuple[int] = tuple([int(el) for el in self.shape])\n        self.data_shape: tuple[int] = tuple([int(el) for el in self.data_shape])\n\n        # Building a data bounds\n        self.data_bounds = np.array([self.margins[:,0], self.margins[:,0] + np.array(self.data_shape)]).T\n\n        # Saving arguments\n        self.source_position = self.data_source_position + self.margins[:,0]\n        self.source_radius = source_radius\n\n        # Boundary conditions\n        assert not ((self.dimensions &gt; 2) and (boundary_condition in ['wrap_vertical', 'wrap_horizontal'])), \"There are more than 2 dimensions, the options of 'wrap_horizontal' and 'wrap_vertical' are disabled.\"\n        self.boundary_condition = boundary_condition\n\n        # Starting zone\n        self.start_probabilities = np.zeros(self.shape)\n        self.start_type = start_zone if isinstance(start_zone, str) else 'custom'\n\n        if isinstance(start_zone, np.ndarray):\n            if start_zone.shape == (self.dimensions,2):\n                slices = tuple(slice(low, high) for low, high in start_zone)\n                self.start_probabilities[slices] = 1.0\n                self.start_type += '_' + '_'.join([str(el) for el in start_zone.ravel()])\n            elif start_zone.shape == self.shape:\n                self.start_probabilities = start_zone\n            else:\n                raise ValueError('If an np.ndarray is provided for the start_zone it has to be |dim| x 2...')\n\n        elif start_zone == 'data_zone':\n            slices = tuple(slice(low, high) for low, high in self.data_bounds)\n            self.start_probabilities[slices] = 1.0\n\n        elif start_zone == 'odor_present':\n            if self.data_processed and isinstance(self._data, np.ndarray):\n                odor_present_map = (np.mean((self._data &gt; (odor_present_threshold if odor_present_threshold is not None else 0)).astype(int), axis=0) &gt; 0).astype(float)\n                self.start_probabilities[tuple(slice(low, high) for low, high in self.data_bounds)] = odor_present_map\n            else:\n                odor_sum = np.zeros(self.data_shape, dtype=float)\n                for i in range(self.timesteps):\n                    data_slice = np.array(self._data[i]) if not self.has_layers else np.array(self._data[0][i])\n                    reshaped_data_slice = _resize_array(data_slice,\n                                                        new_shape=self.data_shape,\n                                                        interpolation=self.interpolation_method.lower())\n                    odor_sum += (reshaped_data_slice &gt; (odor_present_threshold if odor_present_threshold is not None else 0))\n                self.start_probabilities[tuple(slice(low, high) for low, high in self.data_bounds)] = (odor_sum / self.timesteps)\n        else:\n            raise ValueError('start_zone value is wrong')\n\n        # Odor present tresh\n        self.odor_present_threshold = odor_present_threshold\n\n        # Removing the source area from the starting zone\n        source_mask = np.fromfunction((lambda *points: np.sum((np.array(points).transpose([i+1 for i in range(len(self.shape))] + [0]) - self.source_position[None,:])**2, axis=-1) &lt;= self.source_radius**2), shape=self.shape)\n        self.start_probabilities[source_mask] = 0\n        self.start_probabilities /= np.sum(self.start_probabilities) # Normalization\n\n        # Name\n        self.name = name\n        if self.name is None:\n            self.name =  '_'.join([str(axis_size) for axis_size in self.shape]) # Size of env\n            self.name += f'-marg_' + '_'.join(['_'.join([str(marg) for marg in dim_margins]) for dim_margins in self.margins]) # margins\n            self.name += f'-edge_{self.boundary_condition}' # Boundary condition\n            self.name += f'-start_{self.start_type}' # Start zone\n            self.name += f'-source_' + '_'.join([str(pos) for pos in self.source_position]) + f'_radius{self.source_radius}' # Source\n\n        # gpu support\n        self._alternate_version = None\n        self.on_gpu = False\n\n        # random state\n        self.seed = seed\n        self.rnd_state = np.random.RandomState(seed = seed)\n\n\n    @property\n    def data(self) -&gt; np.ndarray:\n        '''\n        The whole dataset with the right shape. If not preprocessed to modify its shape the data will be processed when querrying this object.\n        '''\n        if not self._data_is_numpy or not self.data_processed:\n            xp = cp if self.on_gpu else np\n            print('[Warning] The whole dataset is being querried, it will be reshaped at this time. To avoid this, avoid querrying environment.data directly.')\n\n            # Reshaping\n            if self.has_layers:\n                new_data = np.zeros((len(self.layers), self.timesteps, *self.data_shape))\n                for layer in self.layers:\n                    for i in range(self.timesteps):\n                        new_data[layer, i] = _resize_array(np.array(self._data[layer][i]),\n                                                           new_shape=self.data_shape,\n                                                           interpolation=self.interpolation_method.lower())\n            else:\n                new_data = np.zeros((self.timesteps, *self.data_shape))\n                for i in range(self.timesteps):\n                    new_data[i] = _resize_array(np.array(self._data[i]),\n                                                new_shape=self.data_shape,\n                                                interpolation=self.interpolation_method.lower())\n\n            self._data = xp.array(new_data)\n            self.data_processed = True\n\n        return self._data\n\n\n    @property\n    def _data_is_numpy(self) -&gt; bool:\n        '''\n        Wheter the data is a numpy array or not.\n        '''\n        xp = cp if self.on_gpu else np\n        return isinstance(self._data, xp.ndarray)\n\n\n    def plot(self,\n             frame: int = 0,\n             layer: int = 0,\n             ax: plt.Axes | None = None\n             ) -&gt; None:\n        '''\n        Simple function to plot the environment with a single frame of odor cues.\n        The starting zone is also market down with a blue contour.\n        The source of the odor is marked by a red circle.\n\n        Parameters\n        ----------\n        frame : int, default=0\n            The frame of odor cues to print.\n        layer : int, default=0\n            The layer of the odor cues to print. (Ignored if the environment is not layered.)\n        ax : plt.Axes, optional\n            An ax on which the environment can be plot.\n        '''\n        # If on GPU use the CPU version to plot\n        if self.on_gpu:\n            self._alternate_version.plot(\n                frame=frame,\n                ax=ax\n            )\n            return # Blank return\n\n        # TODO: Implement plotting for 3D\n        assert self.dimensions == 2, \"Plotting function only available for 2D environments for now...\"\n\n        if ax is None:\n            _, ax = plt.subplots(1, figsize=(15,5))\n\n        legend_elements = [[],[]]\n\n        # Gather data frame\n        data_frame: np.ndarray = self._data[layer][frame] if self.has_layers else self._data[frame]\n        if not isinstance(data_frame, np.ndarray):\n            data_frame = np.array(data_frame)\n\n        if not self.data_processed:\n            data_frame = _resize_array(data_frame,\n                                       new_shape=self.data_shape,\n                                       interpolation=self.interpolation_method.lower())\n\n        # Odor grid\n        odor = Rectangle([0,0], 1, 1, color='black', fill=True)\n        frame_data = (data_frame &gt; (self.odor_present_threshold if self.odor_present_threshold is not None else 0)).astype(float)\n        environment_frame = np.zeros(self.shape, dtype=float)\n        environment_frame[self.data_bounds[0,0]:self.data_bounds[0,1], self.data_bounds[1,0]:self.data_bounds[1,1]] = frame_data\n        ax.imshow(environment_frame, cmap='Greys')\n\n        legend_elements[0].append(odor)\n        legend_elements[1].append(f'Frame {frame}' + ('' if not self.has_layers else f' (layer {layer})') + ' odor cues')\n\n        # Start zone contour\n        start_zone = Rectangle([0,0], 1, 1, color='blue', fill=False)\n        ax.contour(self.start_probabilities, levels=[0.0], colors='blue')\n\n        legend_elements[0].append(start_zone)\n        legend_elements[1].append('Start zone')\n\n        # Source circle\n        goal_circle = Circle(self.source_position[::-1], self.source_radius, color='r', fill=False, zorder=10)\n        legend_elements[0].append(goal_circle)\n        legend_elements[1].append('Source')\n\n        if self.source_radius &gt; 0.0:\n            ax.add_patch(goal_circle)\n        else:\n            ax.scatter(self.source_position[1], self.source_position[0], c='red')\n\n        # Legend\n        ax.legend(legend_elements[0], legend_elements[1])\n\n\n    def get_observation(self,\n                        pos: np.ndarray,\n                        time: int | np.ndarray = 0,\n                        layer: int | np.ndarray = 0\n                        ) -&gt; float | np.ndarray:\n        '''\n        Function to get an observation at a given position on the grid at a given time.\n        A set of observations can also be requested, either at a single position for multiple timestamps or with the same amoung of positions as timestamps provided.\n\n        Note: The position will not be checked against boundary conditions; if a position is out-of-bounds it will simply return 0.0!\n\n        Parameters\n        ----------\n        pos : np.ndarray\n            The position or list of positions to get observations at.\n        time : int or np.ndarray, default=0\n            A timestamp or list of timestamps to get the observations at.\n        layer : int or np.ndarray, default=0\n            A layer or list of timestamps to get the observations at.\n            Note: If the environment doesnt have layers, this parameter will be ignored.\n\n        Returns\n        -------\n        observation : float or np.ndarray\n            A single observation or list of observations.\n        '''\n        xp = cp if self.on_gpu else np\n\n        # Handling the case of a single point\n        is_single_point = (len(pos.shape) == 1)\n        if is_single_point:\n            pos = pos[None,:]\n\n        # Counting how many position points we are dealing with\n        pos_count = len(pos)\n\n        # Time looping\n        time = time % self.timesteps\n\n        # Determine unique layers and reindexing them if needed\n        unique_layers = xp.array([layer]) if isinstance(layer, int) else xp.unique(layer)\n        layer = 0 if isinstance(layer, int) else xp.where(layer == unique_layers[:,None])[0]\n        layer_count = len(unique_layers)\n\n        # Determine unique times and reindexing them if needed\n        unique_times = xp.array([time]) if isinstance(time, int) else xp.unique(time)\n        unique_time_indices = 0 if isinstance(time, int) else xp.where(time == unique_times[:,None])[0]\n        time_count = len(unique_times)\n\n        # Handling the case where the data is a sequence of slices (h5, so not numpy array)\n        data = self._data\n\n        # Selecting the required slices\n        if self._data_is_numpy:\n            data = data[unique_layers][:,unique_times] if self.has_layers else data[unique_times]\n        else:\n            # Case where we are dealing with a h5 file\n            # Note: Can't use self.data_shape because we don't know whether the data is processed yet or no\n            selected_slices = xp.zeros((layer_count, time_count, *self._data[0][0].shape)) if self.has_layers else xp.zeros((time_count, *self._data[0].shape))\n            for i, t in enumerate(unique_times):\n                if self.has_layers:\n                    for j, l in enumerate(unique_layers):\n                        selected_slices[j,i] = xp.array(data[int(l)][int(t)])\n                else:\n                    selected_slices[i] = xp.array(data[t])\n            data = xp.array(selected_slices)\n\n        # Handle the case it needs to be processed on the fly\n        if not self.data_processed:\n            reshaped_data = xp.zeros((layer_count, time_count, *self.data_shape)) if self.has_layers else xp.zeros((time_count, *self.data_shape))\n\n            for i in range(time_count):\n                if self.has_layers:\n                    for j in range(layer_count):\n                        reshaped_data[j,i] = _resize_array(data[j,i],\n                                                           new_shape=self.data_shape,\n                                                           interpolation=self.interpolation_method.lower())\n                else:\n                    reshaped_data[i] = _resize_array(data[i],\n                                                     new_shape=self.data_shape,\n                                                     interpolation=self.interpolation_method.lower())\n\n            data = xp.array(reshaped_data)\n\n        # Return 0.0 if outside of data zone\n        data_pos = pos - self.margins[:,0][None,:]\n        data_pos_valid = xp.all((data_pos &gt;= 0) &amp; (data_pos &lt; xp.array(self.data_shape)), axis=1)\n        observation = xp.zeros(pos_count, dtype=float)\n\n        # Gathering data on layered data on not\n        if self.has_layers:\n            observation[data_pos_valid] = data[(layer if isinstance(layer, int) else layer[data_pos_valid]), # layer\n                                               (unique_time_indices if isinstance(unique_time_indices, int) else unique_time_indices[data_pos_valid]), # t\n                                               *data_pos[data_pos_valid,:].T] # physical position\n        else:\n            observation[data_pos_valid] = data[(unique_time_indices if isinstance(unique_time_indices, int) else unique_time_indices[data_pos_valid]), # t\n                                               *data_pos[data_pos_valid,:].T] # physical position\n\n        return float(observation[0]) if is_single_point else observation\n\n\n    def source_reached(self,\n                       pos: np.ndarray\n                       ) -&gt; bool | np.ndarray:\n        '''\n        Checks whether a given position is within the source radius.\n\n        Parameters\n        ----------\n        pos : np.ndarray\n            The position to check whether in the radius of the source.\n\n        Returns\n        -------\n        is_at_source : bool\n            Whether or not the position is within the radius of the source.\n        '''\n        xp = cp if self.on_gpu else np\n\n        # Handling the case of a single point\n        is_single_point = (len(pos.shape) == 1)\n        if is_single_point:\n            pos = pos[None,:]\n\n        is_at_source: np.ndarray = (xp.sum((pos - self.source_position[None,:]) ** 2, axis=-1) &lt;= (self.source_radius ** 2))\n\n        return bool(is_at_source[0]) if is_single_point else is_at_source\n\n\n    def random_start_points(self,\n                            n: int = 1\n                            ) -&gt; np.ndarray:\n        '''\n        Function to generate n starting positions following the starting probabilities.\n\n        Parameters\n        ----------\n        n : int, default=1\n            How many random starting positions to generate\n\n        Returns\n        -------\n        random_states_2d : np.ndarray\n            The n random 2d points in a n x 2 array.\n        '''\n        xp = cp if self.on_gpu else np\n\n        assert (n &gt; 0), \"n has to be a strictly positive number (&gt;0)\"\n\n        random_states = self.rnd_state.choice(xp.arange(int(np.prod(self.shape))), size=n, replace=True, p=self.start_probabilities.ravel())\n        random_states_2d = xp.array(xp.unravel_index(random_states, self.shape)).T\n        return random_states_2d\n\n\n    def move(self,\n             pos: np.ndarray,\n             movement: np.ndarray\n             ) -&gt; np.ndarray:\n        '''\n        Applies a movement vector to a position point and returns a new position point while respecting the boundary conditions.\n\n        Parameters\n        ----------\n        pos : np.ndarray\n            The start position of the movement.\n        movement : np.ndarray\n            A 2D movement vector.\n\n        Returns\n        -------\n        new_pos : np.ndarray\n            The new position after applying the movement.\n        '''\n        xp = cp if self.on_gpu else np\n\n        # Applying the movement vector\n        new_pos = pos + movement\n\n        # Handling the case we are dealing with a single point.\n        is_single_point = (len(pos.shape) == 1)\n        if is_single_point:\n            new_pos = new_pos[None,:]\n\n        shape_array = xp.array(self.shape)[None,:]\n\n        # Wrap boundary\n        if self.boundary_condition == 'wrap':\n            new_pos = xp.where(new_pos &lt; 0, (new_pos + shape_array), new_pos)\n            new_pos = xp.where(new_pos &gt;= shape_array, (new_pos - shape_array), new_pos)\n\n        # Stop boundary\n        elif self.boundary_condition == 'stop':\n            new_pos = xp.clip(new_pos, 0, (shape_array-1))\n\n        # Special wrap - vertical only\n        elif (self.dimensions == 2) and (self.boundary_condition == 'wrap_vertical'):\n            height, width = self.shape\n\n            new_pos[new_pos[:,0] &lt; 0, 0] += height\n            new_pos[new_pos[:,0] &gt;= height, 0] -= height\n\n            new_pos[:,1] = xp.clip(new_pos[:,1], 0, (width-1))\n\n        # Special wrap - horizontal only\n        elif (self.dimensions == 2) and (self.boundary_condition == 'wrap_horizontal'):\n            height, width = self.shape\n\n            new_pos[new_pos[:,1] &lt; 0, 1] += width\n            new_pos[new_pos[:,1] &gt;= width, 1] -= width\n\n            new_pos[:,0] = xp.clip(new_pos[:,0], 0, (height-1))\n\n        return new_pos[0] if is_single_point else new_pos\n\n\n    def distance_to_source(self,\n                           point: np.ndarray,\n                           metric: Literal['manhattan'] = 'manhattan'\n                           ) -&gt; float | np.ndarray:\n        '''\n        Function to compute the distance(s) between given points and the source point.\n\n        Parameters\n        ----------\n        point : np.ndarray\n            A single or an Nx2 array containing N points.\n        metric : 'manhattan'\n            The metric to use to compute the distance.\n\n        Returns\n        -------\n        dist : float or np.ndarray\n            A single distance or a list of distance in a 1D distance array.\n        '''\n        xp = cp if self.on_gpu else np\n\n        # Handling the case we have a single point\n        is_single_point = (len(point.shape) == 1)\n        if is_single_point:\n            point = point[None,:]\n\n        # Computing dist\n        dist = None\n        if metric == 'manhattan':\n            dist = xp.sum(xp.abs(self.source_position[None,:] - point), axis=-1) - self.source_radius\n\n        if dist is None: # Meaning it was not computed\n            raise NotImplementedError('This distance metric has not yet been implemented')\n\n        return float(dist[0]) if is_single_point else dist\n\n\n    def save(self,\n             folder: str | None = None,\n             save_arrays: bool = False,\n             force: bool = False\n             ) -&gt; None:\n        '''\n        Function to save the environment to the memory.\n\n        By default it saved in a new folder at the current path in a new folder with the name 'Env-&lt;name&gt;' where &lt;name&gt; is the name set when initializing an environment.\n        In this folder a file \"METADATA.json\" is created containing all the properties of the environment.\n\n        The numpy arrays of the environment (grid and start_probabilities) can be saved or not. If not, when the environment is loaded it needs to be reconstructed from the original data file.\n        The arrays are saved to .npy files along with the METADATA file.\n\n        If an environment of the same name is already saved, the saving will be interupted. It can however be forced with the force parameter.\n\n        Parameters\n        ----------\n        folder : str, optional\n            The folder to which to save the environment data. If it is not provided, it will be created in the current folder.\n        save_arrays : bool, default=False\n            Whether or not to save the numpy arrays to memory. (The arrays can be heavy)\n        force : bool, default=False\n            In case an environment of the same name is already saved, it will be overwritten.\n        '''\n        # If on gpu, use the cpu version to save\n        if self.on_gpu:\n            self._alternate_version.save(\n                folder=folder,\n                save_arrays=save_arrays,\n                force=force\n            )\n            return # Blank return\n\n        # Assert either data_file is provided or save_arrays is enabled\n        assert save_arrays or ((self.data_file_path is not None) and (self.start_type is not None)), \"The environment was not created from a data file so 'save_arrays' has to be set to True.\"\n\n        # Adding env name to folder path\n        if folder is None:\n            folder = f'./Env-{self.name}'\n        else:\n            folder += '/Env-' + self.name\n\n        # Checking the folder exists or creates it\n        if not os.path.exists(folder):\n            os.mkdir(folder)\n        elif len(os.listdir(folder)) &gt; 0:\n            if force:\n                shutil.rmtree(folder)\n                os.mkdir(folder)\n            else:\n                raise Exception(f'{folder} is not empty. If you want to overwrite the saved model, enable \"force\".')\n\n        # Generating the metadata arguments dictionary\n        arguments = {}\n        arguments['name'] = self.name\n\n        if self.data_file_path is not None:\n            arguments['data_file_path'] = self.data_file_path\n\n        arguments['timesteps']                     = int(self.timesteps)\n        arguments['data_shape']                    = self.data_shape\n        arguments['dimensions']                    = self.dimensions\n        arguments['margins']                       = self.margins.tolist()\n        arguments['shape']                         = self.shape\n        arguments['data_bounds']                   = self.data_bounds.tolist()\n        arguments['original_data_source_position'] = self.original_data_source_position.tolist()\n        arguments['data_source_position']          = self.data_source_position.tolist()\n        arguments['layers']                        = (self.layer_labels if self.has_layers else False)\n        arguments['source_position']               = self.source_position.tolist()\n        arguments['source_radius']                 = self.source_radius\n        arguments['interpolation_method']          = self.interpolation_method\n        arguments['preprocess_data']               = self._preprocess_data\n        arguments['data_processed']                = self.data_processed\n        arguments['boundary_condition']            = self.boundary_condition\n        arguments['start_type']                    = self.start_type\n        arguments['seed']                          = self.seed\n\n        # Check how the start probabilities were built\n        if self.start_type.startswith('custom') and len(self.start_type.split('_')) == 1 and not save_arrays:\n            raise Exception('Start probabilities have been set from a custom array, please enable save_arrays to be able to reconstruct the environment later.')\n\n        if self.odor_present_threshold is not None:\n            arguments['odor_present_threshold'] = self.odor_present_threshold\n\n        # Output the arguments to a METADATA file\n        with open(folder + '/METADATA.json', 'w') as json_file:\n            json.dump(arguments, json_file, indent=4)\n\n        # Output the numpy arrays\n        if save_arrays:\n            if isinstance(self._data, np.ndarray):\n                np.save(folder + '/data.npy', self._data)\n            else:\n                raise NotImplementedError('The saving of data that is not a Numpy array was not implemented yet.')\n            np.save(folder + '/start_probabilities.npy', self.start_probabilities)\n\n        # Success print\n        self.saved_at = os.path.abspath(folder).replace('\\\\', '/')\n        print(f'Environment saved to: {folder}')\n\n\n    @classmethod\n    def load(cls,\n             folder: str\n             ) -&gt; 'Environment':\n        '''\n        Function to load an environment from a given folder.\n\n        Parameters\n        ----------\n        folder : str\n            The folder of the Environment.\n\n        Returns\n        -------\n        loaded_env : Environment\n            The loaded environment.\n        '''\n        assert os.path.exists(folder), \"Folder doesn't exist...\"\n        assert folder.split('/')[-1].startswith('Env-'), \"The folder provided is not the data of en Environment object.\"\n\n        # Load arguments\n        arguments: dict = None\n        with open(folder + '/METADATA.json', 'r') as json_file:\n            arguments = json.load(json_file)\n\n        # Check if numpy arrays are provided, if not, recreate a new environment model\n        if os.path.exists(folder + '/data.npy') and os.path.exists(folder + '/start_probabilities.npy'):\n            data = np.load(folder + '/data.npy')\n            start_probabilities = np.load(folder + '/start_probabilities.npy')\n\n            loaded_env = cls.__new__(cls)\n\n            # Set the arguments\n            loaded_env.name                          = arguments['name']\n            loaded_env.timesteps                     = arguments['timesteps']\n            loaded_env.data_shape                    = arguments['data_shape']\n            loaded_env.dimensions                    = arguments['dimensions']\n            loaded_env.margins                       = np.array(arguments['margins'])\n            loaded_env.shape                         = arguments['shape']\n            loaded_env.data_bounds                   = np.array(arguments['data_bounds'])\n            loaded_env.original_data_source_position = np.array(arguments['original_data_source_position'])\n            loaded_env.data_source_position          = np.array(arguments['data_source_position'])\n            loaded_env.source_position               = np.array(arguments['source_position'])\n            loaded_env.source_radius                 = arguments['source_radius']\n            loaded_env.has_layers                    = isinstance(arguments['layers'], list)\n            loaded_env.layers                        = np.arange(len(arguments['layers'])) if loaded_env.has_layers else None\n            loaded_env.layer_labels                  = arguments['layers']\n            loaded_env.interpolation_method          = arguments['interpolation_method']\n            loaded_env._preprocess_data              = arguments['preprocess_data']\n            loaded_env.data_processed                = arguments['data_processed']\n            loaded_env.boundary_condition            = arguments['boundary_condition']\n            loaded_env.on_gpu                        = False\n            loaded_env.seed                          = arguments['seed']\n            loaded_env.rnd_state                     = np.random.RandomState(arguments['seed'])\n\n            # Optional arguments\n            loaded_env.data_file_path                = arguments.get('data_file_path')\n            loaded_env.odor_present_threshold        = arguments.get('odor_present_threshold')\n            loaded_env.start_type                    = arguments.get('start_type')\n\n            # Arrays\n            loaded_env._data = data\n            loaded_env.start_probabilities = start_probabilities\n\n        else:\n            start_zone: str = arguments['start_type']\n            start_zone_boundaries = None\n            if start_zone.startswith('custom'):\n                start_zone_boundaries = np.array(start_zone.split('_')[1:]).reshape((arguments['dimensions'],2)).astype(int)\n\n            loaded_env = Environment(\n                data_file              = arguments['data_file_path'],\n                data_source_position   = arguments['original_data_source_position'],\n                source_radius          = arguments['source_radius'],\n                layers                 = arguments['layers'],\n                shape                  = arguments['shape'],\n                margins                = arguments['margins'],\n                interpolation_method   = arguments['interpolation_method'],\n                preprocess_data        = arguments['preprocess_data'],\n                boundary_condition     = arguments['boundary_condition'],\n                start_zone             = (start_zone_boundaries if start_zone_boundaries is not None else start_zone),\n                odor_present_threshold = arguments.get('odor_present_threshold'),\n                name                   = arguments['name'],\n                seed                   = arguments['seed']\n            )\n\n        # Folder where the environment was pulled from\n        loaded_env.saved_at = os.path.abspath(folder)\n\n        return loaded_env\n\n\n    def to_gpu(self) -&gt; 'Environment':\n        '''\n        Function to send the numpy arrays of the environment to the gpu memory.\n        It returns a new instance of the Environment with the arrays as cupy arrays.\n\n        Returns\n        -------\n        gpu_environment : Environment\n            A new environment instance where the arrays are on the gpu memory.\n        '''\n        # Check whether the environment is already on the gpu or not\n        if self.on_gpu:\n            return self\n\n        # Warn and overwrite alternate_version in case it already exists\n        if self._alternate_version is not None:\n            print('[warning] A GPU instance already existed and is being recreated.')\n            self._alternate_version = None\n\n        assert gpu_support, \"GPU support is not enabled...\"\n\n        # Generating a new instance\n        cls = self.__class__\n        gpu_environment = cls.__new__(cls)\n\n        # Copying arguments to gpu\n        for arg, val in self.__dict__.items():\n            if isinstance(val, np.ndarray):\n                setattr(gpu_environment, arg, cp.array(val))\n            elif arg == 'rnd_state':\n                setattr(gpu_environment, arg, cp.random.RandomState(self.seed))\n            else:\n                setattr(gpu_environment, arg, val)\n\n        # Self reference instances\n        self._alternate_version = gpu_environment\n        gpu_environment._alternate_version = self\n\n        gpu_environment.on_gpu = True\n        return gpu_environment\n\n\n    def to_cpu(self) -&gt; 'Environment':\n        '''\n        Function to send the numpy arrays of the environment to the cpu memory.\n        It returns a new instance of the Environment with the arrays as numpy arrays.\n\n        Returns\n        -------\n        cpu_environment : Environment\n            A new environment instance where the arrays are on the cpu memory.\n        '''\n        # Check whether the agent is already on the cpu or not\n        if not self.on_gpu:\n            return self\n\n        if self._alternate_version is not None:\n            print('[warning] A CPU instance already existed and is being recreated.')\n            self._alternate_version = None\n\n        # Generating a new instance\n        cls = self.__class__\n        cpu_environment = cls.__new__(cls)\n\n        # Copying arguments to gpu\n        for arg, val in self.__dict__.items():\n            if isinstance(val, cp.ndarray):\n                setattr(cpu_environment, arg, cp.asnumpy(val))\n            elif arg == 'rnd_state':\n                setattr(cpu_environment, arg, np.random.RandomState(self.seed))\n            else:\n                setattr(cpu_environment, arg, val)\n\n        # Self reference instances\n        self._alternate_version = cpu_environment\n        cpu_environment._alternate_version = self\n\n        cpu_environment.on_gpu = True\n        return cpu_environment\n\n\n    @property\n    def gpu_version(self) -&gt; 'Environment':\n        '''\n        A version of the Environment on the GPU.\n        If the environment is already on the GPU it returns itself, otherwise the to_gpu function is called to generate a new one.\n        '''\n        if self.on_gpu:\n            return self\n        else:\n            if self._alternate_version is not None: # Check if an alternate version already exists\n                return self._alternate_version\n            else: # Generate an alternate version on the gpu\n                return self.to_gpu()\n\n\n    @property\n    def cpu_version(self) -&gt; 'Environment':\n        '''\n        A version of the Environment on the CPU.\n        If the environment is already on the CPU it returns itself, otherwise the to_cpu function is called to generate a new one.\n        '''\n        if not self.on_gpu:\n            return self\n        else:\n            if self._alternate_version is not None: # Check if an alternate version already exists\n                return self._alternate_version\n            else: # Generate an alternate version on the cpu\n                return self.to_cpu()\n\n\n    def modify(self,\n               data_source_position: list | np.ndarray | None = None,\n               source_radius: float | None = None,\n               shape: list | np.ndarray | None = None,\n               margins: int | list | np.ndarray | None = None,\n               multiplier: list | np.ndarray | None = None,\n               interpolation_method: str | None = None,\n               boundary_condition: str | None = None\n               ) -&gt; 'Environment':\n        '''\n        Returns a copy of the environment with one or more parameters modified.\n\n        Parameters\n        ----------\n        data_source_position: list or np.ndarray, optional\n            A new position for the source relative to the data file.\n        source_radius: float, optional\n            A new source radius.\n        shape: list or np.ndarray, optional\n            A new shape of environment.\n        margins: int or list or np.ndarray, optional\n            A new set of margins.\n        multiplier: list or np.ndarray, optional\n            A new multiplier to be applied to the data file (this will in turn increase or reduce the margins).\n        interpolation_method: str, optional\n            A new interpolation method to be used.\n        boundary_condition: str, optional\n            New boundary conditions for how the agent should behave at the edges.\n\n        Returns\n        -------\n        modified_environment\n            A copy of the environment where the modified parameters have been applied.\n        '''\n        if self.on_gpu:\n            cpu_environment = self.cpu_version\n            new_cpu_environment = cpu_environment.modify(\n                data_source_position = data_source_position,\n                source_radius        = source_radius,\n                shape                = shape,\n                margins              = margins,\n                multiplier           = multiplier,\n                interpolation_method = interpolation_method,\n                boundary_condition   = boundary_condition\n            )\n            return new_cpu_environment.to_gpu()\n\n        modified_environment = Environment(\n            data_file              = (self.data_file_path if (self.data_file_path is not None) else self._data),\n            data_source_position   = (data_source_position if (data_source_position is not None) else self.original_data_source_position),\n            source_radius          = (source_radius if (source_radius is not None) else self.source_radius),\n            layers                 = (self.layer_labels if self.has_layers else False),\n            shape                  = (shape if (shape is not None) else self.shape),\n            margins                = (margins if (margins is not None) else self.margins),\n            multiplier             = (multiplier if (multiplier is not None) else [1.0,1.0]),\n            interpolation_method   = (interpolation_method if (interpolation_method is not None) else self.interpolation_method),\n            preprocess_data        = self._preprocess_data,\n            boundary_condition     = (boundary_condition if (boundary_condition is not None) else self.boundary_condition),\n            start_zone             = self.start_type,\n            odor_present_threshold = self.odor_present_threshold,\n            name                   = self.name,\n            seed                   = self.seed\n        )\n        return modified_environment\n\n\n    def modify_scale(self,\n                     scale_factor: float\n                     ) -&gt; 'Environment':\n        '''\n        Function to modify the size of the environment by a scale factor.\n        Everything will be scaled this factor. This includes: shape, margins, source radius, and data shape.\n\n        Parameters\n        ----------\n        scale_factor : float\n            By how much to modify the size of the current environment.\n\n        Returns\n        -------\n        modified_environment : Environment\n            The environment with the scale factor applied.\n        '''\n        modified_source_radius = self.source_radius * scale_factor\n        modified_shape = (np.array(self.shape) * scale_factor).astype(int)\n        modified_margins = (self.margins * scale_factor).astype(int)\n\n        modified_environment = Environment(\n            data_file              = (self.data_file_path if (self.data_file_path is not None) else self._data),\n            data_source_position   = self.original_data_source_position,\n            source_radius          = modified_source_radius,\n            layers                 = (self.layer_labels if self.has_layers else False),\n            shape                  = modified_shape,\n            margins                = modified_margins,\n            multiplier             = [1.0,1.0],\n            interpolation_method   = self.interpolation_method,\n            preprocess_data        = self._preprocess_data,\n            boundary_condition     = self.boundary_condition,\n            start_zone             = self.start_type,\n            odor_present_threshold = self.odor_present_threshold,\n            name                   = self.name,\n            seed                   = self.seed\n        )\n        return modified_environment\n</code></pre>"},{"location":"reference/environment/#olfactory_navigation.environment.Environment.cpu_version","title":"<code>cpu_version</code>  <code>property</code>","text":"<p>A version of the Environment on the CPU. If the environment is already on the CPU it returns itself, otherwise the to_cpu function is called to generate a new one.</p>"},{"location":"reference/environment/#olfactory_navigation.environment.Environment.data","title":"<code>data</code>  <code>property</code>","text":"<p>The whole dataset with the right shape. If not preprocessed to modify its shape the data will be processed when querrying this object.</p>"},{"location":"reference/environment/#olfactory_navigation.environment.Environment.gpu_version","title":"<code>gpu_version</code>  <code>property</code>","text":"<p>A version of the Environment on the GPU. If the environment is already on the GPU it returns itself, otherwise the to_gpu function is called to generate a new one.</p>"},{"location":"reference/environment/#olfactory_navigation.environment.Environment.distance_to_source","title":"<code>distance_to_source(point, metric='manhattan')</code>","text":"<p>Function to compute the distance(s) between given points and the source point.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>ndarray</code> <p>A single or an Nx2 array containing N points.</p> required <code>metric</code> <code>manhattan</code> <p>The metric to use to compute the distance.</p> <code>'manhattan'</code> <p>Returns:</p> Name Type Description <code>dist</code> <code>float or ndarray</code> <p>A single distance or a list of distance in a 1D distance array.</p> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>def distance_to_source(self,\n                       point: np.ndarray,\n                       metric: Literal['manhattan'] = 'manhattan'\n                       ) -&gt; float | np.ndarray:\n    '''\n    Function to compute the distance(s) between given points and the source point.\n\n    Parameters\n    ----------\n    point : np.ndarray\n        A single or an Nx2 array containing N points.\n    metric : 'manhattan'\n        The metric to use to compute the distance.\n\n    Returns\n    -------\n    dist : float or np.ndarray\n        A single distance or a list of distance in a 1D distance array.\n    '''\n    xp = cp if self.on_gpu else np\n\n    # Handling the case we have a single point\n    is_single_point = (len(point.shape) == 1)\n    if is_single_point:\n        point = point[None,:]\n\n    # Computing dist\n    dist = None\n    if metric == 'manhattan':\n        dist = xp.sum(xp.abs(self.source_position[None,:] - point), axis=-1) - self.source_radius\n\n    if dist is None: # Meaning it was not computed\n        raise NotImplementedError('This distance metric has not yet been implemented')\n\n    return float(dist[0]) if is_single_point else dist\n</code></pre>"},{"location":"reference/environment/#olfactory_navigation.environment.Environment.get_observation","title":"<code>get_observation(pos, time=0, layer=0)</code>","text":"<p>Function to get an observation at a given position on the grid at a given time. A set of observations can also be requested, either at a single position for multiple timestamps or with the same amoung of positions as timestamps provided.</p> <p>Note: The position will not be checked against boundary conditions; if a position is out-of-bounds it will simply return 0.0!</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>ndarray</code> <p>The position or list of positions to get observations at.</p> required <code>time</code> <code>int or ndarray</code> <p>A timestamp or list of timestamps to get the observations at.</p> <code>0</code> <code>layer</code> <code>int or ndarray</code> <p>A layer or list of timestamps to get the observations at. Note: If the environment doesnt have layers, this parameter will be ignored.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>observation</code> <code>float or ndarray</code> <p>A single observation or list of observations.</p> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>def get_observation(self,\n                    pos: np.ndarray,\n                    time: int | np.ndarray = 0,\n                    layer: int | np.ndarray = 0\n                    ) -&gt; float | np.ndarray:\n    '''\n    Function to get an observation at a given position on the grid at a given time.\n    A set of observations can also be requested, either at a single position for multiple timestamps or with the same amoung of positions as timestamps provided.\n\n    Note: The position will not be checked against boundary conditions; if a position is out-of-bounds it will simply return 0.0!\n\n    Parameters\n    ----------\n    pos : np.ndarray\n        The position or list of positions to get observations at.\n    time : int or np.ndarray, default=0\n        A timestamp or list of timestamps to get the observations at.\n    layer : int or np.ndarray, default=0\n        A layer or list of timestamps to get the observations at.\n        Note: If the environment doesnt have layers, this parameter will be ignored.\n\n    Returns\n    -------\n    observation : float or np.ndarray\n        A single observation or list of observations.\n    '''\n    xp = cp if self.on_gpu else np\n\n    # Handling the case of a single point\n    is_single_point = (len(pos.shape) == 1)\n    if is_single_point:\n        pos = pos[None,:]\n\n    # Counting how many position points we are dealing with\n    pos_count = len(pos)\n\n    # Time looping\n    time = time % self.timesteps\n\n    # Determine unique layers and reindexing them if needed\n    unique_layers = xp.array([layer]) if isinstance(layer, int) else xp.unique(layer)\n    layer = 0 if isinstance(layer, int) else xp.where(layer == unique_layers[:,None])[0]\n    layer_count = len(unique_layers)\n\n    # Determine unique times and reindexing them if needed\n    unique_times = xp.array([time]) if isinstance(time, int) else xp.unique(time)\n    unique_time_indices = 0 if isinstance(time, int) else xp.where(time == unique_times[:,None])[0]\n    time_count = len(unique_times)\n\n    # Handling the case where the data is a sequence of slices (h5, so not numpy array)\n    data = self._data\n\n    # Selecting the required slices\n    if self._data_is_numpy:\n        data = data[unique_layers][:,unique_times] if self.has_layers else data[unique_times]\n    else:\n        # Case where we are dealing with a h5 file\n        # Note: Can't use self.data_shape because we don't know whether the data is processed yet or no\n        selected_slices = xp.zeros((layer_count, time_count, *self._data[0][0].shape)) if self.has_layers else xp.zeros((time_count, *self._data[0].shape))\n        for i, t in enumerate(unique_times):\n            if self.has_layers:\n                for j, l in enumerate(unique_layers):\n                    selected_slices[j,i] = xp.array(data[int(l)][int(t)])\n            else:\n                selected_slices[i] = xp.array(data[t])\n        data = xp.array(selected_slices)\n\n    # Handle the case it needs to be processed on the fly\n    if not self.data_processed:\n        reshaped_data = xp.zeros((layer_count, time_count, *self.data_shape)) if self.has_layers else xp.zeros((time_count, *self.data_shape))\n\n        for i in range(time_count):\n            if self.has_layers:\n                for j in range(layer_count):\n                    reshaped_data[j,i] = _resize_array(data[j,i],\n                                                       new_shape=self.data_shape,\n                                                       interpolation=self.interpolation_method.lower())\n            else:\n                reshaped_data[i] = _resize_array(data[i],\n                                                 new_shape=self.data_shape,\n                                                 interpolation=self.interpolation_method.lower())\n\n        data = xp.array(reshaped_data)\n\n    # Return 0.0 if outside of data zone\n    data_pos = pos - self.margins[:,0][None,:]\n    data_pos_valid = xp.all((data_pos &gt;= 0) &amp; (data_pos &lt; xp.array(self.data_shape)), axis=1)\n    observation = xp.zeros(pos_count, dtype=float)\n\n    # Gathering data on layered data on not\n    if self.has_layers:\n        observation[data_pos_valid] = data[(layer if isinstance(layer, int) else layer[data_pos_valid]), # layer\n                                           (unique_time_indices if isinstance(unique_time_indices, int) else unique_time_indices[data_pos_valid]), # t\n                                           *data_pos[data_pos_valid,:].T] # physical position\n    else:\n        observation[data_pos_valid] = data[(unique_time_indices if isinstance(unique_time_indices, int) else unique_time_indices[data_pos_valid]), # t\n                                           *data_pos[data_pos_valid,:].T] # physical position\n\n    return float(observation[0]) if is_single_point else observation\n</code></pre>"},{"location":"reference/environment/#olfactory_navigation.environment.Environment.load","title":"<code>load(folder)</code>  <code>classmethod</code>","text":"<p>Function to load an environment from a given folder.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>The folder of the Environment.</p> required <p>Returns:</p> Name Type Description <code>loaded_env</code> <code>Environment</code> <p>The loaded environment.</p> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>@classmethod\ndef load(cls,\n         folder: str\n         ) -&gt; 'Environment':\n    '''\n    Function to load an environment from a given folder.\n\n    Parameters\n    ----------\n    folder : str\n        The folder of the Environment.\n\n    Returns\n    -------\n    loaded_env : Environment\n        The loaded environment.\n    '''\n    assert os.path.exists(folder), \"Folder doesn't exist...\"\n    assert folder.split('/')[-1].startswith('Env-'), \"The folder provided is not the data of en Environment object.\"\n\n    # Load arguments\n    arguments: dict = None\n    with open(folder + '/METADATA.json', 'r') as json_file:\n        arguments = json.load(json_file)\n\n    # Check if numpy arrays are provided, if not, recreate a new environment model\n    if os.path.exists(folder + '/data.npy') and os.path.exists(folder + '/start_probabilities.npy'):\n        data = np.load(folder + '/data.npy')\n        start_probabilities = np.load(folder + '/start_probabilities.npy')\n\n        loaded_env = cls.__new__(cls)\n\n        # Set the arguments\n        loaded_env.name                          = arguments['name']\n        loaded_env.timesteps                     = arguments['timesteps']\n        loaded_env.data_shape                    = arguments['data_shape']\n        loaded_env.dimensions                    = arguments['dimensions']\n        loaded_env.margins                       = np.array(arguments['margins'])\n        loaded_env.shape                         = arguments['shape']\n        loaded_env.data_bounds                   = np.array(arguments['data_bounds'])\n        loaded_env.original_data_source_position = np.array(arguments['original_data_source_position'])\n        loaded_env.data_source_position          = np.array(arguments['data_source_position'])\n        loaded_env.source_position               = np.array(arguments['source_position'])\n        loaded_env.source_radius                 = arguments['source_radius']\n        loaded_env.has_layers                    = isinstance(arguments['layers'], list)\n        loaded_env.layers                        = np.arange(len(arguments['layers'])) if loaded_env.has_layers else None\n        loaded_env.layer_labels                  = arguments['layers']\n        loaded_env.interpolation_method          = arguments['interpolation_method']\n        loaded_env._preprocess_data              = arguments['preprocess_data']\n        loaded_env.data_processed                = arguments['data_processed']\n        loaded_env.boundary_condition            = arguments['boundary_condition']\n        loaded_env.on_gpu                        = False\n        loaded_env.seed                          = arguments['seed']\n        loaded_env.rnd_state                     = np.random.RandomState(arguments['seed'])\n\n        # Optional arguments\n        loaded_env.data_file_path                = arguments.get('data_file_path')\n        loaded_env.odor_present_threshold        = arguments.get('odor_present_threshold')\n        loaded_env.start_type                    = arguments.get('start_type')\n\n        # Arrays\n        loaded_env._data = data\n        loaded_env.start_probabilities = start_probabilities\n\n    else:\n        start_zone: str = arguments['start_type']\n        start_zone_boundaries = None\n        if start_zone.startswith('custom'):\n            start_zone_boundaries = np.array(start_zone.split('_')[1:]).reshape((arguments['dimensions'],2)).astype(int)\n\n        loaded_env = Environment(\n            data_file              = arguments['data_file_path'],\n            data_source_position   = arguments['original_data_source_position'],\n            source_radius          = arguments['source_radius'],\n            layers                 = arguments['layers'],\n            shape                  = arguments['shape'],\n            margins                = arguments['margins'],\n            interpolation_method   = arguments['interpolation_method'],\n            preprocess_data        = arguments['preprocess_data'],\n            boundary_condition     = arguments['boundary_condition'],\n            start_zone             = (start_zone_boundaries if start_zone_boundaries is not None else start_zone),\n            odor_present_threshold = arguments.get('odor_present_threshold'),\n            name                   = arguments['name'],\n            seed                   = arguments['seed']\n        )\n\n    # Folder where the environment was pulled from\n    loaded_env.saved_at = os.path.abspath(folder)\n\n    return loaded_env\n</code></pre>"},{"location":"reference/environment/#olfactory_navigation.environment.Environment.modify","title":"<code>modify(data_source_position=None, source_radius=None, shape=None, margins=None, multiplier=None, interpolation_method=None, boundary_condition=None)</code>","text":"<p>Returns a copy of the environment with one or more parameters modified.</p> <p>Parameters:</p> Name Type Description Default <code>data_source_position</code> <code>list | ndarray | None</code> <p>A new position for the source relative to the data file.</p> <code>None</code> <code>source_radius</code> <code>float | None</code> <p>A new source radius.</p> <code>None</code> <code>shape</code> <code>list | ndarray | None</code> <p>A new shape of environment.</p> <code>None</code> <code>margins</code> <code>int | list | ndarray | None</code> <p>A new set of margins.</p> <code>None</code> <code>multiplier</code> <code>list | ndarray | None</code> <p>A new multiplier to be applied to the data file (this will in turn increase or reduce the margins).</p> <code>None</code> <code>interpolation_method</code> <code>str | None</code> <p>A new interpolation method to be used.</p> <code>None</code> <code>boundary_condition</code> <code>str | None</code> <p>New boundary conditions for how the agent should behave at the edges.</p> <code>None</code> <p>Returns:</p> Type Description <code>modified_environment</code> <p>A copy of the environment where the modified parameters have been applied.</p> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>def modify(self,\n           data_source_position: list | np.ndarray | None = None,\n           source_radius: float | None = None,\n           shape: list | np.ndarray | None = None,\n           margins: int | list | np.ndarray | None = None,\n           multiplier: list | np.ndarray | None = None,\n           interpolation_method: str | None = None,\n           boundary_condition: str | None = None\n           ) -&gt; 'Environment':\n    '''\n    Returns a copy of the environment with one or more parameters modified.\n\n    Parameters\n    ----------\n    data_source_position: list or np.ndarray, optional\n        A new position for the source relative to the data file.\n    source_radius: float, optional\n        A new source radius.\n    shape: list or np.ndarray, optional\n        A new shape of environment.\n    margins: int or list or np.ndarray, optional\n        A new set of margins.\n    multiplier: list or np.ndarray, optional\n        A new multiplier to be applied to the data file (this will in turn increase or reduce the margins).\n    interpolation_method: str, optional\n        A new interpolation method to be used.\n    boundary_condition: str, optional\n        New boundary conditions for how the agent should behave at the edges.\n\n    Returns\n    -------\n    modified_environment\n        A copy of the environment where the modified parameters have been applied.\n    '''\n    if self.on_gpu:\n        cpu_environment = self.cpu_version\n        new_cpu_environment = cpu_environment.modify(\n            data_source_position = data_source_position,\n            source_radius        = source_radius,\n            shape                = shape,\n            margins              = margins,\n            multiplier           = multiplier,\n            interpolation_method = interpolation_method,\n            boundary_condition   = boundary_condition\n        )\n        return new_cpu_environment.to_gpu()\n\n    modified_environment = Environment(\n        data_file              = (self.data_file_path if (self.data_file_path is not None) else self._data),\n        data_source_position   = (data_source_position if (data_source_position is not None) else self.original_data_source_position),\n        source_radius          = (source_radius if (source_radius is not None) else self.source_radius),\n        layers                 = (self.layer_labels if self.has_layers else False),\n        shape                  = (shape if (shape is not None) else self.shape),\n        margins                = (margins if (margins is not None) else self.margins),\n        multiplier             = (multiplier if (multiplier is not None) else [1.0,1.0]),\n        interpolation_method   = (interpolation_method if (interpolation_method is not None) else self.interpolation_method),\n        preprocess_data        = self._preprocess_data,\n        boundary_condition     = (boundary_condition if (boundary_condition is not None) else self.boundary_condition),\n        start_zone             = self.start_type,\n        odor_present_threshold = self.odor_present_threshold,\n        name                   = self.name,\n        seed                   = self.seed\n    )\n    return modified_environment\n</code></pre>"},{"location":"reference/environment/#olfactory_navigation.environment.Environment.modify_scale","title":"<code>modify_scale(scale_factor)</code>","text":"<p>Function to modify the size of the environment by a scale factor. Everything will be scaled this factor. This includes: shape, margins, source radius, and data shape.</p> <p>Parameters:</p> Name Type Description Default <code>scale_factor</code> <code>float</code> <p>By how much to modify the size of the current environment.</p> required <p>Returns:</p> Name Type Description <code>modified_environment</code> <code>Environment</code> <p>The environment with the scale factor applied.</p> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>def modify_scale(self,\n                 scale_factor: float\n                 ) -&gt; 'Environment':\n    '''\n    Function to modify the size of the environment by a scale factor.\n    Everything will be scaled this factor. This includes: shape, margins, source radius, and data shape.\n\n    Parameters\n    ----------\n    scale_factor : float\n        By how much to modify the size of the current environment.\n\n    Returns\n    -------\n    modified_environment : Environment\n        The environment with the scale factor applied.\n    '''\n    modified_source_radius = self.source_radius * scale_factor\n    modified_shape = (np.array(self.shape) * scale_factor).astype(int)\n    modified_margins = (self.margins * scale_factor).astype(int)\n\n    modified_environment = Environment(\n        data_file              = (self.data_file_path if (self.data_file_path is not None) else self._data),\n        data_source_position   = self.original_data_source_position,\n        source_radius          = modified_source_radius,\n        layers                 = (self.layer_labels if self.has_layers else False),\n        shape                  = modified_shape,\n        margins                = modified_margins,\n        multiplier             = [1.0,1.0],\n        interpolation_method   = self.interpolation_method,\n        preprocess_data        = self._preprocess_data,\n        boundary_condition     = self.boundary_condition,\n        start_zone             = self.start_type,\n        odor_present_threshold = self.odor_present_threshold,\n        name                   = self.name,\n        seed                   = self.seed\n    )\n    return modified_environment\n</code></pre>"},{"location":"reference/environment/#olfactory_navigation.environment.Environment.move","title":"<code>move(pos, movement)</code>","text":"<p>Applies a movement vector to a position point and returns a new position point while respecting the boundary conditions.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>ndarray</code> <p>The start position of the movement.</p> required <code>movement</code> <code>ndarray</code> <p>A 2D movement vector.</p> required <p>Returns:</p> Name Type Description <code>new_pos</code> <code>ndarray</code> <p>The new position after applying the movement.</p> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>def move(self,\n         pos: np.ndarray,\n         movement: np.ndarray\n         ) -&gt; np.ndarray:\n    '''\n    Applies a movement vector to a position point and returns a new position point while respecting the boundary conditions.\n\n    Parameters\n    ----------\n    pos : np.ndarray\n        The start position of the movement.\n    movement : np.ndarray\n        A 2D movement vector.\n\n    Returns\n    -------\n    new_pos : np.ndarray\n        The new position after applying the movement.\n    '''\n    xp = cp if self.on_gpu else np\n\n    # Applying the movement vector\n    new_pos = pos + movement\n\n    # Handling the case we are dealing with a single point.\n    is_single_point = (len(pos.shape) == 1)\n    if is_single_point:\n        new_pos = new_pos[None,:]\n\n    shape_array = xp.array(self.shape)[None,:]\n\n    # Wrap boundary\n    if self.boundary_condition == 'wrap':\n        new_pos = xp.where(new_pos &lt; 0, (new_pos + shape_array), new_pos)\n        new_pos = xp.where(new_pos &gt;= shape_array, (new_pos - shape_array), new_pos)\n\n    # Stop boundary\n    elif self.boundary_condition == 'stop':\n        new_pos = xp.clip(new_pos, 0, (shape_array-1))\n\n    # Special wrap - vertical only\n    elif (self.dimensions == 2) and (self.boundary_condition == 'wrap_vertical'):\n        height, width = self.shape\n\n        new_pos[new_pos[:,0] &lt; 0, 0] += height\n        new_pos[new_pos[:,0] &gt;= height, 0] -= height\n\n        new_pos[:,1] = xp.clip(new_pos[:,1], 0, (width-1))\n\n    # Special wrap - horizontal only\n    elif (self.dimensions == 2) and (self.boundary_condition == 'wrap_horizontal'):\n        height, width = self.shape\n\n        new_pos[new_pos[:,1] &lt; 0, 1] += width\n        new_pos[new_pos[:,1] &gt;= width, 1] -= width\n\n        new_pos[:,0] = xp.clip(new_pos[:,0], 0, (height-1))\n\n    return new_pos[0] if is_single_point else new_pos\n</code></pre>"},{"location":"reference/environment/#olfactory_navigation.environment.Environment.plot","title":"<code>plot(frame=0, layer=0, ax=None)</code>","text":"<p>Simple function to plot the environment with a single frame of odor cues. The starting zone is also market down with a blue contour. The source of the odor is marked by a red circle.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>The frame of odor cues to print.</p> <code>0</code> <code>layer</code> <code>int</code> <p>The layer of the odor cues to print. (Ignored if the environment is not layered.)</p> <code>0</code> <code>ax</code> <code>Axes</code> <p>An ax on which the environment can be plot.</p> <code>None</code> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>def plot(self,\n         frame: int = 0,\n         layer: int = 0,\n         ax: plt.Axes | None = None\n         ) -&gt; None:\n    '''\n    Simple function to plot the environment with a single frame of odor cues.\n    The starting zone is also market down with a blue contour.\n    The source of the odor is marked by a red circle.\n\n    Parameters\n    ----------\n    frame : int, default=0\n        The frame of odor cues to print.\n    layer : int, default=0\n        The layer of the odor cues to print. (Ignored if the environment is not layered.)\n    ax : plt.Axes, optional\n        An ax on which the environment can be plot.\n    '''\n    # If on GPU use the CPU version to plot\n    if self.on_gpu:\n        self._alternate_version.plot(\n            frame=frame,\n            ax=ax\n        )\n        return # Blank return\n\n    # TODO: Implement plotting for 3D\n    assert self.dimensions == 2, \"Plotting function only available for 2D environments for now...\"\n\n    if ax is None:\n        _, ax = plt.subplots(1, figsize=(15,5))\n\n    legend_elements = [[],[]]\n\n    # Gather data frame\n    data_frame: np.ndarray = self._data[layer][frame] if self.has_layers else self._data[frame]\n    if not isinstance(data_frame, np.ndarray):\n        data_frame = np.array(data_frame)\n\n    if not self.data_processed:\n        data_frame = _resize_array(data_frame,\n                                   new_shape=self.data_shape,\n                                   interpolation=self.interpolation_method.lower())\n\n    # Odor grid\n    odor = Rectangle([0,0], 1, 1, color='black', fill=True)\n    frame_data = (data_frame &gt; (self.odor_present_threshold if self.odor_present_threshold is not None else 0)).astype(float)\n    environment_frame = np.zeros(self.shape, dtype=float)\n    environment_frame[self.data_bounds[0,0]:self.data_bounds[0,1], self.data_bounds[1,0]:self.data_bounds[1,1]] = frame_data\n    ax.imshow(environment_frame, cmap='Greys')\n\n    legend_elements[0].append(odor)\n    legend_elements[1].append(f'Frame {frame}' + ('' if not self.has_layers else f' (layer {layer})') + ' odor cues')\n\n    # Start zone contour\n    start_zone = Rectangle([0,0], 1, 1, color='blue', fill=False)\n    ax.contour(self.start_probabilities, levels=[0.0], colors='blue')\n\n    legend_elements[0].append(start_zone)\n    legend_elements[1].append('Start zone')\n\n    # Source circle\n    goal_circle = Circle(self.source_position[::-1], self.source_radius, color='r', fill=False, zorder=10)\n    legend_elements[0].append(goal_circle)\n    legend_elements[1].append('Source')\n\n    if self.source_radius &gt; 0.0:\n        ax.add_patch(goal_circle)\n    else:\n        ax.scatter(self.source_position[1], self.source_position[0], c='red')\n\n    # Legend\n    ax.legend(legend_elements[0], legend_elements[1])\n</code></pre>"},{"location":"reference/environment/#olfactory_navigation.environment.Environment.random_start_points","title":"<code>random_start_points(n=1)</code>","text":"<p>Function to generate n starting positions following the starting probabilities.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>How many random starting positions to generate</p> <code>1</code> <p>Returns:</p> Name Type Description <code>random_states_2d</code> <code>ndarray</code> <p>The n random 2d points in a n x 2 array.</p> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>def random_start_points(self,\n                        n: int = 1\n                        ) -&gt; np.ndarray:\n    '''\n    Function to generate n starting positions following the starting probabilities.\n\n    Parameters\n    ----------\n    n : int, default=1\n        How many random starting positions to generate\n\n    Returns\n    -------\n    random_states_2d : np.ndarray\n        The n random 2d points in a n x 2 array.\n    '''\n    xp = cp if self.on_gpu else np\n\n    assert (n &gt; 0), \"n has to be a strictly positive number (&gt;0)\"\n\n    random_states = self.rnd_state.choice(xp.arange(int(np.prod(self.shape))), size=n, replace=True, p=self.start_probabilities.ravel())\n    random_states_2d = xp.array(xp.unravel_index(random_states, self.shape)).T\n    return random_states_2d\n</code></pre>"},{"location":"reference/environment/#olfactory_navigation.environment.Environment.save","title":"<code>save(folder=None, save_arrays=False, force=False)</code>","text":"<p>Function to save the environment to the memory.</p> <p>By default it saved in a new folder at the current path in a new folder with the name 'Env-' where  is the name set when initializing an environment. In this folder a file \"METADATA.json\" is created containing all the properties of the environment. <p>The numpy arrays of the environment (grid and start_probabilities) can be saved or not. If not, when the environment is loaded it needs to be reconstructed from the original data file. The arrays are saved to .npy files along with the METADATA file.</p> <p>If an environment of the same name is already saved, the saving will be interupted. It can however be forced with the force parameter.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>The folder to which to save the environment data. If it is not provided, it will be created in the current folder.</p> <code>None</code> <code>save_arrays</code> <code>bool</code> <p>Whether or not to save the numpy arrays to memory. (The arrays can be heavy)</p> <code>False</code> <code>force</code> <code>bool</code> <p>In case an environment of the same name is already saved, it will be overwritten.</p> <code>False</code> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>def save(self,\n         folder: str | None = None,\n         save_arrays: bool = False,\n         force: bool = False\n         ) -&gt; None:\n    '''\n    Function to save the environment to the memory.\n\n    By default it saved in a new folder at the current path in a new folder with the name 'Env-&lt;name&gt;' where &lt;name&gt; is the name set when initializing an environment.\n    In this folder a file \"METADATA.json\" is created containing all the properties of the environment.\n\n    The numpy arrays of the environment (grid and start_probabilities) can be saved or not. If not, when the environment is loaded it needs to be reconstructed from the original data file.\n    The arrays are saved to .npy files along with the METADATA file.\n\n    If an environment of the same name is already saved, the saving will be interupted. It can however be forced with the force parameter.\n\n    Parameters\n    ----------\n    folder : str, optional\n        The folder to which to save the environment data. If it is not provided, it will be created in the current folder.\n    save_arrays : bool, default=False\n        Whether or not to save the numpy arrays to memory. (The arrays can be heavy)\n    force : bool, default=False\n        In case an environment of the same name is already saved, it will be overwritten.\n    '''\n    # If on gpu, use the cpu version to save\n    if self.on_gpu:\n        self._alternate_version.save(\n            folder=folder,\n            save_arrays=save_arrays,\n            force=force\n        )\n        return # Blank return\n\n    # Assert either data_file is provided or save_arrays is enabled\n    assert save_arrays or ((self.data_file_path is not None) and (self.start_type is not None)), \"The environment was not created from a data file so 'save_arrays' has to be set to True.\"\n\n    # Adding env name to folder path\n    if folder is None:\n        folder = f'./Env-{self.name}'\n    else:\n        folder += '/Env-' + self.name\n\n    # Checking the folder exists or creates it\n    if not os.path.exists(folder):\n        os.mkdir(folder)\n    elif len(os.listdir(folder)) &gt; 0:\n        if force:\n            shutil.rmtree(folder)\n            os.mkdir(folder)\n        else:\n            raise Exception(f'{folder} is not empty. If you want to overwrite the saved model, enable \"force\".')\n\n    # Generating the metadata arguments dictionary\n    arguments = {}\n    arguments['name'] = self.name\n\n    if self.data_file_path is not None:\n        arguments['data_file_path'] = self.data_file_path\n\n    arguments['timesteps']                     = int(self.timesteps)\n    arguments['data_shape']                    = self.data_shape\n    arguments['dimensions']                    = self.dimensions\n    arguments['margins']                       = self.margins.tolist()\n    arguments['shape']                         = self.shape\n    arguments['data_bounds']                   = self.data_bounds.tolist()\n    arguments['original_data_source_position'] = self.original_data_source_position.tolist()\n    arguments['data_source_position']          = self.data_source_position.tolist()\n    arguments['layers']                        = (self.layer_labels if self.has_layers else False)\n    arguments['source_position']               = self.source_position.tolist()\n    arguments['source_radius']                 = self.source_radius\n    arguments['interpolation_method']          = self.interpolation_method\n    arguments['preprocess_data']               = self._preprocess_data\n    arguments['data_processed']                = self.data_processed\n    arguments['boundary_condition']            = self.boundary_condition\n    arguments['start_type']                    = self.start_type\n    arguments['seed']                          = self.seed\n\n    # Check how the start probabilities were built\n    if self.start_type.startswith('custom') and len(self.start_type.split('_')) == 1 and not save_arrays:\n        raise Exception('Start probabilities have been set from a custom array, please enable save_arrays to be able to reconstruct the environment later.')\n\n    if self.odor_present_threshold is not None:\n        arguments['odor_present_threshold'] = self.odor_present_threshold\n\n    # Output the arguments to a METADATA file\n    with open(folder + '/METADATA.json', 'w') as json_file:\n        json.dump(arguments, json_file, indent=4)\n\n    # Output the numpy arrays\n    if save_arrays:\n        if isinstance(self._data, np.ndarray):\n            np.save(folder + '/data.npy', self._data)\n        else:\n            raise NotImplementedError('The saving of data that is not a Numpy array was not implemented yet.')\n        np.save(folder + '/start_probabilities.npy', self.start_probabilities)\n\n    # Success print\n    self.saved_at = os.path.abspath(folder).replace('\\\\', '/')\n    print(f'Environment saved to: {folder}')\n</code></pre>"},{"location":"reference/environment/#olfactory_navigation.environment.Environment.source_reached","title":"<code>source_reached(pos)</code>","text":"<p>Checks whether a given position is within the source radius.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>ndarray</code> <p>The position to check whether in the radius of the source.</p> required <p>Returns:</p> Name Type Description <code>is_at_source</code> <code>bool</code> <p>Whether or not the position is within the radius of the source.</p> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>def source_reached(self,\n                   pos: np.ndarray\n                   ) -&gt; bool | np.ndarray:\n    '''\n    Checks whether a given position is within the source radius.\n\n    Parameters\n    ----------\n    pos : np.ndarray\n        The position to check whether in the radius of the source.\n\n    Returns\n    -------\n    is_at_source : bool\n        Whether or not the position is within the radius of the source.\n    '''\n    xp = cp if self.on_gpu else np\n\n    # Handling the case of a single point\n    is_single_point = (len(pos.shape) == 1)\n    if is_single_point:\n        pos = pos[None,:]\n\n    is_at_source: np.ndarray = (xp.sum((pos - self.source_position[None,:]) ** 2, axis=-1) &lt;= (self.source_radius ** 2))\n\n    return bool(is_at_source[0]) if is_single_point else is_at_source\n</code></pre>"},{"location":"reference/environment/#olfactory_navigation.environment.Environment.to_cpu","title":"<code>to_cpu()</code>","text":"<p>Function to send the numpy arrays of the environment to the cpu memory. It returns a new instance of the Environment with the arrays as numpy arrays.</p> <p>Returns:</p> Name Type Description <code>cpu_environment</code> <code>Environment</code> <p>A new environment instance where the arrays are on the cpu memory.</p> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>def to_cpu(self) -&gt; 'Environment':\n    '''\n    Function to send the numpy arrays of the environment to the cpu memory.\n    It returns a new instance of the Environment with the arrays as numpy arrays.\n\n    Returns\n    -------\n    cpu_environment : Environment\n        A new environment instance where the arrays are on the cpu memory.\n    '''\n    # Check whether the agent is already on the cpu or not\n    if not self.on_gpu:\n        return self\n\n    if self._alternate_version is not None:\n        print('[warning] A CPU instance already existed and is being recreated.')\n        self._alternate_version = None\n\n    # Generating a new instance\n    cls = self.__class__\n    cpu_environment = cls.__new__(cls)\n\n    # Copying arguments to gpu\n    for arg, val in self.__dict__.items():\n        if isinstance(val, cp.ndarray):\n            setattr(cpu_environment, arg, cp.asnumpy(val))\n        elif arg == 'rnd_state':\n            setattr(cpu_environment, arg, np.random.RandomState(self.seed))\n        else:\n            setattr(cpu_environment, arg, val)\n\n    # Self reference instances\n    self._alternate_version = cpu_environment\n    cpu_environment._alternate_version = self\n\n    cpu_environment.on_gpu = True\n    return cpu_environment\n</code></pre>"},{"location":"reference/environment/#olfactory_navigation.environment.Environment.to_gpu","title":"<code>to_gpu()</code>","text":"<p>Function to send the numpy arrays of the environment to the gpu memory. It returns a new instance of the Environment with the arrays as cupy arrays.</p> <p>Returns:</p> Name Type Description <code>gpu_environment</code> <code>Environment</code> <p>A new environment instance where the arrays are on the gpu memory.</p> Source code in <code>olfactory_navigation/environment.py</code> <pre><code>def to_gpu(self) -&gt; 'Environment':\n    '''\n    Function to send the numpy arrays of the environment to the gpu memory.\n    It returns a new instance of the Environment with the arrays as cupy arrays.\n\n    Returns\n    -------\n    gpu_environment : Environment\n        A new environment instance where the arrays are on the gpu memory.\n    '''\n    # Check whether the environment is already on the gpu or not\n    if self.on_gpu:\n        return self\n\n    # Warn and overwrite alternate_version in case it already exists\n    if self._alternate_version is not None:\n        print('[warning] A GPU instance already existed and is being recreated.')\n        self._alternate_version = None\n\n    assert gpu_support, \"GPU support is not enabled...\"\n\n    # Generating a new instance\n    cls = self.__class__\n    gpu_environment = cls.__new__(cls)\n\n    # Copying arguments to gpu\n    for arg, val in self.__dict__.items():\n        if isinstance(val, np.ndarray):\n            setattr(gpu_environment, arg, cp.array(val))\n        elif arg == 'rnd_state':\n            setattr(gpu_environment, arg, cp.random.RandomState(self.seed))\n        else:\n            setattr(gpu_environment, arg, val)\n\n    # Self reference instances\n    self._alternate_version = gpu_environment\n    gpu_environment._alternate_version = self\n\n    gpu_environment.on_gpu = True\n    return gpu_environment\n</code></pre>"},{"location":"reference/simulation/","title":"simulation","text":""},{"location":"reference/simulation/#olfactory_navigation.simulation.SimulationHistory","title":"<code>SimulationHistory</code>","text":"<p>Class to record the steps that happened during a simulation with the following information being saved:</p> <ul> <li>the positions the agents pass by</li> <li>the actions the agents take</li> <li>the observations the agents receive ('observations')</li> <li>the time in the simulation process</li> </ul> <p>Parameters:</p> Name Type Description Default <code>start_points</code> <code>ndarray</code> <p>The initial points of the agents in the simulation.</p> required <code>environment</code> <code>Environment</code> <p>The environment on which the simulation is run (can be different from the one associated with the agent).</p> required <code>agent</code> <code>Agent</code> <p>The agent used in the simulation.</p> required <code>time_shift</code> <code>ndarray</code> <p>An array of time shifts in the simulation data.</p> required <code>horizon</code> <code>int</code> <p>The horizon of the simulation. i.e. how many steps can be taken by the agent during the simulation before he is considered lost.</p> required <code>reward_discount</code> <code>float</code> <p>A discount to be applied to the rewards received by the agent. (eg: reward of 1 received at time n would be: 1 * reward_discount^n)</p> <code>0.99</code> <p>Attributes:</p> Name Type Description <code>start_points</code> <code>ndarray</code> <code>environment</code> <code>Environment</code> <code>agent</code> <code>Agent</code> <code>time_shift</code> <code>ndarray</code> <code>horizon</code> <code>int</code> <code>reward_discount</code> <code>float</code> <code>environment_dimensions</code> <code>int</code> <p>The amount of dimensions of the environment.</p> <code>environment_shape</code> <code>tuple[int]</code> <p>The shape of the environment.</p> <code>environment_source_position</code> <code>ndarray</code> <p>The position of the odor source in the environment.</p> <code>environment_source_radius</code> <code>float</code> <p>The radius of the odor source in the environment.</p> <code>environment_layer_labels</code> <code>list[str] or None</code> <p>A list of the layer labels if the environment has layers.</p> <code>agent_thresholds</code> <code>ndarray</code> <p>An array of the olfaction thresholds of the agent.</p> <code>n</code> <code>int</code> <p>The amount of simulations.</p> <code>actions</code> <code>list[ndarray]</code> <p>A list of numpy arrays. At each step of the simulation, an array of shape n by 2 is appended to this list representing the n actions as dy,dx vectors.</p> <code>positions</code> <code>list[ndarray]</code> <p>A list of numpy arrays. At each step of the simulation, an array of shape n by 2 is appended to this list representing the n positions as y,x vectors.</p> <code>observations</code> <code>list[ndarray]</code> <p>A list of numpy arrays. At each step of the simulation, an array of shape n is appended to this list representing the n observations received by the agents.</p> <code>timestamps</code> <code>dict[int, list[datetime]]</code> <p>A dictionay of the timestamps at which the simulation steps were recorded where the key is the id of the first run with these timestamps.</p> <code>reached_source</code> <code>ndarray</code> <p>A numpy array of booleans saying whether the simulations reached the source or not.</p> <code>done_at_step</code> <code>ndarray</code> <p>A numpy array containing n elements that records when a given simulation reaches the source (-1 is not reached).</p> <code>start_time</code> <code>datetime</code> <p>The time at which the first simulation was started.</p> <code>simulation_dfs</code> <code>list[DataFrame]</code> <p>A list of the pandas DataFrame where each dataframe is a single simulation history.</p> <code>runs_analysis_df</code> <code>DataFrame</code> <p>A Pandas DataFrame analyzing the results of the simulations.</p> <code>general_analysis_df</code> <code>DataFrame</code> <p>A Pandas DataFrame analyzing the results of the simulations.</p> <code>done_count</code> <code>int</code> <p>How many simulations are terminated (whether they reached the source or not).</p> <code>successful_simulation</code> <code>ndarray</code> <p>A boolean array of which simulations reached the source.</p> <code>success_count</code> <code>int</code> <p>How many simulations reached the source.</p> <code>simulations_at_horizon</code> <code>ndarray</code> <p>A boolean array of which simulations reached the horizon.</p> <code>summary</code> <code>str</code> <p>A string summarizing the performances of all the simulations.</p> Source code in <code>olfactory_navigation/simulation.py</code> <pre><code>class SimulationHistory:\n    '''\n    Class to record the steps that happened during a simulation with the following information being saved:\n\n    - the positions the agents pass by\n    - the actions the agents take\n    - the observations the agents receive ('observations')\n    - the time in the simulation process\n\n\n    Parameters\n    ----------\n    start_points : np.ndarray\n        The initial points of the agents in the simulation.\n    environment : Environment\n        The environment on which the simulation is run (can be different from the one associated with the agent).\n    agent : Agent\n        The agent used in the simulation.\n    time_shift : np.ndarray\n        An array of time shifts in the simulation data.\n    horizon : int\n        The horizon of the simulation. i.e. how many steps can be taken by the agent during the simulation before he is considered lost.\n    reward_discount : float, default=0.99\n        A discount to be applied to the rewards received by the agent. (eg: reward of 1 received at time n would be: 1 * reward_discount^n)\n\n    Attributes\n    ----------\n    start_points : np.ndarray\n    environment : Environment\n    agent : Agent\n    time_shift : np.ndarray\n    horizon : int\n    reward_discount : float\n    environment_dimensions : int\n        The amount of dimensions of the environment.\n    environment_shape : tuple[int]\n        The shape of the environment.\n    environment_source_position : np.ndarray\n        The position of the odor source in the environment.\n    environment_source_radius : float\n        The radius of the odor source in the environment.\n    environment_layer_labels : list[str] or None\n        A list of the layer labels if the environment has layers.\n    agent_thresholds : np.ndarray\n        An array of the olfaction thresholds of the agent.\n    n : int\n        The amount of simulations.\n    actions : list[np.ndarray]\n        A list of numpy arrays. At each step of the simulation, an array of shape n by 2 is appended to this list representing the n actions as dy,dx vectors.\n    positions : list[np.ndarray]\n        A list of numpy arrays. At each step of the simulation, an array of shape n by 2 is appended to this list representing the n positions as y,x vectors.\n    observations : list[np.ndarray]\n        A list of numpy arrays. At each step of the simulation, an array of shape n is appended to this list representing the n observations received by the agents.\n    timestamps : dict[int, list[datetime]]\n        A dictionay of the timestamps at which the simulation steps were recorded where the key is the id of the first run with these timestamps.\n    reached_source : np.ndarray\n        A numpy array of booleans saying whether the simulations reached the source or not.\n    done_at_step : np.ndarray\n        A numpy array containing n elements that records when a given simulation reaches the source (-1 is not reached).\n    start_time : datetime\n        The time at which the first simulation was started.\n    simulation_dfs : list[pd.DataFrame]\n        A list of the pandas DataFrame where each dataframe is a single simulation history.\n    runs_analysis_df : pd.DataFrame\n        A Pandas DataFrame analyzing the results of the simulations.\n    general_analysis_df : pd.DataFrame\n        A Pandas DataFrame analyzing the results of the simulations.\n    done_count : int\n        How many simulations are terminated (whether they reached the source or not).\n    successful_simulation : np.ndarray\n        A boolean array of which simulations reached the source.\n    success_count : int\n        How many simulations reached the source.\n    simulations_at_horizon : np.ndarray\n        A boolean array of which simulations reached the horizon.\n    summary : str\n        A string summarizing the performances of all the simulations.\n    '''\n    def __init__(self,\n                 start_points: np.ndarray,\n                 environment: Environment,\n                 agent: Agent,\n                 time_shift: np.ndarray,\n                 horizon: int,\n                 reward_discount: float = 0.99\n                 ) -&gt; None:\n        # If only on state is provided, we make it a 1x2 vector\n        if len(start_points.shape) == 1:\n            start_points = start_points[None,:]\n\n        # Fixed parameters\n        self.n = len(start_points)\n        self.environment = environment.cpu_version\n        self.agent = agent.cpu_version\n        self.time_shift = time_shift if gpu_support and cp.get_array_module(time_shift) == np else cp.asnumpy(time_shift)\n        self.horizon = horizon\n        self.reward_discount = reward_discount\n\n        # Simulation Tracking\n        self.start_points = start_points if gpu_support and cp.get_array_module(start_points) == np else cp.asnumpy(start_points)\n        self.actions = []\n        self.positions = []\n        self.observations = []\n        self.timestamps = {0: [datetime.now()]}\n\n        self._running_sims = np.arange(self.n)\n        self.reached_source = np.zeros(self.n, dtype=bool)\n        self.done_at_step = np.full(self.n, fill_value=-1)\n\n        # Environment and agent attributes\n        self.environment_dimensions = self.environment.dimensions\n        self.environment_shape = self.environment.shape\n        self.environment_source_position = self.environment.source_position\n        self.environment_source_radius = self.environment.source_radius\n        self.environment_layer_labels = self.environment.layer_labels\n        self.agent_thresholds = self.agent.thresholds\n\n        # Other parameters\n        self._simulation_dfs = None\n\n\n    def add_step(self,\n                 actions: np.ndarray,\n                 next_positions: np.ndarray,\n                 observations: np.ndarray,\n                 reached_source: np.ndarray,\n                 interupt: np.ndarray\n                 ) -&gt; None:\n        '''\n        Function to add a step in the simulation history.\n\n        Parameters\n        ----------\n        actions : np.ndarray\n            The actions that were taken by the agents.\n        next_positions : np.ndarray\n            The positions that were reached by the agents after having taken actions.\n        observations : np.ndarray\n            The observations the agents receive after having taken actions.\n        reached_source : np.ndarray\n            A boolean array of whether each agent has reached the source or not.\n        interupt : np.ndarray\n            A boolean array of whether each agent has to be terminated even if it hasnt reached the source yet.\n        '''\n        self._simulation_dfs = None\n\n        # Time tracking\n        self.timestamps[0].append(datetime.now())\n\n        # Check if environment if layered and/or 3D\n        layered = 0 if self.environment_layer_labels is None else 1\n\n        # Handle case cupy arrays are provided\n        if gpu_support:\n            actions = actions if cp.get_array_module(actions) == np else cp.asnumpy(actions)\n            next_positions = next_positions if cp.get_array_module(next_positions) == np else cp.asnumpy(next_positions)\n            observations = observations if cp.get_array_module(observations) == np else cp.asnumpy(observations)\n            reached_source = reached_source if cp.get_array_module(reached_source) == np else cp.asnumpy(reached_source)\n            interupt = interupt if cp.get_array_module(interupt) == np else cp.asnumpy(interupt)\n\n        # Actions tracking\n        action_all_sims = np.full((self.n, (layered + self.environment_dimensions)), fill_value=-1)\n        action_all_sims[self._running_sims] = actions\n        self.actions.append(action_all_sims)\n\n        # Next states tracking\n        next_position_all_sims = np.full((self.n, self.environment_dimensions), fill_value=-1)\n        next_position_all_sims[self._running_sims] = next_positions\n        self.positions.append(next_position_all_sims)\n\n        # Observation tracking\n        observation_all_sims = np.full((self.n,), fill_value=-1, dtype=float)\n        observation_all_sims[self._running_sims] = observations\n        self.observations.append(observation_all_sims)\n\n        # Recording at which step the simulation is done if it is done and whether it reached the source\n        self.done_at_step[self._running_sims[reached_source | interupt]] = len(self.positions)\n        self.reached_source[self._running_sims[reached_source]] = True\n\n        # Updating the list of running sims\n        self._running_sims = self._running_sims[~reached_source &amp; ~interupt]\n\n\n    def compute_distance_to_source(self) -&gt; np.ndarray:\n        '''\n        Function to compute the optimal distance to the source of each starting point according to the optimal_distance_metric attribute.\n\n        Returns\n        -------\n        distance : np.ndarray\n            The optimal distances to the source point.\n        '''\n        point = self.start_points\n\n        # Handling the case we have a single point\n        is_single_point = (len(point.shape) == 1)\n        if is_single_point:\n            point = point[None,:]\n\n        # Computing dist\n        dist = None\n        # if self.optimal_distance_metric == 'manhattan': # TODO Allow for other metrics to be used\n        dist = np.sum(np.abs(self.environment_source_position[None,:] - point), axis=-1) - self.environment_source_radius\n\n        if dist is None: # Meaning it was not computed\n            raise NotImplementedError('This distance metric has not yet been implemented')\n\n        return float(dist[0]) if is_single_point else dist\n\n\n    @property\n    def runs_analysis_df(self) -&gt; pd.DataFrame:\n        '''\n        A Pandas DataFrame analyzing the results of the simulations.\n        It aggregates the simulations in single rows, recording:\n\n         - &lt;axis&gt;:              The starting positions at the given axis\n         - optimal_steps_count: The minimal amount of steps to reach the source\n         - converged:           Whether or not the simulation reached the source\n         - reached_horizon:     Whether the failed simulation reached to horizon\n         - steps_taken:         The amount of steps the agent took to reach the source, (horizon if the simulation did not reach the source)\n         - discounted_rewards:  The discounted reward received by the agent over the course of the simulation\n         - extra_steps:         The amount of extra steps compared to the optimal trajectory\n         - t_min_over_t:        Normalized version of the extra steps measure, where it tends to 1 the least amount of time the agent took to reach the source compared to an optimal trajectory.\n        '''\n        # Get axes labels\n        axes_labels = None\n        if self.environment_dimensions &lt;= 3:\n            axes_labels = ['z', 'y', 'x'][-self.environment_dimensions:]\n        else:\n            axes_labels = [f'x{i}' for i in range(self.environment_dimensions)]\n\n        # Dataframe creation\n        df = pd.DataFrame(self.start_points, columns=axes_labels)\n        df['optimal_steps_count'] = self.compute_distance_to_source()\n        df['converged'] = self.reached_source\n        df['reached_horizon'] = np.all(self.positions[-1] != -1, axis=1) &amp; ~self.reached_source &amp; (len(self.positions) == self.horizon)\n        df['steps_taken'] = np.where(self.done_at_step &gt;= 0, self.done_at_step, len(self.positions))\n        df['discounted_rewards'] = self.reward_discount ** df['steps_taken']\n        df['extra_steps'] = df['steps_taken'] - df['optimal_steps_count']\n        df['t_min_over_t'] = df['optimal_steps_count'] / df['steps_taken']\n\n        # Reindex\n        runs_list = [f'run_{i}' for i in range(self.n)]\n        df.index = runs_list\n\n        return df\n\n\n    @property\n    def general_analysis_df(self) -&gt; pd.DataFrame:\n        '''\n        A Pandas DataFrame analyzing the results of the simulations.\n        Summarizing the performance of all the simulations with the following metrics:\n\n         - converged:           Whether or not the simulation reached the source\n         - reached_horizon:     Whether the failed simulation reached to horizon\n         - steps_taken:         The amount of steps the agent took to reach the source, (horizon if the simulation did not reach the source)\n         - discounted_rewards:  The discounted reward received by the agent over the course of the simulation\n         - extra_steps:         The amount of extra steps compared to the optimal trajectory\n         - t_min_over_t:        Normalized version of the extra steps measure, where it tends to 1 the least amount of time the agent took to reach the source compared to an optimal trajectory.\n\n        For the measures (converged, steps_taken, discounted_rewards, extra_steps, t_min_over_t), the average and standard deviations are computed in rows at the top.\n        '''\n        df = self.runs_analysis_df\n\n        # Analysis aggregations\n        columns_to_analyze = ['converged', 'reached_horizon', 'steps_taken', 'discounted_rewards', 'extra_steps', 't_min_over_t']\n        row_names = [['mean', 'standard_deviation', 'success_mean', 'success_standard_deviation']]\n        general_analysis_data = [\n            df[columns_to_analyze].mean(),\n            df[columns_to_analyze].std(),\n            df.loc[df['converged'], columns_to_analyze].mean(),\n            df.loc[df['converged'], columns_to_analyze].std()\n        ]\n\n        return pd.DataFrame(data=general_analysis_data, index=row_names, columns=columns_to_analyze)\n\n\n    @property\n    def done_count(self) -&gt; int:\n        '''\n        Returns how many simulations are terminated (whether they reached the source or not).\n        '''\n        return self.n - len(self._running_sims)\n\n\n    @property\n    def successful_simulation(self) -&gt; np.ndarray:\n        return self.reached_source\n\n\n    @property\n    def success_count(self) -&gt; int:\n        '''\n        Returns how many simulations reached the source.\n        '''\n        return int(np.sum(self.successful_simulation))\n\n\n    @property\n    def simulations_at_horizon(self) -&gt; np.ndarray:\n        '''\n        Returns a boolean array of which simulations reached the horizon.\n        '''\n        last_position_exists = np.all(self.positions[-1] != -1, axis=1)\n        simulation_reached_horizon = (len(self.positions) == self.horizon)\n        return last_position_exists &amp; ~self.reached_source &amp; simulation_reached_horizon\n\n\n    @property\n    def summary(self) -&gt; str:\n        '''\n        A string summarizing the performances of all the simulations.\n        The metrics used are averages of:\n\n         - Step count\n         - Extra steps\n         - Discounted rewards\n         - Tmin / T\n\n        Along with the respective the standard deviations and equally for only for the successful simulations.\n        '''\n        success_sim_count = self.success_count\n        failed_count = self.n - success_sim_count\n        reached_horizon_count = int(np.sum(self.simulations_at_horizon))\n        summary_str = f'Simulations reached goal: {success_sim_count}/{self.n} ({failed_count} failures (reached horizon: {reached_horizon_count})) ({(success_sim_count*100)/self.n:.2f}% success)'\n\n        if success_sim_count == 0:\n            return summary_str\n\n        # Metrics\n        df = self.general_analysis_df\n\n        summary_str += f\"\\n - {'Average step count:':&lt;35} {df.loc['mean','steps_taken'].item():.3f} +- {df.loc['standard_deviation','steps_taken'].item():.2f} \"\n        summary_str += f\"(Successful only: {df.loc['success_mean','steps_taken'].item():.3f} +- {df.loc['success_standard_deviation','steps_taken'].item():.2f})\"\n\n        summary_str += f\"\\n - {'Extra steps:':&lt;35} {df.loc['mean','extra_steps'].item():.3f} +- {df.loc['standard_deviation','extra_steps'].item():.2f} \"\n        summary_str += f\"(Successful only: {df.loc['success_mean','extra_steps'].item():.3f} +- {df.loc['success_standard_deviation','extra_steps'].item():.2f})\"\n\n        summary_str += f\"\\n - {'Average discounted rewards (ADR):':&lt;35} {df.loc['mean','discounted_rewards'].item():.3f} +- {df.loc['standard_deviation','discounted_rewards'].item():.2f} \"\n        summary_str += f\"(Successful only: {df.loc['success_mean','discounted_rewards'].item():.3f} +- {df.loc['success_standard_deviation','discounted_rewards'].item():.2f})\"\n\n        summary_str += f\"\\n - {'Tmin/T:':&lt;35} {df.loc['mean','t_min_over_t'].item():.3f} +- {df.loc['standard_deviation','t_min_over_t'].item():.2f} \"\n        summary_str += f\"(Successful only: {df.loc['success_mean','t_min_over_t'].item():.3f} +- {df.loc['success_standard_deviation','t_min_over_t'].item():.2f})\"\n\n        return summary_str\n\n\n    @property\n    def start_time(self) -&gt; datetime:\n        '''\n        The time at which the first simulation was started.\n        '''\n        return self.timestamps[0][0]\n\n\n    @property\n    def simulation_dfs(self) -&gt; list[pd.DataFrame]:\n        '''\n        A list of the pandas DataFrame where each dataframe is a single simulation history.\n        Each row is a different time instant of simulation process with each column being:\n\n         - time (of the simulation data)\n         - [position] (z,) y, x  OR  x0, x1, ... xn\n         - (layer)\n         - [movement] (dz,) dy, dx  OR  dx0, dx1, ... dxn\n         - o (pure, not thresholded)\n         - reached_source (boolean)\n        '''\n        if self._simulation_dfs is None:\n            self._simulation_dfs = []\n\n            # Converting state, actions and observation to numpy arrays\n            states_array = np.array(self.positions)\n            action_array = np.array(self.actions)\n            observation_array = np.array(self.observations)\n\n            # Get axes labels\n            axes_labels = None\n            if self.environment_dimensions &lt;= 3:\n                axes_labels = ['z', 'y', 'x'][-self.environment_dimensions:]\n            else:\n                axes_labels = [f'x{i}' for i in range(self.environment_dimensions)]\n\n            # Loop through the n simulations\n            for i in range(self.n):\n                length = self.done_at_step[i] if self.done_at_step[i] &gt;= 0 else len(states_array)\n\n                # Creation of the dataframe\n                df = {}\n                df['time'] = np.arange(length+1) + self.time_shift[i]\n\n                # - Position variables\n                for axis_i, axis in enumerate(axes_labels):\n                    df[axis] = np.hstack([self.start_points[i, axis_i], states_array[:length, i, axis_i]])\n\n                # - Action variables\n                if self.environment_layer_labels is not None:\n                    df['layer'] = np.hstack([[None], action_array[:length, i, 0]])\n\n                for axis_i, axis in enumerate(axes_labels):\n                    axis_i += (0 if self.environment_layer_labels is None else 1)\n                    df['d' + axis]   = np.hstack([[None], action_array[:length, i, axis_i]])\n\n                # - Other variables\n                df['o'] = np.hstack([[None], observation_array[:length, i]])\n                df['reached_source'] = np.hstack([[None], np.where(np.arange(1,length+1) == self.done_at_step[i], (1 if self.reached_source[i] else 0), 0)])\n\n                # Append\n                self._simulation_dfs.append(pd.DataFrame(df))\n\n        return self._simulation_dfs\n\n\n    def __add__(self, other_hist: 'SimulationHistory'):\n        # Asserting the SimulationHistory objects are compatible\n        assert self.horizon == other_hist.horizon, \"The 'horizon' parameters must match between the two SimulationHistory objects...\"\n        assert self.reward_discount == other_hist.reward_discount, \"The 'reward_discount' parameters must match between the two SimulationHistory objects...\"\n        assert self.environment_dimensions == other_hist.environment_dimensions, \"The 'environment_dimensions' parameters must match between the two SimulationHistory objects...\"\n        assert self.environment_shape == other_hist.environment_shape, \"The 'environment_shape' parameters must match between the two SimulationHistory objects...\"\n        assert self.environment_layer_labels == other_hist.environment_layer_labels, \"The 'environment_layer_labels' parameters must match between the two SimulationHistory objects...\"\n        assert all(self.environment_source_position == other_hist.environment_source_position), \"The 'environment_source_position' parameters must match between the two SimulationHistory objects...\"\n        assert self.environment_source_radius == other_hist.environment_source_radius, \"The 'environment_source_radius' parameters must match between the two SimulationHistory objects...\"\n        assert all(self.agent_thresholds == other_hist.agent_thresholds), \"The 'agent_thresholds' parameters must match between the two SimulationHistory objects...\"\n\n        # Combining arrays\n        combined_start_points = np.vstack([self.start_points,\n                                           other_hist.start_points])\n        combined_time_shifts = np.hstack([self.time_shift,\n                                          other_hist.time_shift])\n        combined_reached_source = np.hstack([self.reached_source,\n                                             other_hist.reached_source])\n        combined_done_at_step = np.hstack([self.done_at_step,\n                                           other_hist.done_at_step])\n\n        combined_actions = []\n        combined_positions = []\n        combined_observations = []\n        for step_i in range(max([len(self.actions), len(other_hist.actions)])):\n            self_in_range = (step_i &lt; len(self.actions))\n            other_in_range = (step_i &lt; len(other_hist.actions))\n            combined_actions.append(np.vstack([self.actions[step_i] if self_in_range else np.full_like(self.actions[0], fill_value=-1),\n                                               other_hist.actions[step_i] if other_in_range else np.full_like(other_hist.actions[0], fill_value=-1)]))\n            combined_positions.append(np.vstack([self.positions[step_i] if self_in_range else np.full_like(self.positions[0], fill_value=-1),\n                                                 other_hist.positions[step_i] if other_in_range else np.full_like(other_hist.positions[0], fill_value=-1)]))\n            combined_observations.append(np.hstack([self.observations[step_i] if self_in_range else np.full_like(self.observations[0], fill_value=-1),\n                                                    other_hist.observations[step_i] if other_in_range else np.full_like(other_hist.observations[0], fill_value=-1)]))\n\n        # Combining timestamps\n        combined_timestamps = self.timestamps | {k + self.n: v for k,v in other_hist.timestamps.items()}\n\n        # Creating the combined simulation history object\n        combined_hist = SimulationHistory.__new__(SimulationHistory)\n\n        combined_hist.n = self.n + other_hist.n\n        combined_hist.environment = self.environment.cpu_version if self.environment is not None else (other_hist.environment.cpu_version if other_hist.environment is not None else None)\n        combined_hist.agent = self.agent.cpu_version if self.agent is not None else (other_hist.agent.cpu_version if other_hist.agent is not None else None)\n        combined_hist.time_shift = combined_time_shifts\n        combined_hist.horizon = self.horizon\n        combined_hist.reward_discount = self.reward_discount\n\n        combined_hist.start_points = combined_start_points\n        combined_hist._running_sims = None\n\n        combined_hist.positions = combined_positions\n        combined_hist.actions = combined_actions\n        combined_hist.observations = combined_observations\n        combined_hist.reached_source = combined_reached_source\n        combined_hist.done_at_step = combined_done_at_step\n        combined_hist.timestamps = combined_timestamps\n\n        # Other attributes\n        combined_hist.environment_dimensions = self.environment_dimensions\n        combined_hist.environment_shape = self.environment_shape\n        combined_hist.environment_source_position = self.environment_source_position\n        combined_hist.environment_source_radius = self.environment_source_radius\n        combined_hist.environment_layer_labels = self.environment_layer_labels\n        combined_hist.agent_thresholds = self.agent_thresholds\n        combined_hist._simulation_dfs = None\n\n        return combined_hist\n\n\n    def save(self,\n             file: str | None = None,\n             folder: str | None = None,\n             save_analysis: bool = True,\n             save_components: bool = False\n             ) -&gt; None:\n        '''\n        Function to save the simulation history to a csv file in a given folder.\n        Additionally, an analysis of the runs can be saved if the save_analysis is enabled.\n        The environment and agent used can be saved in the saved folder by enabling the 'save_component' parameter.\n\n        Parameters\n        ----------\n        file : str, optional\n            The name of the file the simulation histories will be saved to.\n            If it is not provided, it will be by default \"Simulations-&lt;env_name&gt;-n_&lt;sim_count&gt;-&lt;sim_start_timestamp&gt;-horizon_&lt;max_sim_length&gt;.csv\"\n        folder : str, optional\n            Folder to save the simulation histories to.\n            If the folder name is not provided the current folder will be used.\n        save_analysis : bool, default=True\n            Whether to save an additional csv file with an analysis of the runs of the simulation.\n            It will contain the amount of steps taken, the amount of extra steps compared to optimality, the discounted rewards and the ratio between optimal trajectory and the steps taken.\n            The means and standard deviations of all the runs are also computed.\n            The file will have the same name as the simulation history file with an additional '-analysis' tag at the end.\n        save_components : bool, default=False\n            Whether or not to save the environment and agent along with the simulation histories in the given folder.\n        '''\n        assert (self.environment is not None) and (self.agent is not None), \"Function not available, the agent and/or the environment is not set.\"\n\n        # Handle file name\n        if file is None:\n            env_name = f's_' + '_'.join([str(axis_shape) for axis_shape in self.environment_shape])\n            file = f'Simulations-{env_name}-n_{self.n}-{self.timestamps[0][0].strftime(\"%Y%m%d_%H%M%S\")}-horizon_{len(self.positions)}.csv'\n\n        if not file.endswith('.csv'):\n            file += '.csv'\n\n        # Handle folder\n        if folder is None:\n            folder = './'\n\n        if '/' not in folder:\n            folder = './' + folder\n\n        if not os.path.exists(folder):\n            os.mkdir(folder)\n\n        if not folder.endswith('/'):\n            folder += '/'\n\n        # Save components if requested\n        if save_components:\n            if (self.environment.saved_at is None) or (folder not in self.environment.saved_at):\n                self.environment.save(folder=folder)\n\n            if (self.agent.saved_at is None) or (folder not in self.agent.saved_at):\n                self.agent.save(folder=folder)\n\n        # Create csv file\n        combined_df = pd.concat(self.simulation_dfs)\n\n        # timestamps information\n        simulation_lengths = np.array([len(df) for df in self.simulation_dfs])\n        timestamps_column = [None] * len(combined_df)\n        for n_start, run_timestamps in self.timestamps.items():\n            i_start = np.sum(simulation_lengths[:n_start])\n            for ts_i, ts in enumerate(run_timestamps):\n                timestamps_column[i_start + ts_i] = (ts.strftime('%Y%m%d_%H%M%S%f') if ts_i == 0 else ts.strftime('%H%M%S%f'))\n        combined_df['timestamps'] = timestamps_column\n\n        # Adding other useful info\n        padding = [None] * len(combined_df)\n        combined_df['horizon'] = [self.horizon] + padding[:-1]\n        combined_df['reward_discount'] = [self.reward_discount] + padding[:-1]\n\n        environment_info = [\n            self.environment.name,\n            self.environment.saved_at,\n            str(self.environment_dimensions), # int\n            '_'.join(str(axis_size) for axis_size in self.environment_shape),\n            '_'.join(str(axis_position) for axis_position in self.environment_source_position),\n            str(self.environment_source_radius), # float\n            '' if (self.environment_layer_labels is None) else '&amp;'.join(self.environment_layer_labels) # Using '&amp;' as splitter as '_' could be used in the labels themselves\n        ]\n        combined_df['environment'] = (environment_info + padding[:-len(environment_info)])\n\n        # Converting the thresholds array to a string to be saved\n        thresholds_string = ''\n        if len(self.agent_thresholds.shape) == 2:\n            thresholds_string = '&amp;'.join(['_'.join([str(item) for item in row]) for row_i, row in enumerate(self.agent_thresholds[:,1:-1])]) # Using '&amp;' as layer splitter as '-' can be used for negative thresholds\n        else:\n            thresholds_string = '_'.join([str(item) for item in self.agent_thresholds])\n\n        agent_info = [\n            self.agent.name,\n            self.agent.class_name,\n            self.agent.saved_at,\n            thresholds_string\n        ]\n        combined_df['agent'] = (agent_info + padding[:-len(agent_info)])\n\n        # Saving csv\n        combined_df.to_csv(folder + file, index=False)\n\n        print(f'Simulations saved to: {folder + file}')\n\n        if save_analysis:\n            runs_analysis_file_name = file.replace('.csv', '-runs_analysis.csv')\n            self.runs_analysis_df.to_csv(folder + runs_analysis_file_name)\n            print(f\"Simulation's runs analysis saved to: {folder + runs_analysis_file_name}\")\n\n            general_analysis_file_name = file.replace('.csv', '-general_analysis.csv')\n            self.general_analysis_df.to_csv(folder + general_analysis_file_name)\n            print(f\"Simulation's general analysis saved to: {folder + general_analysis_file_name}\")\n\n\n    @classmethod\n    def load_from_file(cls,\n                       file: str,\n                       environment: bool | Environment = False,\n                       agent: bool | Agent = False\n                       ) -&gt; 'SimulationHistory':\n        return cls.load(file, environment, agent)\n\n\n    @classmethod\n    def load(cls,\n             file: str,\n             environment: bool | Environment = False,\n             agent: bool | Agent = False\n             ) -&gt; 'SimulationHistory':\n        '''\n        Function to load the simulation history from a file.\n        This can be useful to use the plot functions on the simulations saved in such file.\n\n        The environment and agent can provided as a backup in the case they cannot be loaded from the file.\n\n        Parameters\n        ----------\n        file : str\n            A file (with the path) of the simulation histories csv. (the analysis file cannot be used for this)\n        environment : bool or Environment, default=False\n            If set to True, it will try to load the environment that was used for the simulation (if the save path is available).\n            Or, an environment instance to be linked with the simulation history object.\n        agent : bool or Agent, default=False\n            If set to True, it will try to load the agent that was used for the simulation (if the save path is available).\n            An agent instance to be linked with the simulation history object.\n\n        Returns\n        -------\n        hist : SimulationHistory\n            The loaded instance of a simulation history object.\n        '''\n        # Retrieving columns\n        with open(file, 'r') as f:\n            header = f.readline()\n        columns = header.replace('\\n','').split(',')\n\n        # Setting the datatypes of columns\n        column_dtypes = {col: float for col in columns}\n        column_dtypes['time'] = int\n        if 'layer' in columns:\n            column_dtypes['layer'] = int\n        column_dtypes['timestamps'] = str\n        column_dtypes['environment'] = str\n        column_dtypes['agent'] = str\n\n        # Retrieving the combined dataframe\n        combined_df = pd.read_csv(file, dtype=column_dtypes)\n\n        # Retrieving horizon and reward discount\n        horizon = int(combined_df['horizon'][0])\n        reward_discount = combined_df['reward_discount'][0]\n\n        # Retrieving environment\n        if (not isinstance(environment, Environment)) and (environment == True):\n            environment_name = combined_df['environment'][0]\n            environment_path = combined_df['environment'][1]\n\n            environment_path_check = (environment_path is not None) and (not np.isnan(environment_path))\n            assert environment_path_check, \"Environment was not saved at the time of the saving of the simulation history. Input an environment to the environment parameter or toggle the parameter to False.\"\n\n            try:\n                environment = Environment.load(environment_path)\n            except:\n                print(f'Failed to retrieve \"{environment_name}\" environment from memory')\n\n        # Retrieving agent\n        if (not isinstance(agent, Agent)) and (agent == True):\n            agent_name = combined_df['environment'][0]\n            agent_class = combined_df['environment'][1]\n            agent_path = combined_df['environment'][2]\n\n            agent_path_check = (agent_path is not None) and (not np.isnan(agent_path))\n            assert agent_path_check, \"Agent was not saved at the time of the saving of the simulation history. Input an agent to the agent parameter or toggle the parameter to False.\"\n\n            try:\n                class_instance = None\n                for (class_name, class_obj) in inspect.getmembers(sys.modules[__name__], inspect.isclass):\n                    if class_name == agent_class:\n                        class_instance = class_obj\n                        break\n                agent = class_instance.load(combined_df['agent'][2])\n            except:\n                print(f'Failed to retrieve \"{agent_name}\" agent from memory')\n\n        # Other attributes\n        environment_dimensions = int(combined_df['environment'][2])\n        environment_shape = tuple([int(axis_shape) for axis_shape in combined_df['environment'][3].split('_')])\n        environment_source_position = np.array([float(pos_axis) for pos_axis in combined_df['environment'][4].split('_')])\n        environment_source_radius = float(combined_df['environment'][5])\n        layer_entery = combined_df['environment'][6]\n        environment_layer_labels = (None if ((not isinstance(layer_entery, str)) or (len(layer_entery) == 0)) else layer_entery.split('&amp;'))\n\n        # Processing the threshold string\n        thresholds_string = str(combined_df['agent'][3])\n        if '&amp;' in thresholds_string:\n            rows_thresholds_string = thresholds_string.split('&amp;')\n            layer_thresholds = []\n            for row in rows_thresholds_string:\n                layer_thresholds.append(np.array(row.split('_')).astype(float))\n            agent_thresholds = np.array(layer_thresholds)\n\n        else:\n            agent_thresholds = np.array(np.array(thresholds_string.split('_')).astype(float))\n\n        # Columns to retrieve\n        columns = [col for col in columns if col not in ['reward_discount', 'environment', 'agent']]\n\n        # Checking how many dimensions there are\n        has_layers = (((len(columns) - 5) % 2) == 1)\n        dimensions = int((len(columns) - 5) / 2)\n\n        # Recreation of list of simulations\n        sim_start_rows = np.argwhere(combined_df[['reached_source']].isnull())[1:,0]\n\n        simulation_arrays = np.split(combined_df[columns].to_numpy(), sim_start_rows)\n        simulation_dfs = [pd.DataFrame(sim_array, columns=columns) for sim_array in simulation_arrays]\n\n        # Making a combined numpy array with all the simulations\n        sizes = np.array([len(sim_array) for sim_array in simulation_arrays])\n        max_length = sizes.max()\n        paddings = max_length - sizes\n\n        padded_simulation_arrays = [np.pad(sim_arr, ((0,pad),(0,0)), constant_values=-1) for sim_arr, pad in zip(simulation_arrays, paddings)]\n        all_simulation_arrays = np.array(padded_simulation_arrays).transpose((1,0,2))\n\n        # Timeshift\n        time_shift = all_simulation_arrays[0,:,0].astype(int)\n\n        # Gathering start states\n        start_points = all_simulation_arrays[0,:,1:(1+dimensions)].astype(int)\n\n        # Recreating action, state and observations\n        positions = all_simulation_arrays[1:, :, 1:(1+dimensions)]\n        actions = all_simulation_arrays[1:, :, (1+dimensions):((1+dimensions) + (1 if has_layers else 0) + dimensions)]\n        observations = all_simulation_arrays[1:, :, ((1+dimensions) + (1 if has_layers else 0) + dimensions)]\n        reached_source = np.array([(df['reached_source'][len(df)-1] == 1) for df in simulation_dfs])\n        done_at_step = np.where((sizes-1 &lt; horizon), sizes-1, -1)\n\n        # Building SimulationHistory instance\n        hist = cls.__new__(cls)\n\n        hist.n = len(start_points)\n        hist.environment = environment.cpu_version if isinstance(environment, Environment) else None\n        hist.agent = agent.cpu_version if isinstance(agent, Agent) else None\n        hist.time_shift = time_shift\n        hist.horizon = horizon\n        hist.reward_discount = reward_discount\n\n        hist.start_points = start_points\n        hist._running_sims = None\n\n        hist.positions = [*positions]\n        hist.actions = [*actions]\n        hist.observations = [*observations]\n        hist.reached_source = reached_source\n        hist.done_at_step = done_at_step\n\n        # Reading timestamps\n        timestamp_column = combined_df['timestamps']\n        timestamp_groups = np.concatenate([np.argwhere(timestamp_column.str.contains('_') == True)[:,0], [len(timestamp_column)]])\n        timestamps = {}\n\n        # Reading each group of timestamps (representing of each run)\n        for group_i, (group_start, group_end) in enumerate(zip(timestamp_groups[:-1], timestamp_groups[1:])):\n            timestamp_group = timestamp_column[group_start:group_end]\n\n            # Initial read of the group\n            first_timestamp = timestamp_group.iloc[0]\n            timestamp_day = first_timestamp[:9]\n            timestamp_count = np.sum(timestamp_group.notna())\n            timestamp_string_list = timestamp_group[:timestamp_count].to_list()\n\n            day_delta = timedelta(days=0)\n            timestamp_list = [datetime.strptime(timestamp_string_list[0], '%Y%m%d_%H%M%S%f')]\n\n            # Reading each timestamp of the list\n            for timestamp_string in timestamp_string_list[1:]:\n                timestamp_string = timestamp_day + str(timestamp_string)\n                timestamp = datetime.strptime(timestamp_string, '%Y%m%d_%H%M%S%f') + day_delta\n\n                # If timestamp is smaller than the previous one, it means it is a new day and the day_delta has to be increased\n                if timestamp &lt; timestamp_list[-1]:\n                    day_delta += timedelta(days=1)\n                    timestamp += timedelta(days=1)\n\n                timestamp_list.append(timestamp)\n\n            # Adding the timestamps to the general dictionary\n            associate_run_i = np.argwhere(np.concatenate([[0], sim_start_rows]) == group_start)[0,0]\n            timestamps[associate_run_i] = timestamp_list\n\n        # Warn if no timestamps were found\n        if len(timestamps) == 0:\n            print('[Warning] No timestamps were found in the loaded simulation history...')\n\n        hist.timestamps = timestamps\n\n        # Other attributes\n        hist.environment_dimensions = environment_dimensions\n        hist.environment_shape = environment_shape\n        hist.environment_source_position = environment_source_position\n        hist.environment_source_radius = environment_source_radius\n        hist.environment_layer_labels = environment_layer_labels\n        hist.agent_thresholds = agent_thresholds\n\n        # Saving simulation dfs back\n        hist._simulation_dfs = simulation_dfs\n\n        return hist\n\n\n    def plot(self,\n             sim_id: int = 0,\n             ax: plt.Axes | None = None\n             ) -&gt; None:\n        '''\n        Function to plot a the trajectory of a given simulation.\n        An ax can be use to plot it on.\n\n        Parameters\n        ----------\n        sim_id : int, default=0\n            The id of the simulation to plot.\n        ax : plt.Axes, optional\n            The ax on which to plot the path. (If not provided, a new axis will be created)\n        '''\n        # TODO: Setup 3D plotting\n        assert self.environment_dimensions == 2, \"Plotting function only available for 2D environments for now...\"\n\n        # Generate ax is not provided\n        if ax is None:\n            _, ax = plt.subplots(figsize=(18,3))\n\n        # Retrieving sim\n        sim = self.simulation_dfs[sim_id]\n\n        # Plot setup\n        env_shape = self.environment_shape\n        ax.imshow(np.zeros(self.environment_shape), cmap='Greys', zorder=-100)\n        ax.set_xlim(0, env_shape[1])\n        ax.set_ylim(env_shape[0], 0)\n\n        # Start\n        start_coord = sim[['x', 'y']].to_numpy()[0]\n        ax.scatter(start_coord[0], start_coord[1], c='green', label='Start')\n\n        # Source circle\n        goal_circle = Circle(self.environment_source_position[::-1], self.environment_source_radius, color='r', fill=False, label='Source')\n        ax.add_patch(goal_circle)\n\n        # Until step\n        seq = sim[['x','y']].to_numpy()\n\n        # Path\n        ax.plot(seq[:,0], seq[:,1], zorder=-1, c='black', label='Path')\n\n        # Layer observations\n        if self.environment_layer_labels is not None:\n            obs_layer = sim[['layer']][1:].to_numpy()\n            layer_colors = np.array(list(colors.TABLEAU_COLORS.values()))\n\n            for layer_i, layer_label in enumerate(self.environment_layer_labels[1:]):\n                layer_i += 1\n                layer_mask = (obs_layer == layer_i)[:,0] # Reshaping to a single vector and not an n by 1 array\n                ax.scatter(seq[1:][layer_mask,0], seq[1:][layer_mask,1], # X, Y\n                           marker='x',\n                           color=layer_colors[(layer_i-1) % len(layer_colors)], # Looping over the colors in case there are more layers than colors\n                           zorder=2,\n                           label=layer_label)\n\n        # Process odor cues\n        odor_cues = sim['o'][1:].to_numpy()\n        observation_ids = None\n        if (self.environment_layer_labels is not None) and len(self.agent_thresholds.shape) == 2:\n            layer_ids = sim[['layer']][1:].to_numpy()\n            action_layer_thresholds = self.agent_thresholds[layer_ids]\n            observation_ids = np.argwhere((odor_cues[:,None] &gt;= action_layer_thresholds[:,:-1]) &amp; (odor_cues[:,None] &lt; action_layer_thresholds[:,1:]))[:,1]\n        else:\n            # Setting observation ids\n            observation_ids = np.argwhere((odor_cues[:,None] &gt;= self.agent_thresholds[:-1][None,:]) &amp; (odor_cues[:,None] &lt; self.agent_thresholds[1:][None,:]))[:,1]\n\n        # Check whether the odor detection is binary or by level\n        odor_bins = self.agent_thresholds.shape[-1] - 1\n        if odor_bins &gt; 2:\n            odor_levels = np.arange(odor_bins - 1) + 1\n            for level in odor_levels:\n                cues_at_level = (observation_ids == level)\n                ax.scatter(seq[1:][cues_at_level,0], seq[1:][cues_at_level,1],\n                           zorder=1,\n                           alpha=(level / odor_bins),\n                           label=f'Sensed level {level}')\n        else:\n            something_sensed = (observation_ids == 1)\n            ax.scatter(seq[1:][something_sensed,0], seq[1:][something_sensed,1],\n                       zorder=1,\n                       label='Something observed')\n\n        # Generate legend\n        ax.legend()\n\n\n    def plot_runtimes(self,\n                      ax: plt.Axes | None = None\n                      ) -&gt; None:\n        '''\n        Function to plot the runtimes over the iterations.\n\n        Parameters\n        ----------\n        ax : plt.Axes, optional\n            The ax on which to plot the path. (If not provided, a new axis will be created)\n        '''\n        # Generate ax is not provided\n        if ax is None:\n            _, ax = plt.subplots(figsize=(18,3))\n\n        # Computing differences and plotting\n        x_start = 0\n        for i, (_, consecutive_timestamps) in enumerate(self.timestamps.items()):\n            time_differences_ms = np.array([t_diff.total_seconds() for t_diff in np.diff(consecutive_timestamps)]) / 1000\n            time_differences_count = len(time_differences_ms)\n            xs = x_start + np.arange(time_differences_count)\n\n            ax.plot(xs, time_differences_ms, label=f'Simulation {i}')\n\n            x_start += time_differences_count\n\n        # Axes\n        ax.set_xlabel('Iteration')\n        ax.set_ylabel('Runtime (ms)')\n\n\n    def plot_successes(self,\n                       ax: plt.Axes | None = None\n                       ) -&gt; None:\n        '''\n        Function to plot a 2D map of whether a given starting point was successfull or not (and whether it died early).\n\n        Parameters\n        ----------\n        ax : plt.Axes, optional\n            The ax on which to plot the path. (If not provided, a new axis will be created)\n        '''\n        assert self.environment_dimensions == 2, \"Only implemented for 2D environments...\"\n\n        # Generate ax is not provided\n        if ax is None:\n            _, ax = plt.subplots(figsize=(18,3))\n\n        # Setting up an empty grid of the starting points\n        start_points_grid = np.zeros(self.environment_shape)\n\n        # Compute the successful, failed and the ones that reached the horizon\n        success_points = self.start_points[self.successful_simulation]\n        failed_points = self.start_points[~self.successful_simulation]\n        failed_not_at_horizon_points = self.start_points[~self.successful_simulation &amp; ~self.simulations_at_horizon]\n\n        start_points_grid[failed_points[:,0], failed_points[:,1]] = -1\n        start_points_grid[success_points[:,0], success_points[:,1]] = 1\n\n        ax.imshow(start_points_grid, cmap='RdBu')\n\n        # The crosses where the points did not reach the horizon\n        ax.scatter(failed_not_at_horizon_points[:,1], failed_not_at_horizon_points[:,0], marker='x', color='black', s=10, label='Died early')\n        ax.legend()\n</code></pre>"},{"location":"reference/simulation/#olfactory_navigation.simulation.SimulationHistory.done_count","title":"<code>done_count</code>  <code>property</code>","text":"<p>Returns how many simulations are terminated (whether they reached the source or not).</p>"},{"location":"reference/simulation/#olfactory_navigation.simulation.SimulationHistory.general_analysis_df","title":"<code>general_analysis_df</code>  <code>property</code>","text":"<p>A Pandas DataFrame analyzing the results of the simulations. Summarizing the performance of all the simulations with the following metrics:</p> <ul> <li>converged:           Whether or not the simulation reached the source</li> <li>reached_horizon:     Whether the failed simulation reached to horizon</li> <li>steps_taken:         The amount of steps the agent took to reach the source, (horizon if the simulation did not reach the source)</li> <li>discounted_rewards:  The discounted reward received by the agent over the course of the simulation</li> <li>extra_steps:         The amount of extra steps compared to the optimal trajectory</li> <li>t_min_over_t:        Normalized version of the extra steps measure, where it tends to 1 the least amount of time the agent took to reach the source compared to an optimal trajectory.</li> </ul> <p>For the measures (converged, steps_taken, discounted_rewards, extra_steps, t_min_over_t), the average and standard deviations are computed in rows at the top.</p>"},{"location":"reference/simulation/#olfactory_navigation.simulation.SimulationHistory.runs_analysis_df","title":"<code>runs_analysis_df</code>  <code>property</code>","text":"<p>A Pandas DataFrame analyzing the results of the simulations. It aggregates the simulations in single rows, recording:</p> <ul> <li>:              The starting positions at the given axis <li>optimal_steps_count: The minimal amount of steps to reach the source</li> <li>converged:           Whether or not the simulation reached the source</li> <li>reached_horizon:     Whether the failed simulation reached to horizon</li> <li>steps_taken:         The amount of steps the agent took to reach the source, (horizon if the simulation did not reach the source)</li> <li>discounted_rewards:  The discounted reward received by the agent over the course of the simulation</li> <li>extra_steps:         The amount of extra steps compared to the optimal trajectory</li> <li>t_min_over_t:        Normalized version of the extra steps measure, where it tends to 1 the least amount of time the agent took to reach the source compared to an optimal trajectory.</li>"},{"location":"reference/simulation/#olfactory_navigation.simulation.SimulationHistory.simulation_dfs","title":"<code>simulation_dfs</code>  <code>property</code>","text":"<p>A list of the pandas DataFrame where each dataframe is a single simulation history. Each row is a different time instant of simulation process with each column being:</p> <ul> <li>time (of the simulation data)</li> <li>[position] (z,) y, x  OR  x0, x1, ... xn</li> <li>(layer)</li> <li>[movement] (dz,) dy, dx  OR  dx0, dx1, ... dxn</li> <li>o (pure, not thresholded)</li> <li>reached_source (boolean)</li> </ul>"},{"location":"reference/simulation/#olfactory_navigation.simulation.SimulationHistory.simulations_at_horizon","title":"<code>simulations_at_horizon</code>  <code>property</code>","text":"<p>Returns a boolean array of which simulations reached the horizon.</p>"},{"location":"reference/simulation/#olfactory_navigation.simulation.SimulationHistory.start_time","title":"<code>start_time</code>  <code>property</code>","text":"<p>The time at which the first simulation was started.</p>"},{"location":"reference/simulation/#olfactory_navigation.simulation.SimulationHistory.success_count","title":"<code>success_count</code>  <code>property</code>","text":"<p>Returns how many simulations reached the source.</p>"},{"location":"reference/simulation/#olfactory_navigation.simulation.SimulationHistory.summary","title":"<code>summary</code>  <code>property</code>","text":"<p>A string summarizing the performances of all the simulations. The metrics used are averages of:</p> <ul> <li>Step count</li> <li>Extra steps</li> <li>Discounted rewards</li> <li>Tmin / T</li> </ul> <p>Along with the respective the standard deviations and equally for only for the successful simulations.</p>"},{"location":"reference/simulation/#olfactory_navigation.simulation.SimulationHistory.add_step","title":"<code>add_step(actions, next_positions, observations, reached_source, interupt)</code>","text":"<p>Function to add a step in the simulation history.</p> <p>Parameters:</p> Name Type Description Default <code>actions</code> <code>ndarray</code> <p>The actions that were taken by the agents.</p> required <code>next_positions</code> <code>ndarray</code> <p>The positions that were reached by the agents after having taken actions.</p> required <code>observations</code> <code>ndarray</code> <p>The observations the agents receive after having taken actions.</p> required <code>reached_source</code> <code>ndarray</code> <p>A boolean array of whether each agent has reached the source or not.</p> required <code>interupt</code> <code>ndarray</code> <p>A boolean array of whether each agent has to be terminated even if it hasnt reached the source yet.</p> required Source code in <code>olfactory_navigation/simulation.py</code> <pre><code>def add_step(self,\n             actions: np.ndarray,\n             next_positions: np.ndarray,\n             observations: np.ndarray,\n             reached_source: np.ndarray,\n             interupt: np.ndarray\n             ) -&gt; None:\n    '''\n    Function to add a step in the simulation history.\n\n    Parameters\n    ----------\n    actions : np.ndarray\n        The actions that were taken by the agents.\n    next_positions : np.ndarray\n        The positions that were reached by the agents after having taken actions.\n    observations : np.ndarray\n        The observations the agents receive after having taken actions.\n    reached_source : np.ndarray\n        A boolean array of whether each agent has reached the source or not.\n    interupt : np.ndarray\n        A boolean array of whether each agent has to be terminated even if it hasnt reached the source yet.\n    '''\n    self._simulation_dfs = None\n\n    # Time tracking\n    self.timestamps[0].append(datetime.now())\n\n    # Check if environment if layered and/or 3D\n    layered = 0 if self.environment_layer_labels is None else 1\n\n    # Handle case cupy arrays are provided\n    if gpu_support:\n        actions = actions if cp.get_array_module(actions) == np else cp.asnumpy(actions)\n        next_positions = next_positions if cp.get_array_module(next_positions) == np else cp.asnumpy(next_positions)\n        observations = observations if cp.get_array_module(observations) == np else cp.asnumpy(observations)\n        reached_source = reached_source if cp.get_array_module(reached_source) == np else cp.asnumpy(reached_source)\n        interupt = interupt if cp.get_array_module(interupt) == np else cp.asnumpy(interupt)\n\n    # Actions tracking\n    action_all_sims = np.full((self.n, (layered + self.environment_dimensions)), fill_value=-1)\n    action_all_sims[self._running_sims] = actions\n    self.actions.append(action_all_sims)\n\n    # Next states tracking\n    next_position_all_sims = np.full((self.n, self.environment_dimensions), fill_value=-1)\n    next_position_all_sims[self._running_sims] = next_positions\n    self.positions.append(next_position_all_sims)\n\n    # Observation tracking\n    observation_all_sims = np.full((self.n,), fill_value=-1, dtype=float)\n    observation_all_sims[self._running_sims] = observations\n    self.observations.append(observation_all_sims)\n\n    # Recording at which step the simulation is done if it is done and whether it reached the source\n    self.done_at_step[self._running_sims[reached_source | interupt]] = len(self.positions)\n    self.reached_source[self._running_sims[reached_source]] = True\n\n    # Updating the list of running sims\n    self._running_sims = self._running_sims[~reached_source &amp; ~interupt]\n</code></pre>"},{"location":"reference/simulation/#olfactory_navigation.simulation.SimulationHistory.compute_distance_to_source","title":"<code>compute_distance_to_source()</code>","text":"<p>Function to compute the optimal distance to the source of each starting point according to the optimal_distance_metric attribute.</p> <p>Returns:</p> Name Type Description <code>distance</code> <code>ndarray</code> <p>The optimal distances to the source point.</p> Source code in <code>olfactory_navigation/simulation.py</code> <pre><code>def compute_distance_to_source(self) -&gt; np.ndarray:\n    '''\n    Function to compute the optimal distance to the source of each starting point according to the optimal_distance_metric attribute.\n\n    Returns\n    -------\n    distance : np.ndarray\n        The optimal distances to the source point.\n    '''\n    point = self.start_points\n\n    # Handling the case we have a single point\n    is_single_point = (len(point.shape) == 1)\n    if is_single_point:\n        point = point[None,:]\n\n    # Computing dist\n    dist = None\n    # if self.optimal_distance_metric == 'manhattan': # TODO Allow for other metrics to be used\n    dist = np.sum(np.abs(self.environment_source_position[None,:] - point), axis=-1) - self.environment_source_radius\n\n    if dist is None: # Meaning it was not computed\n        raise NotImplementedError('This distance metric has not yet been implemented')\n\n    return float(dist[0]) if is_single_point else dist\n</code></pre>"},{"location":"reference/simulation/#olfactory_navigation.simulation.SimulationHistory.load","title":"<code>load(file, environment=False, agent=False)</code>  <code>classmethod</code>","text":"<p>Function to load the simulation history from a file. This can be useful to use the plot functions on the simulations saved in such file.</p> <p>The environment and agent can provided as a backup in the case they cannot be loaded from the file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>A file (with the path) of the simulation histories csv. (the analysis file cannot be used for this)</p> required <code>environment</code> <code>bool or Environment</code> <p>If set to True, it will try to load the environment that was used for the simulation (if the save path is available). Or, an environment instance to be linked with the simulation history object.</p> <code>False</code> <code>agent</code> <code>bool or Agent</code> <p>If set to True, it will try to load the agent that was used for the simulation (if the save path is available). An agent instance to be linked with the simulation history object.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>hist</code> <code>SimulationHistory</code> <p>The loaded instance of a simulation history object.</p> Source code in <code>olfactory_navigation/simulation.py</code> <pre><code>@classmethod\ndef load(cls,\n         file: str,\n         environment: bool | Environment = False,\n         agent: bool | Agent = False\n         ) -&gt; 'SimulationHistory':\n    '''\n    Function to load the simulation history from a file.\n    This can be useful to use the plot functions on the simulations saved in such file.\n\n    The environment and agent can provided as a backup in the case they cannot be loaded from the file.\n\n    Parameters\n    ----------\n    file : str\n        A file (with the path) of the simulation histories csv. (the analysis file cannot be used for this)\n    environment : bool or Environment, default=False\n        If set to True, it will try to load the environment that was used for the simulation (if the save path is available).\n        Or, an environment instance to be linked with the simulation history object.\n    agent : bool or Agent, default=False\n        If set to True, it will try to load the agent that was used for the simulation (if the save path is available).\n        An agent instance to be linked with the simulation history object.\n\n    Returns\n    -------\n    hist : SimulationHistory\n        The loaded instance of a simulation history object.\n    '''\n    # Retrieving columns\n    with open(file, 'r') as f:\n        header = f.readline()\n    columns = header.replace('\\n','').split(',')\n\n    # Setting the datatypes of columns\n    column_dtypes = {col: float for col in columns}\n    column_dtypes['time'] = int\n    if 'layer' in columns:\n        column_dtypes['layer'] = int\n    column_dtypes['timestamps'] = str\n    column_dtypes['environment'] = str\n    column_dtypes['agent'] = str\n\n    # Retrieving the combined dataframe\n    combined_df = pd.read_csv(file, dtype=column_dtypes)\n\n    # Retrieving horizon and reward discount\n    horizon = int(combined_df['horizon'][0])\n    reward_discount = combined_df['reward_discount'][0]\n\n    # Retrieving environment\n    if (not isinstance(environment, Environment)) and (environment == True):\n        environment_name = combined_df['environment'][0]\n        environment_path = combined_df['environment'][1]\n\n        environment_path_check = (environment_path is not None) and (not np.isnan(environment_path))\n        assert environment_path_check, \"Environment was not saved at the time of the saving of the simulation history. Input an environment to the environment parameter or toggle the parameter to False.\"\n\n        try:\n            environment = Environment.load(environment_path)\n        except:\n            print(f'Failed to retrieve \"{environment_name}\" environment from memory')\n\n    # Retrieving agent\n    if (not isinstance(agent, Agent)) and (agent == True):\n        agent_name = combined_df['environment'][0]\n        agent_class = combined_df['environment'][1]\n        agent_path = combined_df['environment'][2]\n\n        agent_path_check = (agent_path is not None) and (not np.isnan(agent_path))\n        assert agent_path_check, \"Agent was not saved at the time of the saving of the simulation history. Input an agent to the agent parameter or toggle the parameter to False.\"\n\n        try:\n            class_instance = None\n            for (class_name, class_obj) in inspect.getmembers(sys.modules[__name__], inspect.isclass):\n                if class_name == agent_class:\n                    class_instance = class_obj\n                    break\n            agent = class_instance.load(combined_df['agent'][2])\n        except:\n            print(f'Failed to retrieve \"{agent_name}\" agent from memory')\n\n    # Other attributes\n    environment_dimensions = int(combined_df['environment'][2])\n    environment_shape = tuple([int(axis_shape) for axis_shape in combined_df['environment'][3].split('_')])\n    environment_source_position = np.array([float(pos_axis) for pos_axis in combined_df['environment'][4].split('_')])\n    environment_source_radius = float(combined_df['environment'][5])\n    layer_entery = combined_df['environment'][6]\n    environment_layer_labels = (None if ((not isinstance(layer_entery, str)) or (len(layer_entery) == 0)) else layer_entery.split('&amp;'))\n\n    # Processing the threshold string\n    thresholds_string = str(combined_df['agent'][3])\n    if '&amp;' in thresholds_string:\n        rows_thresholds_string = thresholds_string.split('&amp;')\n        layer_thresholds = []\n        for row in rows_thresholds_string:\n            layer_thresholds.append(np.array(row.split('_')).astype(float))\n        agent_thresholds = np.array(layer_thresholds)\n\n    else:\n        agent_thresholds = np.array(np.array(thresholds_string.split('_')).astype(float))\n\n    # Columns to retrieve\n    columns = [col for col in columns if col not in ['reward_discount', 'environment', 'agent']]\n\n    # Checking how many dimensions there are\n    has_layers = (((len(columns) - 5) % 2) == 1)\n    dimensions = int((len(columns) - 5) / 2)\n\n    # Recreation of list of simulations\n    sim_start_rows = np.argwhere(combined_df[['reached_source']].isnull())[1:,0]\n\n    simulation_arrays = np.split(combined_df[columns].to_numpy(), sim_start_rows)\n    simulation_dfs = [pd.DataFrame(sim_array, columns=columns) for sim_array in simulation_arrays]\n\n    # Making a combined numpy array with all the simulations\n    sizes = np.array([len(sim_array) for sim_array in simulation_arrays])\n    max_length = sizes.max()\n    paddings = max_length - sizes\n\n    padded_simulation_arrays = [np.pad(sim_arr, ((0,pad),(0,0)), constant_values=-1) for sim_arr, pad in zip(simulation_arrays, paddings)]\n    all_simulation_arrays = np.array(padded_simulation_arrays).transpose((1,0,2))\n\n    # Timeshift\n    time_shift = all_simulation_arrays[0,:,0].astype(int)\n\n    # Gathering start states\n    start_points = all_simulation_arrays[0,:,1:(1+dimensions)].astype(int)\n\n    # Recreating action, state and observations\n    positions = all_simulation_arrays[1:, :, 1:(1+dimensions)]\n    actions = all_simulation_arrays[1:, :, (1+dimensions):((1+dimensions) + (1 if has_layers else 0) + dimensions)]\n    observations = all_simulation_arrays[1:, :, ((1+dimensions) + (1 if has_layers else 0) + dimensions)]\n    reached_source = np.array([(df['reached_source'][len(df)-1] == 1) for df in simulation_dfs])\n    done_at_step = np.where((sizes-1 &lt; horizon), sizes-1, -1)\n\n    # Building SimulationHistory instance\n    hist = cls.__new__(cls)\n\n    hist.n = len(start_points)\n    hist.environment = environment.cpu_version if isinstance(environment, Environment) else None\n    hist.agent = agent.cpu_version if isinstance(agent, Agent) else None\n    hist.time_shift = time_shift\n    hist.horizon = horizon\n    hist.reward_discount = reward_discount\n\n    hist.start_points = start_points\n    hist._running_sims = None\n\n    hist.positions = [*positions]\n    hist.actions = [*actions]\n    hist.observations = [*observations]\n    hist.reached_source = reached_source\n    hist.done_at_step = done_at_step\n\n    # Reading timestamps\n    timestamp_column = combined_df['timestamps']\n    timestamp_groups = np.concatenate([np.argwhere(timestamp_column.str.contains('_') == True)[:,0], [len(timestamp_column)]])\n    timestamps = {}\n\n    # Reading each group of timestamps (representing of each run)\n    for group_i, (group_start, group_end) in enumerate(zip(timestamp_groups[:-1], timestamp_groups[1:])):\n        timestamp_group = timestamp_column[group_start:group_end]\n\n        # Initial read of the group\n        first_timestamp = timestamp_group.iloc[0]\n        timestamp_day = first_timestamp[:9]\n        timestamp_count = np.sum(timestamp_group.notna())\n        timestamp_string_list = timestamp_group[:timestamp_count].to_list()\n\n        day_delta = timedelta(days=0)\n        timestamp_list = [datetime.strptime(timestamp_string_list[0], '%Y%m%d_%H%M%S%f')]\n\n        # Reading each timestamp of the list\n        for timestamp_string in timestamp_string_list[1:]:\n            timestamp_string = timestamp_day + str(timestamp_string)\n            timestamp = datetime.strptime(timestamp_string, '%Y%m%d_%H%M%S%f') + day_delta\n\n            # If timestamp is smaller than the previous one, it means it is a new day and the day_delta has to be increased\n            if timestamp &lt; timestamp_list[-1]:\n                day_delta += timedelta(days=1)\n                timestamp += timedelta(days=1)\n\n            timestamp_list.append(timestamp)\n\n        # Adding the timestamps to the general dictionary\n        associate_run_i = np.argwhere(np.concatenate([[0], sim_start_rows]) == group_start)[0,0]\n        timestamps[associate_run_i] = timestamp_list\n\n    # Warn if no timestamps were found\n    if len(timestamps) == 0:\n        print('[Warning] No timestamps were found in the loaded simulation history...')\n\n    hist.timestamps = timestamps\n\n    # Other attributes\n    hist.environment_dimensions = environment_dimensions\n    hist.environment_shape = environment_shape\n    hist.environment_source_position = environment_source_position\n    hist.environment_source_radius = environment_source_radius\n    hist.environment_layer_labels = environment_layer_labels\n    hist.agent_thresholds = agent_thresholds\n\n    # Saving simulation dfs back\n    hist._simulation_dfs = simulation_dfs\n\n    return hist\n</code></pre>"},{"location":"reference/simulation/#olfactory_navigation.simulation.SimulationHistory.plot","title":"<code>plot(sim_id=0, ax=None)</code>","text":"<p>Function to plot a the trajectory of a given simulation. An ax can be use to plot it on.</p> <p>Parameters:</p> Name Type Description Default <code>sim_id</code> <code>int</code> <p>The id of the simulation to plot.</p> <code>0</code> <code>ax</code> <code>Axes</code> <p>The ax on which to plot the path. (If not provided, a new axis will be created)</p> <code>None</code> Source code in <code>olfactory_navigation/simulation.py</code> <pre><code>def plot(self,\n         sim_id: int = 0,\n         ax: plt.Axes | None = None\n         ) -&gt; None:\n    '''\n    Function to plot a the trajectory of a given simulation.\n    An ax can be use to plot it on.\n\n    Parameters\n    ----------\n    sim_id : int, default=0\n        The id of the simulation to plot.\n    ax : plt.Axes, optional\n        The ax on which to plot the path. (If not provided, a new axis will be created)\n    '''\n    # TODO: Setup 3D plotting\n    assert self.environment_dimensions == 2, \"Plotting function only available for 2D environments for now...\"\n\n    # Generate ax is not provided\n    if ax is None:\n        _, ax = plt.subplots(figsize=(18,3))\n\n    # Retrieving sim\n    sim = self.simulation_dfs[sim_id]\n\n    # Plot setup\n    env_shape = self.environment_shape\n    ax.imshow(np.zeros(self.environment_shape), cmap='Greys', zorder=-100)\n    ax.set_xlim(0, env_shape[1])\n    ax.set_ylim(env_shape[0], 0)\n\n    # Start\n    start_coord = sim[['x', 'y']].to_numpy()[0]\n    ax.scatter(start_coord[0], start_coord[1], c='green', label='Start')\n\n    # Source circle\n    goal_circle = Circle(self.environment_source_position[::-1], self.environment_source_radius, color='r', fill=False, label='Source')\n    ax.add_patch(goal_circle)\n\n    # Until step\n    seq = sim[['x','y']].to_numpy()\n\n    # Path\n    ax.plot(seq[:,0], seq[:,1], zorder=-1, c='black', label='Path')\n\n    # Layer observations\n    if self.environment_layer_labels is not None:\n        obs_layer = sim[['layer']][1:].to_numpy()\n        layer_colors = np.array(list(colors.TABLEAU_COLORS.values()))\n\n        for layer_i, layer_label in enumerate(self.environment_layer_labels[1:]):\n            layer_i += 1\n            layer_mask = (obs_layer == layer_i)[:,0] # Reshaping to a single vector and not an n by 1 array\n            ax.scatter(seq[1:][layer_mask,0], seq[1:][layer_mask,1], # X, Y\n                       marker='x',\n                       color=layer_colors[(layer_i-1) % len(layer_colors)], # Looping over the colors in case there are more layers than colors\n                       zorder=2,\n                       label=layer_label)\n\n    # Process odor cues\n    odor_cues = sim['o'][1:].to_numpy()\n    observation_ids = None\n    if (self.environment_layer_labels is not None) and len(self.agent_thresholds.shape) == 2:\n        layer_ids = sim[['layer']][1:].to_numpy()\n        action_layer_thresholds = self.agent_thresholds[layer_ids]\n        observation_ids = np.argwhere((odor_cues[:,None] &gt;= action_layer_thresholds[:,:-1]) &amp; (odor_cues[:,None] &lt; action_layer_thresholds[:,1:]))[:,1]\n    else:\n        # Setting observation ids\n        observation_ids = np.argwhere((odor_cues[:,None] &gt;= self.agent_thresholds[:-1][None,:]) &amp; (odor_cues[:,None] &lt; self.agent_thresholds[1:][None,:]))[:,1]\n\n    # Check whether the odor detection is binary or by level\n    odor_bins = self.agent_thresholds.shape[-1] - 1\n    if odor_bins &gt; 2:\n        odor_levels = np.arange(odor_bins - 1) + 1\n        for level in odor_levels:\n            cues_at_level = (observation_ids == level)\n            ax.scatter(seq[1:][cues_at_level,0], seq[1:][cues_at_level,1],\n                       zorder=1,\n                       alpha=(level / odor_bins),\n                       label=f'Sensed level {level}')\n    else:\n        something_sensed = (observation_ids == 1)\n        ax.scatter(seq[1:][something_sensed,0], seq[1:][something_sensed,1],\n                   zorder=1,\n                   label='Something observed')\n\n    # Generate legend\n    ax.legend()\n</code></pre>"},{"location":"reference/simulation/#olfactory_navigation.simulation.SimulationHistory.plot_runtimes","title":"<code>plot_runtimes(ax=None)</code>","text":"<p>Function to plot the runtimes over the iterations.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The ax on which to plot the path. (If not provided, a new axis will be created)</p> <code>None</code> Source code in <code>olfactory_navigation/simulation.py</code> <pre><code>def plot_runtimes(self,\n                  ax: plt.Axes | None = None\n                  ) -&gt; None:\n    '''\n    Function to plot the runtimes over the iterations.\n\n    Parameters\n    ----------\n    ax : plt.Axes, optional\n        The ax on which to plot the path. (If not provided, a new axis will be created)\n    '''\n    # Generate ax is not provided\n    if ax is None:\n        _, ax = plt.subplots(figsize=(18,3))\n\n    # Computing differences and plotting\n    x_start = 0\n    for i, (_, consecutive_timestamps) in enumerate(self.timestamps.items()):\n        time_differences_ms = np.array([t_diff.total_seconds() for t_diff in np.diff(consecutive_timestamps)]) / 1000\n        time_differences_count = len(time_differences_ms)\n        xs = x_start + np.arange(time_differences_count)\n\n        ax.plot(xs, time_differences_ms, label=f'Simulation {i}')\n\n        x_start += time_differences_count\n\n    # Axes\n    ax.set_xlabel('Iteration')\n    ax.set_ylabel('Runtime (ms)')\n</code></pre>"},{"location":"reference/simulation/#olfactory_navigation.simulation.SimulationHistory.plot_successes","title":"<code>plot_successes(ax=None)</code>","text":"<p>Function to plot a 2D map of whether a given starting point was successfull or not (and whether it died early).</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The ax on which to plot the path. (If not provided, a new axis will be created)</p> <code>None</code> Source code in <code>olfactory_navigation/simulation.py</code> <pre><code>def plot_successes(self,\n                   ax: plt.Axes | None = None\n                   ) -&gt; None:\n    '''\n    Function to plot a 2D map of whether a given starting point was successfull or not (and whether it died early).\n\n    Parameters\n    ----------\n    ax : plt.Axes, optional\n        The ax on which to plot the path. (If not provided, a new axis will be created)\n    '''\n    assert self.environment_dimensions == 2, \"Only implemented for 2D environments...\"\n\n    # Generate ax is not provided\n    if ax is None:\n        _, ax = plt.subplots(figsize=(18,3))\n\n    # Setting up an empty grid of the starting points\n    start_points_grid = np.zeros(self.environment_shape)\n\n    # Compute the successful, failed and the ones that reached the horizon\n    success_points = self.start_points[self.successful_simulation]\n    failed_points = self.start_points[~self.successful_simulation]\n    failed_not_at_horizon_points = self.start_points[~self.successful_simulation &amp; ~self.simulations_at_horizon]\n\n    start_points_grid[failed_points[:,0], failed_points[:,1]] = -1\n    start_points_grid[success_points[:,0], success_points[:,1]] = 1\n\n    ax.imshow(start_points_grid, cmap='RdBu')\n\n    # The crosses where the points did not reach the horizon\n    ax.scatter(failed_not_at_horizon_points[:,1], failed_not_at_horizon_points[:,0], marker='x', color='black', s=10, label='Died early')\n    ax.legend()\n</code></pre>"},{"location":"reference/simulation/#olfactory_navigation.simulation.SimulationHistory.save","title":"<code>save(file=None, folder=None, save_analysis=True, save_components=False)</code>","text":"<p>Function to save the simulation history to a csv file in a given folder. Additionally, an analysis of the runs can be saved if the save_analysis is enabled. The environment and agent used can be saved in the saved folder by enabling the 'save_component' parameter.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>The name of the file the simulation histories will be saved to. If it is not provided, it will be by default \"Simulations--n_--horizon_.csv\" <code>None</code> <code>folder</code> <code>str</code> <p>Folder to save the simulation histories to. If the folder name is not provided the current folder will be used.</p> <code>None</code> <code>save_analysis</code> <code>bool</code> <p>Whether to save an additional csv file with an analysis of the runs of the simulation. It will contain the amount of steps taken, the amount of extra steps compared to optimality, the discounted rewards and the ratio between optimal trajectory and the steps taken. The means and standard deviations of all the runs are also computed. The file will have the same name as the simulation history file with an additional '-analysis' tag at the end.</p> <code>True</code> <code>save_components</code> <code>bool</code> <p>Whether or not to save the environment and agent along with the simulation histories in the given folder.</p> <code>False</code> Source code in <code>olfactory_navigation/simulation.py</code> <pre><code>def save(self,\n         file: str | None = None,\n         folder: str | None = None,\n         save_analysis: bool = True,\n         save_components: bool = False\n         ) -&gt; None:\n    '''\n    Function to save the simulation history to a csv file in a given folder.\n    Additionally, an analysis of the runs can be saved if the save_analysis is enabled.\n    The environment and agent used can be saved in the saved folder by enabling the 'save_component' parameter.\n\n    Parameters\n    ----------\n    file : str, optional\n        The name of the file the simulation histories will be saved to.\n        If it is not provided, it will be by default \"Simulations-&lt;env_name&gt;-n_&lt;sim_count&gt;-&lt;sim_start_timestamp&gt;-horizon_&lt;max_sim_length&gt;.csv\"\n    folder : str, optional\n        Folder to save the simulation histories to.\n        If the folder name is not provided the current folder will be used.\n    save_analysis : bool, default=True\n        Whether to save an additional csv file with an analysis of the runs of the simulation.\n        It will contain the amount of steps taken, the amount of extra steps compared to optimality, the discounted rewards and the ratio between optimal trajectory and the steps taken.\n        The means and standard deviations of all the runs are also computed.\n        The file will have the same name as the simulation history file with an additional '-analysis' tag at the end.\n    save_components : bool, default=False\n        Whether or not to save the environment and agent along with the simulation histories in the given folder.\n    '''\n    assert (self.environment is not None) and (self.agent is not None), \"Function not available, the agent and/or the environment is not set.\"\n\n    # Handle file name\n    if file is None:\n        env_name = f's_' + '_'.join([str(axis_shape) for axis_shape in self.environment_shape])\n        file = f'Simulations-{env_name}-n_{self.n}-{self.timestamps[0][0].strftime(\"%Y%m%d_%H%M%S\")}-horizon_{len(self.positions)}.csv'\n\n    if not file.endswith('.csv'):\n        file += '.csv'\n\n    # Handle folder\n    if folder is None:\n        folder = './'\n\n    if '/' not in folder:\n        folder = './' + folder\n\n    if not os.path.exists(folder):\n        os.mkdir(folder)\n\n    if not folder.endswith('/'):\n        folder += '/'\n\n    # Save components if requested\n    if save_components:\n        if (self.environment.saved_at is None) or (folder not in self.environment.saved_at):\n            self.environment.save(folder=folder)\n\n        if (self.agent.saved_at is None) or (folder not in self.agent.saved_at):\n            self.agent.save(folder=folder)\n\n    # Create csv file\n    combined_df = pd.concat(self.simulation_dfs)\n\n    # timestamps information\n    simulation_lengths = np.array([len(df) for df in self.simulation_dfs])\n    timestamps_column = [None] * len(combined_df)\n    for n_start, run_timestamps in self.timestamps.items():\n        i_start = np.sum(simulation_lengths[:n_start])\n        for ts_i, ts in enumerate(run_timestamps):\n            timestamps_column[i_start + ts_i] = (ts.strftime('%Y%m%d_%H%M%S%f') if ts_i == 0 else ts.strftime('%H%M%S%f'))\n    combined_df['timestamps'] = timestamps_column\n\n    # Adding other useful info\n    padding = [None] * len(combined_df)\n    combined_df['horizon'] = [self.horizon] + padding[:-1]\n    combined_df['reward_discount'] = [self.reward_discount] + padding[:-1]\n\n    environment_info = [\n        self.environment.name,\n        self.environment.saved_at,\n        str(self.environment_dimensions), # int\n        '_'.join(str(axis_size) for axis_size in self.environment_shape),\n        '_'.join(str(axis_position) for axis_position in self.environment_source_position),\n        str(self.environment_source_radius), # float\n        '' if (self.environment_layer_labels is None) else '&amp;'.join(self.environment_layer_labels) # Using '&amp;' as splitter as '_' could be used in the labels themselves\n    ]\n    combined_df['environment'] = (environment_info + padding[:-len(environment_info)])\n\n    # Converting the thresholds array to a string to be saved\n    thresholds_string = ''\n    if len(self.agent_thresholds.shape) == 2:\n        thresholds_string = '&amp;'.join(['_'.join([str(item) for item in row]) for row_i, row in enumerate(self.agent_thresholds[:,1:-1])]) # Using '&amp;' as layer splitter as '-' can be used for negative thresholds\n    else:\n        thresholds_string = '_'.join([str(item) for item in self.agent_thresholds])\n\n    agent_info = [\n        self.agent.name,\n        self.agent.class_name,\n        self.agent.saved_at,\n        thresholds_string\n    ]\n    combined_df['agent'] = (agent_info + padding[:-len(agent_info)])\n\n    # Saving csv\n    combined_df.to_csv(folder + file, index=False)\n\n    print(f'Simulations saved to: {folder + file}')\n\n    if save_analysis:\n        runs_analysis_file_name = file.replace('.csv', '-runs_analysis.csv')\n        self.runs_analysis_df.to_csv(folder + runs_analysis_file_name)\n        print(f\"Simulation's runs analysis saved to: {folder + runs_analysis_file_name}\")\n\n        general_analysis_file_name = file.replace('.csv', '-general_analysis.csv')\n        self.general_analysis_df.to_csv(folder + general_analysis_file_name)\n        print(f\"Simulation's general analysis saved to: {folder + general_analysis_file_name}\")\n</code></pre>"},{"location":"reference/simulation/#olfactory_navigation.simulation.run_test","title":"<code>run_test(agent, n=None, start_points=None, environment=None, time_shift=0, time_loop=True, horizon=1000, initialization_values={}, reward_discount=0.99, print_progress=True, print_stats=True, print_warning=True, use_gpu=False, batches=-1)</code>","text":"<p>Function to run n simulations for a given agent in its environment (or a given modified environment). The simulations start either from random start points or provided trough the start_points parameter. The simulation can have shifted initial times (in the olfactory simulation).</p> <p>The simulation will run for at most 'horizon' steps, after which the simulations will be considered failed.</p> <p>Some statistics can be printed at end of the simulation with the 'print_stats' parameter. It will print some performance statisitcs about the simulations such as the average discounter reward. The reward discount can be set by the 'reward_discount' parameter.</p> <p>To speedup the simulations, it can be run on the gpu by toggling the 'use_gpu' parameter. This will have the consequence to send the various arrays to the gpu memory. This will only work if the agent has the support for to work with cupy arrays.</p> <p>This method returns a SimulationHistory object that saves all the positions the agent went through, the actions the agent took, and the observation the agent received. It also provides the possibility the save the results to a csv file and plot the various trajectories.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>The agent to be tested</p> required <code>n</code> <code>int</code> <p>How many simulation to run in parallel. n is optional but it needs to match with what is provided in start_points.</p> <code>None</code> <code>start_points</code> <code>ndarray</code> <p>The starting points of the simulation in 2d space. If not provided, n random points will be generated based on the start probabilities of the environment. Else, the amount of start_points need to match to n, if it is provided.</p> <code>None</code> <code>environment</code> <code>Environment</code> <p>The environment to run the simulations in. By default, the environment linked to the agent will used. This parameter is intended if the environment needs to be modified compared to environment the agent was trained on.</p> <code>None</code> <code>time_shift</code> <code>int or ndarray</code> <p>The time at which to start the olfactory simulation array. It can be either a single value, or n values.</p> <code>0</code> <code>time_loop</code> <code>bool</code> <p>Whether to loop the time if reaching the end. (starts back at 0)</p> <code>True</code> <code>horizon</code> <code>int</code> <p>The amount of steps to run the simulation for before killing the remaining simulations.</p> <code>1000</code> <code>initialization_values</code> <code>dict</code> <p>In the case the agent is to be initialized with custom values, the paramaters to be passed on the initialize_state function can be set here.</p> <code>{}</code> <code>reward_discount</code> <code>float</code> <p>How much a given reward is discounted based on how long it took to get it. It is purely used to compute the Average Discount Reward (ADR) after the simulation.</p> <code>0.99</code> <code>print_progress</code> <code>bool</code> <p>Whether to show a progress bar of what step the simulations are at.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether to print the stats at the end of the run.</p> <code>True</code> <code>print_warning</code> <code>bool</code> <p>Whether to print warnings when they occur or not.</p> <code>True</code> <code>use_gpu</code> <code>bool</code> <p>Whether to run the simulations on the GPU or not.</p> <code>False</code> <code>batches</code> <code>int</code> <p>In how many batches the simulations should be run. This is useful in the case there are too many simulations and the memory can fill up. The value of batches=-1 will make it that different batches amount are tried in increasing order if a MemoryError is encountered.</p> <code>-1</code> <p>Returns:</p> Name Type Description <code>hist</code> <code>SimulationHistory</code> <p>A SimulationHistory object that tracked all the positions, actions and observations.</p> Source code in <code>olfactory_navigation/simulation.py</code> <pre><code>def run_test(agent: Agent,\n             n: int | None = None,\n             start_points: np.ndarray | None = None,\n             environment: Environment | None = None,\n             time_shift: int | np.ndarray = 0,\n             time_loop: bool = True,\n             horizon: int = 1000,\n             initialization_values: dict = {},\n             reward_discount: float = 0.99,\n             print_progress: bool = True,\n             print_stats: bool = True,\n             print_warning: bool = True,\n             use_gpu: bool = False,\n             batches: int = -1\n             ) -&gt; SimulationHistory:\n    '''\n    Function to run n simulations for a given agent in its environment (or a given modified environment).\n    The simulations start either from random start points or provided trough the start_points parameter.\n    The simulation can have shifted initial times (in the olfactory simulation).\n\n    The simulation will run for at most 'horizon' steps, after which the simulations will be considered failed.\n\n    Some statistics can be printed at end of the simulation with the 'print_stats' parameter.\n    It will print some performance statisitcs about the simulations such as the average discounter reward.\n    The reward discount can be set by the 'reward_discount' parameter.\n\n    To speedup the simulations, it can be run on the gpu by toggling the 'use_gpu' parameter.\n    This will have the consequence to send the various arrays to the gpu memory.\n    This will only work if the agent has the support for to work with cupy arrays.\n\n    This method returns a SimulationHistory object that saves all the positions the agent went through,\n    the actions the agent took, and the observation the agent received.\n    It also provides the possibility the save the results to a csv file and plot the various trajectories.\n\n    Parameters\n    ----------\n    agent : Agent\n        The agent to be tested\n    n : int, optional\n        How many simulation to run in parallel.\n        n is optional but it needs to match with what is provided in start_points.\n    start_points : np.ndarray, optional\n        The starting points of the simulation in 2d space.\n        If not provided, n random points will be generated based on the start probabilities of the environment.\n        Else, the amount of start_points need to match to n, if it is provided.\n    environment : Environment, optional\n        The environment to run the simulations in.\n        By default, the environment linked to the agent will used.\n        This parameter is intended if the environment needs to be modified compared to environment the agent was trained on.\n    time_shift : int or np.ndarray, default=0\n        The time at which to start the olfactory simulation array.\n        It can be either a single value, or n values.\n    time_loop : bool, default=True\n        Whether to loop the time if reaching the end. (starts back at 0)\n    horizon : int, default=1000\n        The amount of steps to run the simulation for before killing the remaining simulations.\n    initialization_values : dict, default={}\n        In the case the agent is to be initialized with custom values,\n        the paramaters to be passed on the initialize_state function can be set here.\n    reward_discount : float, default=0.99\n        How much a given reward is discounted based on how long it took to get it.\n        It is purely used to compute the Average Discount Reward (ADR) after the simulation.\n    print_progress : bool, default=True\n        Whether to show a progress bar of what step the simulations are at.\n    print_stats : bool, default=True\n        Whether to print the stats at the end of the run.\n    print_warning : bool, default=True\n        Whether to print warnings when they occur or not.\n    use_gpu : bool, default=False\n        Whether to run the simulations on the GPU or not.\n    batches : int, default=-1\n        In how many batches the simulations should be run.\n        This is useful in the case there are too many simulations and the memory can fill up.\n        The value of batches=-1 will make it that different batches amount are tried in increasing order if a MemoryError is encountered.\n\n    Returns\n    -------\n    hist : SimulationHistory\n        A SimulationHistory object that tracked all the positions, actions and observations.\n    '''\n    # Gathering n\n    if n is None:\n        if (start_points is None) or (len(start_points.shape) == 1):\n            n = 1\n        else:\n            n = len(start_points)\n\n    # Handle the case an specific environment is given\n    if (environment is not None) and print_warning:\n        if environment.shape != agent.environment.shape:\n            print(\"[Warning] The provided environment's shape doesn't match the environment has been trained on...\")\n        print('Using the provided environment, not the agent environment.')\n    else:\n        environment = agent.environment\n\n    # Timeshift\n    if isinstance(time_shift, int):\n        time_shift = np.ones(n) * time_shift\n    else:\n        time_shift = np.array(time_shift)\n        assert time_shift.shape == (n,), f\"time_shift array has a wrong shape (Given: {time_shift.shape}, expected ({n},))\"\n    time_shift = time_shift.astype(int)\n\n    # Auto batches selector where the amount of batches increases if a memory error is detected\n    if batches &lt; 0:\n        all_try_batches = (2**np.arange(np.log2(11000), dtype=int))\n        for try_batches in all_try_batches:\n            try:\n                hist = run_test(agent = agent,\n                                n = n,\n                                start_points = start_points,\n                                environment = environment,\n                                time_shift = time_shift,\n                                time_loop = time_loop,\n                                horizon = horizon,\n                                initialization_values = initialization_values,\n                                reward_discount = reward_discount,\n                                print_progress = print_progress,\n                                print_stats = print_stats,\n                                print_warning = False, # If there was any, it would have been printed already\n                                use_gpu = use_gpu,\n                                batches = try_batches)\n                return hist\n            except MemoryError as e:\n                print(f'Memory full: {e}')\n                print('Increasing the amount of batches...')\n\n    # If more than one batch is selected, split the starting point arrays by the amounts of simulations in each batch\n    elif batches &gt; 1:\n        # Computing the amount of simulations to be in each batch\n        n_batches = np.array([n / batches] * batches).astype(int)\n        n_batches[:(n%batches)] += 1\n        n_start = 0\n\n        # Full SimulationHistory object\n        combined_hist = None\n\n        # Time tracking\n        all_sim_start_ts = datetime.now()\n\n        # Batches loop\n        batch_iterator = tqdm(n_batches, desc='Batches') if print_progress else n_batches\n        for b_n in batch_iterator:\n            b_hist = run_test(agent = agent,\n                              n = b_n,\n                              start_points = start_points[n_start:n_start+b_n],\n                              environment = environment,\n                              time_shift = time_shift[n_start:n_start+b_n],\n                              time_loop = time_loop,\n                              horizon = horizon,\n                              initialization_values = initialization_values,\n                              reward_discount = reward_discount,\n                              print_progress = print_progress,\n                              print_stats = False, # Forced false to not print too many things\n                              print_warning = False, # If there was any, it would have been printed already\n                              use_gpu = use_gpu,\n                              batches = 1)\n            n_start += b_n\n\n            # Combining SimulationHistory objects\n            if combined_hist is None:\n                combined_hist = b_hist\n            else:\n                combined_hist += b_hist\n\n        # Print stats of the complete history is asked\n        if print_stats:\n            all_sim_end_ts = datetime.now()\n            print(f'Simulations done in {(all_sim_end_ts - all_sim_start_ts).total_seconds():.3f}s:')\n            print(combined_hist.summary)\n\n        return combined_hist\n\n    # Move things to GPU if needed\n    xp = np\n    if use_gpu:\n        assert gpu_support, f\"GPU support is not enabled, the use_gpu option is not available.\"\n        xp = cp\n\n        # Move instances to GPU\n        agent = agent.gpu_version\n        environment = environment.gpu_version\n        time_shift = cp.array(time_shift)\n\n        if start_points is not None:\n            start_points = cp.array(start_points)\n\n    # Set start positions\n    agent_position = None\n    if start_points is not None:\n        assert start_points.shape == (n, environment.dimensions), f'The provided start_points are of the wrong shape (expected {environment.dimensions}; received {start_points.shape[1]})'\n        agent_position = start_points\n    else:\n        # Generating random starts\n        agent_position = environment.random_start_points(n)\n\n    # Initialize agent's state\n    agent.initialize_state(n, **initialization_values)\n\n    # Create simulation history tracker\n    hist = SimulationHistory(\n        start_points=agent_position,\n        environment=environment,\n        agent=agent,\n        time_shift=time_shift,\n        horizon=horizon,\n        reward_discount=reward_discount\n    )\n\n    # Track begin of simulation ts\n    sim_start_ts = datetime.now()\n\n    # Simulation loop\n    iterator = trange(horizon) if print_progress else range(horizon)\n    for i in iterator:\n        # Letting agent choose the action to take based on it's curent state\n        action = agent.choose_action()\n\n        # Updating the agent's actual position (hidden to him)\n        agent_position = environment.move(pos=agent_position,\n                                          movement=(action if not environment.has_layers else action[:,1:])) # Getting only the physical component of the action vector if environment has layers.\n\n        # Get an observation based on the new position of the agent\n        observation = environment.get_observation(pos=agent_position,\n                                                  time=(time_shift + i),\n                                                  layer=(0 if not environment.has_layers else action[:,0])) # Getting the layer information column of the action matrix.\n\n        # Check if the source is reached\n        source_reached = environment.source_reached(agent_position)\n\n        # Add the position to the observation if the agent is space aware\n        if agent.space_aware:\n            observation = xp.hstack((observation[:,None], agent_position))\n\n        # Return the observation to the agent\n        update_succeeded = agent.update_state(action=action,\n                                              observation=observation,\n                                              source_reached=source_reached)\n        if update_succeeded is None:\n            update_succeeded = xp.ones(len(source_reached), dtype=bool)\n\n        # Handling the case where simulations have reached the end\n        sims_at_end = ((time_shift + i + 1) &gt;= (math.inf if time_loop else environment.timesteps))\n\n        # Agents to terminate\n        to_terminate = source_reached | sims_at_end | ~update_succeeded\n\n        # Send the values to the tracker\n        hist.add_step(\n            actions=action,\n            next_positions=agent_position,\n            observations=observation[:,0] if agent.space_aware else observation,\n            reached_source=source_reached,\n            interupt=to_terminate\n        )\n\n        # Interupt agents that reached the end\n        agent_position = agent_position[~to_terminate]\n        time_shift = time_shift[~to_terminate]\n        agent.kill(simulations_to_kill=to_terminate)\n\n        # Early stopping if all agents done\n        if len(agent_position) == 0:\n            break\n\n        # Update progress bar\n        if print_progress:\n            done_count = hist.done_count\n            success_count = hist.success_count\n            success_percentage = (success_count/done_count)*100 if done_count &gt; 0 else 100\n            dead_percentage = ((done_count-success_count)/done_count)*100 if done_count &gt; 0 else 0\n            iterator.set_postfix({\n                'done ': f' {done_count}/{n} ({(done_count/n)*100:.1f}%)',\n                'success ': f' {success_count}/{done_count} ({success_percentage:.1f}%)',\n                'dead ': f' {done_count-success_count}/{done_count} ({dead_percentage:.1f}%)'\n            })\n\n    # If requested print the simulation start\n    if print_stats:\n        sim_end_ts = datetime.now()\n        print(f'Simulations done in {(sim_end_ts - sim_start_ts).total_seconds():.3f}s:')\n        print(hist.summary)\n\n    return hist\n</code></pre>"},{"location":"reference/test_setups/","title":"test_setups","text":""},{"location":"reference/test_setups/#olfactory_navigation.test_setups.analyse_scale_robustness","title":"<code>analyse_scale_robustness(all_histories, multipliers)</code>","text":"<p>Function to generate an analysis of a set of simulation tests with different multipliers applied in the environment. It returns a pandas dataframe summarizing the results for each multiplier pairs. The results analyzed are the following:</p> <ul> <li>convergence</li> <li>steps taken</li> <li>discounted rewards</li> <li>extra steps taken (compared to a minimum path)</li> <li>t min over t (a ratio of how optimal the path taken was)</li> </ul> <p>For each result, the mean, standard deviation along with the mean and standard deviation of the successful trajectories are recorded.</p> <p>Parameters:</p> Name Type Description Default <code>all_histories</code> <code>list[SimulationHistory]</code> <p>A list of all the simulation histories to summarize</p> required <code>multipliers</code> <code>ndarray</code> <p>An array of the multiplier pairs used (for the y multiplier then the x multiplier)</p> required <p>Returns:</p> Name Type Description <code>df</code> <code>DataFrame</code> <p>The analysis dataframe.</p> Source code in <code>olfactory_navigation/test_setups.py</code> <pre><code>def analyse_scale_robustness(all_histories: list[SimulationHistory],\n                             multipliers: np.ndarray\n                             ) -&gt; pd.DataFrame:\n    '''\n    Function to generate an analysis of a set of simulation tests with different multipliers applied in the environment.\n    It returns a pandas dataframe summarizing the results for each multiplier pairs.\n    The results analyzed are the following:\n\n    - convergence\n    - steps taken\n    - discounted rewards\n    - extra steps taken (compared to a minimum path)\n    - t min over t (a ratio of how optimal the path taken was)\n\n    For each result, the mean, standard deviation along with the mean and standard deviation of the successful trajectories are recorded.\n\n    Parameters\n    ----------\n    all_histories : list[SimulationHistory]\n        A list of all the simulation histories to summarize\n    multipliers : np.ndarray\n        An array of the multiplier pairs used (for the y multiplier then the x multiplier)\n\n    Returns\n    -------\n    df : pd.DataFrame\n        The analysis dataframe.\n    '''\n    rows = []\n    # For each simulation history and multiplier, the analysis dataframe is extracted\n    for hist, multiplier in zip(all_histories, multipliers):\n        df = hist.general_analysis_df\n\n        # Then the summarized metrics are collapsed on a single row\n        col_metric_dict = {'multiplier': int(multiplier)}\n        for col in ['converged', 'reached_horizon', 'steps_taken', 'discounted_rewards', 'extra_steps', 't_min_over_t']:\n            for metric in ['mean', 'standard_deviation', 'success_mean', 'success_standard_deviation']:\n                col_metric_dict[f'{col}_{metric}'] = df.loc[metric, col]\n\n        rows.append(col_metric_dict)\n\n    # Creating the dataframe from all the rows\n    df = pd.DataFrame(rows)\n\n    # Removal of 4 unnecessary columns\n    df = df.drop(columns=['converged_success_mean',\n                          'converged_success_standard_deviation',\n                          'reached_horizon_success_mean',\n                          'reached_horizon_success_standard_deviation'])\n\n    return df\n</code></pre>"},{"location":"reference/test_setups/#olfactory_navigation.test_setups.analyse_shape_robustness","title":"<code>analyse_shape_robustness(all_histories, multipliers)</code>","text":"<p>Function to generate an analysis of a set of simulation tests with different multipliers applied in the environment. It returns a pandas dataframe summarizing the results for each multiplier pairs. The results analyzed are the following:</p> <ul> <li>convergence</li> <li>steps taken</li> <li>discounted rewards</li> <li>extra steps taken (compared to a minimum path)</li> <li>t min over t (a ratio of how optimal the path taken was)</li> </ul> <p>For each result, the mean, standard deviation along with the mean and standard deviation of the successful trajectories are recorded.</p> <p>Parameters:</p> Name Type Description Default <code>all_histories</code> <code>list[SimulationHistory]</code> <p>A list of all the simulation histories to summarize</p> required <code>multipliers</code> <code>ndarray</code> <p>An array of the multiplier pairs used (for the y multiplier then the x multiplier)</p> required <p>Returns:</p> Name Type Description <code>df</code> <code>DataFrame</code> <p>The analysis dataframe.</p> Source code in <code>olfactory_navigation/test_setups.py</code> <pre><code>def analyse_shape_robustness(all_histories: list[SimulationHistory],\n                             multipliers: np.ndarray\n                             ) -&gt; pd.DataFrame:\n    '''\n    Function to generate an analysis of a set of simulation tests with different multipliers applied in the environment.\n    It returns a pandas dataframe summarizing the results for each multiplier pairs.\n    The results analyzed are the following:\n\n    - convergence\n    - steps taken\n    - discounted rewards\n    - extra steps taken (compared to a minimum path)\n    - t min over t (a ratio of how optimal the path taken was)\n\n    For each result, the mean, standard deviation along with the mean and standard deviation of the successful trajectories are recorded.\n\n    Parameters\n    ----------\n    all_histories : list[SimulationHistory]\n        A list of all the simulation histories to summarize\n    multipliers : np.ndarray\n        An array of the multiplier pairs used (for the y multiplier then the x multiplier)\n\n    Returns\n    -------\n    df : pd.DataFrame\n        The analysis dataframe.\n    '''\n    rows = []\n    # For each simulation history and multiplier, the analysis dataframe is extracted\n    for hist, multiplier_pair in zip(all_histories, multipliers):\n        df = hist.general_analysis_df\n\n        # Then the summarized metrics are collapsed on a single row\n        col_metric_dict = {'y_multiplier': multiplier_pair[0].astype(int), 'x_multiplier': multiplier_pair[1].astype(int)}\n        for col in ['converged', 'reached_horizon', 'steps_taken', 'discounted_rewards', 'extra_steps', 't_min_over_t']:\n            for metric in ['mean', 'standard_deviation', 'success_mean', 'success_standard_deviation']:\n                col_metric_dict[f'{col}_{metric}'] = df.loc[metric, col]\n\n        rows.append(col_metric_dict)\n\n    # Creating the dataframe from all the rows\n    df = pd.DataFrame(rows)\n\n    # Removal of 4 unnecessary columns\n    df = df.drop(columns=['converged_success_mean',\n                          'converged_success_standard_deviation',\n                          'reached_horizon_success_mean',\n                          'reached_horizon_success_standard_deviation'])\n\n    return df\n</code></pre>"},{"location":"reference/test_setups/#olfactory_navigation.test_setups.run_all_starts_test","title":"<code>run_all_starts_test(agent, environment=None, time_shift=0, time_loop=True, horizon=1000, initialization_values={}, reward_discount=0.99, print_progress=True, print_stats=True, use_gpu=False)</code>","text":"<p>Function to run a test with all the available starting positions based on the environment provided (or the environmnent of the agent).</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>The agent to be tested</p> required <code>environment</code> <code>Environment</code> <p>The environment to run the simulations in. By default, the environment linked to the agent will used. This parameter is intended if the environment needs to be modified compared to environment the agent was trained on.</p> <code>None</code> <code>time_shift</code> <code>int or ndarray</code> <p>The time at which to start the olfactory simulation array. It can be either a single value, or n values.</p> <code>0</code> <code>time_loop</code> <code>bool</code> <p>Whether to loop the time if reaching the end. (starts back at 0)</p> <code>True</code> <code>horizon</code> <code>int</code> <p>The amount of steps to run the simulation for before killing the remaining simulations.</p> <code>1000</code> <code>initialization_values</code> <code>dict</code> <p>In the case the agent is to be initialized with custom values, the paramaters to be passed on the initialize_state function can be set here.</p> <code>{}</code> <code>reward_discount</code> <code>float</code> <p>How much a given reward is discounted based on how long it took to get it. It is purely used to compute the Average Discount Reward (ADR) after the simulation.</p> <code>0.99</code> <code>print_progress</code> <code>bool</code> <p>Wheter to show a progress bar of what step the simulations are at.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Wheter to print the stats at the end of the run.</p> <code>True</code> <code>use_gpu</code> <code>bool</code> <p>Whether to run the simulations on the GPU or not.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>hist</code> <code>SimulationHistory</code> <p>A SimulationHistory object that tracked all the positions, actions and observations.</p> Source code in <code>olfactory_navigation/test_setups.py</code> <pre><code>def run_all_starts_test(agent: Agent,\n                        environment: Environment | None = None,\n                        time_shift: int | np.ndarray = 0,\n                        time_loop: bool = True,\n                        horizon: int = 1000,\n                        initialization_values: dict = {},\n                        reward_discount: float = 0.99,\n                        print_progress: bool = True,\n                        print_stats: bool = True,\n                        use_gpu: bool = False\n                        ) -&gt; SimulationHistory:\n    '''\n    Function to run a test with all the available starting positions based on the environment provided (or the environmnent of the agent).\n\n    Parameters\n    ----------\n    agent : Agent\n        The agent to be tested\n    environment : Environment, optional\n        The environment to run the simulations in.\n        By default, the environment linked to the agent will used.\n        This parameter is intended if the environment needs to be modified compared to environment the agent was trained on.\n    time_shift : int or np.ndarray, default=0\n        The time at which to start the olfactory simulation array.\n        It can be either a single value, or n values.\n    time_loop : bool, default=True\n        Whether to loop the time if reaching the end. (starts back at 0)\n    horizon : int, default=1000\n        The amount of steps to run the simulation for before killing the remaining simulations.\n    initialization_values : dict, default={}\n        In the case the agent is to be initialized with custom values,\n        the paramaters to be passed on the initialize_state function can be set here.\n    reward_discount : float, default=0.99\n        How much a given reward is discounted based on how long it took to get it.\n        It is purely used to compute the Average Discount Reward (ADR) after the simulation.\n    print_progress : bool, default=True\n        Wheter to show a progress bar of what step the simulations are at.\n    print_stats : bool, default=True\n        Wheter to print the stats at the end of the run.\n    use_gpu : bool, default=False\n        Whether to run the simulations on the GPU or not.\n\n    Returns\n    -------\n    hist : SimulationHistory\n        A SimulationHistory object that tracked all the positions, actions and observations.\n    '''\n    # Handle the case an specific environment is given\n    environment_provided = environment is not None\n    if environment_provided:\n        assert environment.shape == agent.environment.shape, \"The provided environment's shape doesn't match the environment has been trained on...\"\n    else:\n        environment = agent.environment\n\n    # Gathering starting points\n    start_points = np.argwhere(environment.start_probabilities &gt; 0)\n    n = len(start_points)\n\n    return run_test(\n        agent = agent,\n        n = n,\n        start_points = start_points,\n        environment = environment if environment_provided else None,\n        time_shift = time_shift,\n        time_loop = time_loop,\n        horizon = horizon,\n        initialization_values = initialization_values,\n        reward_discount = reward_discount,\n        print_progress = print_progress,\n        print_stats = print_stats,\n        use_gpu = use_gpu\n    )\n</code></pre>"},{"location":"reference/test_setups/#olfactory_navigation.test_setups.run_n_by_cell_test","title":"<code>run_n_by_cell_test(agent, cell_width=10, n_by_cell=10, environment=None, time_shift=0, time_loop=True, horizon=1000, initialization_values={}, reward_discount=0.99, print_progress=True, print_stats=True, use_gpu=False)</code>","text":"<p>Function to run a test with simulations starting in different cells across the available starting zones. A number n_by_cell determines how many simulations should start within each cell (the same position can be chosen multiple times).</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>The agent to be tested</p> required <code>cell_width</code> <code>int</code> <p>The size of the sides of each cells to be considered.</p> <code>10</code> <code>n_by_cell</code> <code>int</code> <p>How many simulations should start within each cell.</p> <code>10</code> <code>environment</code> <code>Environment</code> <p>The environment to run the simulations in. By default, the environment linked to the agent will used. This parameter is intended if the environment needs to be modified compared to environment the agent was trained on.</p> <code>None</code> <code>time_shift</code> <code>int or ndarray</code> <p>The time at which to start the olfactory simulation array. It can be either a single value, or n values.</p> <code>0</code> <code>time_loop</code> <code>bool</code> <p>Whether to loop the time if reaching the end. (starts back at 0)</p> <code>True</code> <code>horizon</code> <code>int</code> <p>The amount of steps to run the simulation for before killing the remaining simulations.</p> <code>1000</code> <code>initialization_values</code> <code>dict</code> <p>In the case the agent is to be initialized with custom values, the paramaters to be passed on the initialize_state function can be set here.</p> <code>{}</code> <code>reward_discount</code> <code>float</code> <p>How much a given reward is discounted based on how long it took to get it. It is purely used to compute the Average Discount Reward (ADR) after the simulation.</p> <code>0.99</code> <code>print_progress</code> <code>bool</code> <p>Wheter to show a progress bar of what step the simulations are at.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Wheter to print the stats at the end of the run.</p> <code>True</code> <code>use_gpu</code> <code>bool</code> <p>Whether to run the simulations on the GPU or not.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>hist</code> <code>SimulationHistory</code> <p>A SimulationHistory object that tracked all the positions, actions and observations.</p> Source code in <code>olfactory_navigation/test_setups.py</code> <pre><code>def run_n_by_cell_test(agent: Agent,\n                       cell_width: int = 10,\n                       n_by_cell: int = 10,\n                       environment: Environment | None = None,\n                       time_shift: int | np.ndarray = 0,\n                       time_loop: bool = True,\n                       horizon: int = 1000,\n                       initialization_values: dict = {},\n                       reward_discount: float = 0.99,\n                       print_progress: bool = True,\n                       print_stats: bool = True,\n                       use_gpu: bool = False\n                       ) -&gt; SimulationHistory:\n    '''\n    Function to run a test with simulations starting in different cells across the available starting zones.\n    A number n_by_cell determines how many simulations should start within each cell (the same position can be chosen multiple times).\n\n    Parameters\n    ----------\n    agent : Agent\n        The agent to be tested\n    cell_width : int, default=10\n        The size of the sides of each cells to be considered.\n    n_by_cell : int, default=10\n        How many simulations should start within each cell.\n    environment : Environment, optional\n        The environment to run the simulations in.\n        By default, the environment linked to the agent will used.\n        This parameter is intended if the environment needs to be modified compared to environment the agent was trained on.\n    time_shift : int or np.ndarray, default=0\n        The time at which to start the olfactory simulation array.\n        It can be either a single value, or n values.\n    time_loop : bool, default=True\n        Whether to loop the time if reaching the end. (starts back at 0)\n    horizon : int, default=1000\n        The amount of steps to run the simulation for before killing the remaining simulations.\n    initialization_values : dict, default={}\n        In the case the agent is to be initialized with custom values,\n        the paramaters to be passed on the initialize_state function can be set here.\n    reward_discount : float, default=0.99\n        How much a given reward is discounted based on how long it took to get it.\n        It is purely used to compute the Average Discount Reward (ADR) after the simulation.\n    print_progress : bool, default=True\n        Wheter to show a progress bar of what step the simulations are at.\n    print_stats : bool, default=True\n        Wheter to print the stats at the end of the run.\n    use_gpu : bool, default=False\n        Whether to run the simulations on the GPU or not.\n\n    Returns\n    -------\n    hist : SimulationHistory\n        A SimulationHistory object that tracked all the positions, actions and observations.\n    '''\n    # Handle the case an specific environment is given\n    environment_provided = environment is not None\n    if environment_provided:\n        assert environment.shape == agent.environment.shape, \"The provided environment's shape doesn't match the environment has been trained on...\"\n    else:\n        environment = agent.environment\n\n    # Gathering starting points\n    cells_x = int(environment.shape[0] / cell_width)\n    cells_y = int(environment.shape[1] / cell_width)\n\n    indices = np.arange(np.prod(environment.shape), dtype=int)\n    indices_grid = indices.reshape(environment.shape)\n    all_chosen_indices = []\n\n    for i in range(cells_x):\n        for j in range(cells_y):\n            cell_probs = environment.start_probabilities[(i*cell_width):(i*cell_width)+cell_width, (j*cell_width):(j*cell_width)+cell_width]\n            if np.any(cell_probs &gt; 0):\n                cell_indices = indices_grid[(i*cell_width):(i*cell_width)+cell_width, (j*cell_width):(j*cell_width)+cell_width]\n                cell_probs /= np.sum(cell_probs)\n\n                chosen_indices = np.random.choice(cell_indices.ravel(), size=n_by_cell, replace=True, p=cell_probs.ravel()).tolist()\n                all_chosen_indices += chosen_indices\n\n    n = len(all_chosen_indices)\n    start_points = np.array(np.unravel_index(all_chosen_indices, environment.shape)).T\n\n    return run_test(\n        agent = agent,\n        n = n,\n        start_points = start_points,\n        environment = environment if environment_provided else None,\n        time_shift = time_shift,\n        time_loop = time_loop,\n        horizon = horizon,\n        initialization_values = initialization_values,\n        reward_discount = reward_discount,\n        print_progress = print_progress,\n        print_stats = print_stats,\n        use_gpu = use_gpu\n    )\n</code></pre>"},{"location":"reference/test_setups/#olfactory_navigation.test_setups.test_scale_robustness","title":"<code>test_scale_robustness(agent, environment=None, time_shift=0, time_loop=True, horizon=1000, initialization_values={}, reward_discount=0.99, step_percentage=20, min_percentage=20, max_percentage=200, multipliers=None, use_gpu=False, print_progress=True, print_stats=True, save=True, save_folder=None, save_analysis=True)</code>","text":"<p>Function to test the robustness of an agent in a environment where the scale of the environment's shape is altered by some percentage.</p> <p>A list of multipliers will be constructed from the min_percentage to 100% and up to max_percentage values with between each percentage step_percentage values. These percentage multipliers will be applied both in the x and y direction but cropped to the largest allowed multiplier along each axis.</p> <p>This complete test consists in running from all possible start positions of the original environment.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>The agent to run the shape robustness test on.</p> required <code>environment</code> <code>Environment</code> <p>The environment to run the test in. By default, the environment linked to the agent will used. This parameter is intended if the environment needs to be modified compared to environment the agent was trained on.</p> <code>None</code> <code>time_shift</code> <code>int or ndarray</code> <p>The time at which to start the olfactory simulation array. It can be either a single value, or n values.</p> <code>0</code> <code>time_loop</code> <code>bool</code> <p>Whether to loop the time if reaching the end. (starts back at 0)</p> <code>True</code> <code>horizon</code> <code>int</code> <p>The amount of steps to run the simulation for before killing the remaining simulations.</p> <code>1000</code> <code>initialization_values</code> <code>dict</code> <p>In the case the agent is to be initialized with custom values, the paramaters to be passed on the initialize_state function can be set here.</p> <code>{}</code> <code>reward_discount</code> <code>float</code> <p>How much a given reward is discounted based on how long it took to get it. It is purely used to compute the Average Discount Reward (ADR) after the simulation.</p> <code>0.99</code> <code>step_percentage</code> <code>int</code> <p>Starting at 100%, how much of a percentage step to do to reach the min and max percentages.</p> <code>20</code> <code>min_percentage</code> <code>int</code> <p>The minimum percentage of deformation to apply on the environment's odor plume.</p> <code>20</code> <code>max_percentage</code> <code>int</code> <p>The maximum percentage of deformation to apply on the environment's odor plume. If this value is larger than the maximum shape allowed by the margins, the largest allowed percentage will be used.</p> <code>200</code> <code>multipliers</code> <code>list[int]</code> <p>If provided, the step_percentage, min_percentage and max_percentage parameters will be ignored. A list of percentages of deformations to use to deforme the environment's odor plume.</p> <code>None</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU to speed up the tests.</p> <code>False</code> <code>print_progress</code> <code>bool</code> <p>Whether to display a progress bar of how many test have been performed so far.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether to display statistics at the end of each test.</p> <code>True</code> <code>save</code> <code>bool</code> <p>Whether to save the results of each test to a save_folder. Each test's result will be under the name 'test_env_mult-.csv' <code>True</code> <code>save_folder</code> <code>str</code> <p>The path to which the test results are saved. If not provided, it will automatically create a new folder './results/scale_robustness_test/' <code>None</code> <code>save_analysis</code> <code>bool</code> <p>Whether to save the analysis of the histories. It will be saved under a file named '_analysis.csv' in the save_folder.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>all_histories</code> <code>list[SimulationHistory]</code> <p>A list of SimulationHistory instances.</p> Source code in <code>olfactory_navigation/test_setups.py</code> <pre><code>def test_scale_robustness(agent: Agent,\n                          environment: Environment | None = None,\n                          time_shift: int | np.ndarray = 0,\n                          time_loop: bool = True,\n                          horizon: int = 1000,\n                          initialization_values: dict = {},\n                          reward_discount: float = 0.99,\n                          step_percentage: int = 20,\n                          min_percentage:int = 20,\n                          max_percentage:int = 200,\n                          multipliers: list[int] | None = None,\n                          use_gpu: bool = False,\n                          print_progress: bool = True,\n                          print_stats: bool = True,\n                          save: bool = True,\n                          save_folder: str = None,\n                          save_analysis: bool = True\n                          ) -&gt; list[SimulationHistory]:\n    '''\n    Function to test the robustness of an agent in a environment where the scale of the environment's shape is altered by some percentage.\n\n    A list of multipliers will be constructed from the min_percentage to 100% and up to max_percentage values with between each percentage step_percentage values.\n    These percentage multipliers will be applied both in the x and y direction but cropped to the largest allowed multiplier along each axis.\n\n    This complete test consists in running from all possible start positions of the original environment.\n\n    Parameters\n    ----------\n    agent : Agent\n        The agent to run the shape robustness test on.\n    environment : Environment, optional\n        The environment to run the test in.\n        By default, the environment linked to the agent will used.\n        This parameter is intended if the environment needs to be modified compared to environment the agent was trained on.\n    time_shift : int or np.ndarray, default=0\n        The time at which to start the olfactory simulation array.\n        It can be either a single value, or n values.\n    time_loop : bool, default=True\n        Whether to loop the time if reaching the end. (starts back at 0)\n    horizon : int, default=1000\n        The amount of steps to run the simulation for before killing the remaining simulations.\n    initialization_values : dict, default={}\n        In the case the agent is to be initialized with custom values,\n        the paramaters to be passed on the initialize_state function can be set here.\n    reward_discount : float, default=0.99\n        How much a given reward is discounted based on how long it took to get it.\n        It is purely used to compute the Average Discount Reward (ADR) after the simulation.\n    step_percentage : int, default=20\n        Starting at 100%, how much of a percentage step to do to reach the min and max percentages.\n    min_percentage : int, default=20\n        The minimum percentage of deformation to apply on the environment's odor plume.\n    max_percentage : int, default=200\n        The maximum percentage of deformation to apply on the environment's odor plume.\n        If this value is larger than the maximum shape allowed by the margins, the largest allowed percentage will be used.\n    multipliers : list[int], optional\n        If provided, the step_percentage, min_percentage and max_percentage parameters will be ignored.\n        A list of percentages of deformations to use to deforme the environment's odor plume.\n    use_gpu : bool, default=False\n        Whether to use the GPU to speed up the tests.\n    print_progress : bool, default=True\n        Whether to display a progress bar of how many test have been performed so far.\n    print_stats : bool, default=True\n        Whether to display statistics at the end of each test.\n    save : bool, default=True\n        Whether to save the results of each test to a save_folder.\n        Each test's result will be under the name 'test_env_mult-&lt;multiplier&gt;.csv'\n    save_folder : str, optional\n        The path to which the test results are saved.\n        If not provided, it will automatically create a new folder './results/&lt;timestamp&gt;_scale_robustness_test_&lt;environment_name&gt;/'\n    save_analysis : bool, default=True\n        Whether to save the analysis of the histories.\n        It will be saved under a file named '_analysis.csv' in the save_folder.\n\n    Returns\n    -------\n    all_histories : list[SimulationHistory]\n        A list of SimulationHistory instances.\n    '''\n    # Handle the case an specific environment is given\n    environment_provided = environment is not None\n    if environment_provided:\n        assert environment.shape == agent.environment.shape, \"The provided environment's shape doesn't match the environment has been trained on...\"\n    else:\n        environment = agent.environment\n\n    # Gathering starting points\n    start_points = np.argwhere(environment.start_probabilities &gt; 0)\n    n = len(start_points)\n\n    # Generating multipliers\n    if multipliers is None:\n        with np.errstate(divide='ignore'):\n            low_max_mult = ((environment.margins[:,0] / environment.data_source_position) + 1)\n            high_max_mult = (1 + (environment.margins[:,1] / (environment.data_shape - environment.data_source_position)))\n            max_mult = np.min(np.vstack([low_max_mult, high_max_mult]), axis=0)\n\n        multipliers = [(100 - perc_mult) for perc_mult in range(0, (100-min_percentage)+step_percentage, step_percentage)[1:]] + [perc_mult for perc_mult in range(100, min(max_percentage, int(max(max_mult)*100)), step_percentage)]\n    multipliers.sort()\n\n    # Save Folder name and creation\n    if save or save_analysis:\n        if save_folder is None:\n            save_folder = f'./results/{datetime.now().strftime(\"%Y%m%d_%H%M%S\")}_scale_robustness_test_' + environment.name\n\n        if not os.path.exists(save_folder):\n            os.mkdir(save_folder)\n\n        print(f'The results will be saved to: {save_folder}\\n')\n\n    all_histories = []\n    for mult in (tqdm(multipliers) if print_progress else multipliers):\n        print(f'Testing on environment with scale modifier {mult}%')\n\n        # Modifying environment\n        modified_environment = environment.modify_scale(scale_factor=mult/100)\n\n        # Running test\n        hist = run_test(\n            agent = agent,\n            n = n,\n            start_points = start_points,\n            environment = modified_environment,\n            time_shift = time_shift,\n            time_loop = time_loop,\n            horizon = horizon,\n            initialization_values = initialization_values,\n            reward_discount = reward_discount,\n            print_progress = False,\n            print_stats = print_stats,\n            use_gpu = use_gpu\n        )\n\n        all_histories.append(hist)\n\n        # Saving history\n        if save:\n            file_name = f'test_env_mult-{mult}'\n            hist.save(file=file_name,\n                      folder=save_folder,\n                      save_analysis=False)\n\n        print()\n\n    # Analysis saving\n    if save and save_analysis:\n        analysis_df = analyse_scale_robustness(all_histories=all_histories, multipliers=multipliers)\n        analysis_file_name = '_analysis.csv'\n        analysis_df.to_csv(save_folder + '/' + analysis_file_name, index=False)\n        print(f'Scale robustness analysis saved to: {save_folder}/{analysis_file_name}')\n\n    return all_histories\n</code></pre>"},{"location":"reference/test_setups/#olfactory_navigation.test_setups.test_shape_robustness","title":"<code>test_shape_robustness(agent, environment=None, time_shift=0, time_loop=True, horizon=1000, initialization_values={}, reward_discount=0.99, step_percentage=20, min_percentage=20, max_percentage=200, multipliers=None, use_gpu=False, print_progress=True, print_stats=True, save=True, save_folder=None, save_analysis=True)</code>","text":"<p>Function to test the robustness of an agent in a environment where the odor plume's shape is altered by some percentage.</p> <p>A list of multipliers will be constructed from the min_percentage to 100% and up to max_percentage values with between each percentage step_percentage values. These percentage multipliers will be applied both in the x and y direction but cropped to the largest allowed multiplier along each axis.</p> <p>For each multiplier pair, a completed test will be run. This complete test consists in running from all possible start positions of the original environment.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>The agent to run the shape robustness test on.</p> required <code>environment</code> <code>Environment</code> <p>The environment to run the test in. By default, the environment linked to the agent will used. This parameter is intended if the environment needs to be modified compared to environment the agent was trained on.</p> <code>None</code> <code>time_shift</code> <code>int or ndarray</code> <p>The time at which to start the olfactory simulation array. It can be either a single value, or n values.</p> <code>0</code> <code>time_loop</code> <code>bool</code> <p>Whether to loop the time if reaching the end. (starts back at 0)</p> <code>True</code> <code>horizon</code> <code>int</code> <p>The amount of steps to run the simulation for before killing the remaining simulations.</p> <code>1000</code> <code>initialization_values</code> <code>dict</code> <p>In the case the agent is to be initialized with custom values, the paramaters to be passed on the initialize_state function can be set here.</p> <code>{}</code> <code>reward_discount</code> <code>float</code> <p>How much a given reward is discounted based on how long it took to get it. It is purely used to compute the Average Discount Reward (ADR) after the simulation.</p> <code>0.99</code> <code>step_percentage</code> <code>int</code> <p>Starting at 100%, how much of a percentage step to do to reach the min and max percentages.</p> <code>20</code> <code>min_percentage</code> <code>int</code> <p>The minimum percentage of deformation to apply on the environment's odor plume.</p> <code>20</code> <code>max_percentage</code> <code>int</code> <p>The maximum percentage of deformation to apply on the environment's odor plume. If this value is larger than the maximum shape allowed by the margins, the largest allowed percentage will be used.</p> <code>200</code> <code>multipliers</code> <code>list[int]</code> <p>If provided, the step_percentage, min_percentage and max_percentage parameters will be ignored. A list of percentages of deformations to use to deforme the environment's odor plume.</p> <code>None</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU to speed up the tests.</p> <code>False</code> <code>print_progress</code> <code>bool</code> <p>Whether to display a progress bar of how many test have been performed so far.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether to display statistics at the end of each test.</p> <code>True</code> <code>save</code> <code>bool</code> <p>Whether to save the results of each test to a save_folder. Each test's result will be under the name 'test_env_y-_x-.csv' <code>True</code> <code>save_folder</code> <code>str</code> <p>The path to which the test results are saved. If not provided, it will automatically create a new folder './results/shape_robustness_test/' <code>None</code> <code>save_analysis</code> <code>bool</code> <p>Whether to save the analysis of the histories. It will be saved under a file named '_analysis.csv' in the save_folder.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>all_histories</code> <code>list[SimulationHistory]</code> <p>A list of SimulationHistory instances.</p> Source code in <code>olfactory_navigation/test_setups.py</code> <pre><code>def test_shape_robustness(agent: Agent,\n                          environment: Environment | None = None,\n                          time_shift: int | np.ndarray = 0,\n                          time_loop: bool = True,\n                          horizon: int = 1000,\n                          initialization_values: dict = {},\n                          reward_discount: float = 0.99,\n                          step_percentage: int = 20,\n                          min_percentage:int = 20,\n                          max_percentage:int = 200,\n                          multipliers: list[int] | None = None,\n                          use_gpu: bool = False,\n                          print_progress: bool = True,\n                          print_stats: bool = True,\n                          save: bool = True,\n                          save_folder: str = None,\n                          save_analysis: bool = True\n                          ) -&gt; list[SimulationHistory]:\n    '''\n    Function to test the robustness of an agent in a environment where the odor plume's shape is altered by some percentage.\n\n    A list of multipliers will be constructed from the min_percentage to 100% and up to max_percentage values with between each percentage step_percentage values.\n    These percentage multipliers will be applied both in the x and y direction but cropped to the largest allowed multiplier along each axis.\n\n    For each multiplier pair, a completed test will be run. This complete test consists in running from all possible start positions of the original environment.\n\n    Parameters\n    ----------\n    agent : Agent\n        The agent to run the shape robustness test on.\n    environment : Environment, optional\n        The environment to run the test in.\n        By default, the environment linked to the agent will used.\n        This parameter is intended if the environment needs to be modified compared to environment the agent was trained on.\n    time_shift : int or np.ndarray, default=0\n        The time at which to start the olfactory simulation array.\n        It can be either a single value, or n values.\n    time_loop : bool, default=True\n        Whether to loop the time if reaching the end. (starts back at 0)\n    horizon : int, default=1000\n        The amount of steps to run the simulation for before killing the remaining simulations.\n    initialization_values : dict, default={}\n        In the case the agent is to be initialized with custom values,\n        the paramaters to be passed on the initialize_state function can be set here.\n    reward_discount : float, default=0.99\n        How much a given reward is discounted based on how long it took to get it.\n        It is purely used to compute the Average Discount Reward (ADR) after the simulation.\n    step_percentage : int, default=20\n        Starting at 100%, how much of a percentage step to do to reach the min and max percentages.\n    min_percentage : int, default=20\n        The minimum percentage of deformation to apply on the environment's odor plume.\n    max_percentage : int, default=200\n        The maximum percentage of deformation to apply on the environment's odor plume.\n        If this value is larger than the maximum shape allowed by the margins, the largest allowed percentage will be used.\n    multipliers : list[int], optional\n        If provided, the step_percentage, min_percentage and max_percentage parameters will be ignored.\n        A list of percentages of deformations to use to deforme the environment's odor plume.\n    use_gpu : bool, default=False\n        Whether to use the GPU to speed up the tests.\n    print_progress : bool, default=True\n        Whether to display a progress bar of how many test have been performed so far.\n    print_stats : bool, default=True\n        Whether to display statistics at the end of each test.\n    save : bool, default=True\n        Whether to save the results of each test to a save_folder.\n        Each test's result will be under the name 'test_env_y-&lt;y_multiplier&gt;_x-&lt;x_multiplier&gt;.csv'\n    save_folder : str, optional\n        The path to which the test results are saved.\n        If not provided, it will automatically create a new folder './results/&lt;timestamp&gt;_shape_robustness_test_&lt;environment_name&gt;/'\n    save_analysis : bool, default=True\n        Whether to save the analysis of the histories.\n        It will be saved under a file named '_analysis.csv' in the save_folder.\n\n    Returns\n    -------\n    all_histories : list[SimulationHistory]\n        A list of SimulationHistory instances.\n    '''\n    # Handle the case an specific environment is given\n    environment_provided = environment is not None\n    if environment_provided:\n        assert environment.shape == agent.environment.shape, \"The provided environment's shape doesn't match the environment has been trained on...\"\n    else:\n        environment = agent.environment\n\n    # Gathering starting points\n    start_points = np.argwhere(environment.start_probabilities &gt; 0)\n    n = len(start_points)\n\n    # Generating multipliers\n    if multipliers is None:\n        with np.errstate(divide='ignore'):\n            low_max_mult = ((environment.margins[:,0] / environment.data_source_position) + 1)\n            high_max_mult = (1 + (environment.margins[:,1] / (environment.data_shape - environment.data_source_position)))\n            max_mult = np.min(np.vstack([low_max_mult, high_max_mult]), axis=0)\n\n        multipliers = [(100 - perc_mult) for perc_mult in range(0, (100-min_percentage)+step_percentage, step_percentage)[1:]] + [perc_mult for perc_mult in range(100, min(max_percentage, int(max(max_mult)*100)), step_percentage)]\n    multipliers.sort()\n\n    # Generating all combinations of multipliers\n    mult_combinations = np.array(np.meshgrid(multipliers, multipliers, indexing='xy')).T.reshape(-1,2).astype(float)\n    mult_combinations /= 100\n    mult_combinations = mult_combinations[np.all(mult_combinations &lt; max_mult, axis=1), :]\n\n    # Save Folder name and creation\n    if save or save_analysis:\n        if save_folder is None:\n            save_folder = f'./results/{datetime.now().strftime(\"%Y%m%d_%H%M%S\")}_shape_robustness_test_' + environment.name\n\n        if not os.path.exists(save_folder):\n            os.mkdir(save_folder)\n\n        print(f'The results will be saved to: {save_folder}\\n')\n\n    all_histories = []\n    for mults in (tqdm(mult_combinations) if print_progress else mult_combinations):\n        print(f'Testing on environment with height {int(mults[0]*100)}% and width {int(mults[1] * 100)}%')\n\n        # Modifying environment\n        modified_environment = environment.modify(multiplier=mults)\n\n        # Running test\n        hist = run_test(\n            agent = agent,\n            n = n,\n            start_points = start_points,\n            environment = modified_environment,\n            time_shift = time_shift,\n            time_loop = time_loop,\n            horizon = horizon,\n            initialization_values = initialization_values,\n            reward_discount = reward_discount,\n            print_progress = False,\n            print_stats = print_stats,\n            use_gpu = use_gpu\n        )\n\n        all_histories.append(hist)\n\n        # Saving history\n        if save:\n            file_name = f'test_env_y-{int(mults[0]*100)}_x-{int(mults[1]*100)}'\n            hist.save(file=file_name,\n                      folder=save_folder,\n                      save_analysis=False)\n\n        print()\n\n    # Analysis saving\n    if save and save_analysis:\n        analysis_df = analyse_shape_robustness(all_histories=all_histories, multipliers=(mult_combinations*100))\n        analysis_file_name = '_analysis.csv'\n        analysis_df.to_csv(save_folder + '/' + analysis_file_name, index=False)\n        print(f'Shape robustness analysis saved to: {save_folder}/{analysis_file_name}')\n\n    return all_histories\n</code></pre>"},{"location":"reference/visualization/","title":"visualization","text":""},{"location":"reference/visualization/#olfactory_navigation.visualization.plot_full_shape_robustness_analysis","title":"<code>plot_full_shape_robustness_analysis(robustness_analysis_df)</code>","text":"<p>Function to build a combined plot of all the metrics with and without the success trajectory filtering. The metrics used are 'converged', 'steps_taken', 'discounted_rewards', 'extra_steps', and 't_min_over_t'</p> <p>Parameters:</p> Name Type Description Default <code>robustness_analysis_df</code> <code>DataFrame</code> <p>The pandas dataframe to plot the full analysis on.</p> required Source code in <code>olfactory_navigation/visualization.py</code> <pre><code>def plot_full_shape_robustness_analysis(robustness_analysis_df: pd.DataFrame) -&gt; None:\n    '''\n    Function to build a combined plot of all the metrics with and without the success trajectory filtering.\n    The metrics used are 'converged', 'steps_taken', 'discounted_rewards', 'extra_steps', and 't_min_over_t'\n\n    Parameters\n    ----------\n    robustness_analysis_df : pd.DataFrame\n        The pandas dataframe to plot the full analysis on.\n    '''\n    _, axes = plt.subplots(5,2, figsize=(15,30))\n\n    # For each metric on each row and columns being success filtering off then on.\n    for row, metric in enumerate(['converged', 'steps_taken', 'discounted_rewards', 'extra_steps', 't_min_over_t']):\n        for col, success_only in enumerate([False, True]):\n            if (metric == 'converged') and (success_only):\n                axes[row, col].set_axis_off()\n                continue\n\n            plot_shape_robustness_performance(robustness_analysis_df, metric=metric, success_only=success_only, ax=axes[row, col])\n</code></pre>"},{"location":"reference/visualization/#olfactory_navigation.visualization.plot_shape_robustness_performance","title":"<code>plot_shape_robustness_performance(robustness_analysis_df, metric='converged', success_only=False, ax=None)</code>","text":"<p>Function to visualize the performance according to some metric for each multiplier on the horizontal and vertical axes. The metrics that can be chosen are among 'converged', 'steps_taken', 'discounted_rewards', 'extra_steps', or 't_min_over_t'.</p> <p>Parameters:</p> Name Type Description Default <code>robustness_analysis_df</code> <code>DataFrame</code> <p>The analysis dataframe from which to plot the comparison plot.</p> required <code>metric</code> <code>converged or steps_taken or discounted_rewards or extra_steps or t_min_over_t</code> <p>The metric to be used to compare the performance between different multiplier combinations.</p> <code>= 'converged'</code> <code>success_only</code> <code>bool</code> <p>Whether to use the results filtered only to the successful trajectories.</p> <code>False</code> <code>ax</code> <code>Axes</code> <p>A matplotlib axis on which to plot the comparison plot. If not provided, a new one will be created.</p> <code>None</code> Source code in <code>olfactory_navigation/visualization.py</code> <pre><code>def plot_shape_robustness_performance(robustness_analysis_df: pd.DataFrame,\n                                      metric: Literal['converged', 'steps_taken', 'discounted_rewards', 'extra_steps', 't_min_over_t'] = 'converged',\n                                      success_only: bool = False,\n                                      ax: plt.Axes = None\n                                      ) -&gt; None:\n    '''\n    Function to visualize the performance according to some metric for each multiplier on the horizontal and vertical axes.\n    The metrics that can be chosen are among 'converged', 'steps_taken', 'discounted_rewards', 'extra_steps', or 't_min_over_t'.\n\n    Parameters\n    ----------\n    robustness_analysis_df : pd.DataFrame\n        The analysis dataframe from which to plot the comparison plot.\n    metric : 'converged' or 'steps_taken' or 'discounted_rewards' or 'extra_steps' or 't_min_over_t', default = 'converged'\n        The metric to be used to compare the performance between different multiplier combinations.\n    success_only : bool, default=False\n        Whether to use the results filtered only to the successful trajectories.\n    ax : plt.Axes, optional\n        A matplotlib axis on which to plot the comparison plot. If not provided, a new one will be created.\n    '''\n    if ax is None:\n        _, ax = plt.subplots()\n\n    assert not ((metric == 'converged') and success_only), \"The 'converged' metric is not available for the 'success_only' option.\"\n\n    # Invert is lower is better\n    inverted = metric in ['steps_taken', 'extra_steps']\n\n    # If success only\n    metric += ('_success' if success_only else '')\n\n    # Processing data\n    mult_lists = {}\n    for col in ['y','x']:\n        mult_lists[col] = np.unique(robustness_analysis_df[col + '_multiplier'].to_numpy(dtype=int)).tolist()\n\n    grid_data = robustness_analysis_df[metric + '_mean'].to_numpy().reshape([len(mults) for mults in mult_lists.values()])\n\n    # Plotting data\n    im = ax.imshow(grid_data, cmap='RdYlGn' + ('_r' if inverted else ''))\n    cbar = ax.get_figure().colorbar(im)\n    cbar.set_label((' '.join(metric.split('_'))).capitalize() + ' Mean')\n\n    # Processing standard deviations\n    std_data = robustness_analysis_df[metric + '_standard_deviation'].to_numpy()\n    min_std, max_std = std_data.min(), std_data.max()\n    normalized_std_data = (99 * (std_data - min_std) / (max_std - min_std)) + 1\n    X,Y = np.meshgrid(np.arange(len(mult_lists['x'])), np.arange(len(mult_lists['y'])))\n    scatter = ax.scatter(X, Y, s=normalized_std_data, c='black')\n\n    dots = [1,100]\n    dot_labels = [f'{min_std:.2f}', f'{max_std:.2f}']\n\n    legend_handles,_ = scatter.legend_elements(prop='sizes', num=dots)\n    ax.legend(handles=legend_handles, labels=dot_labels, title='Standard\\ndeviations', loc='upper right', bbox_to_anchor=(1.6,1.0))\n\n    # Adding axis labels\n    ax.set_xlabel('Horizontal multiplier')\n    ax.set_xticks(np.arange(len(mult_lists['x'])), labels=[f'{mult}%' for mult in mult_lists['x']])\n\n    ax.set_ylabel('Vertical multiplier')\n    ax.set_yticks(np.arange(len(mult_lists['y'])), labels=[f'{mult}%' for mult in mult_lists['y']])\n</code></pre>"},{"location":"reference/agents/","title":"agents","text":""},{"location":"reference/agents/#olfactory_navigation.agents.FSVI_Agent","title":"<code>FSVI_Agent</code>","text":"<p>               Bases: <code>PBVI_Agent</code></p> <p>A particular flavor of the Point-Based Value Iteration based agent. The general concept relies on Model-Based reinforcement learning as described in: Pineau, J., Gordon, G., &amp; Thrun, S. (2003, August). Point-based value iteration: An anytime algorithm for POMDPs The Forward Search Value Iteration algorithm is described in: Shani, G., Brafman, R. I., &amp; Shimony, S. E. (2007, January). Forward Search Value Iteration for POMDPs</p> <p>The training consist in two steps:</p> <ul> <li> <p>Expand: Where belief points are explored based on the some strategy (to be defined by subclasses).</p> </li> <li> <p>Backup: Using the generated belief points, the value function is updated.</p> </li> </ul> <p>The belief points are probability distributions over the state space and are therefore vectors of |S| elements.</p> <p>Actions are chosen based on a value function. A value function is a set of alpha vectors of dimentionality |S|. Each alpha vector is associated to a single action but multiple alpha vectors can be associated to the same action. To choose an action at a given belief point, a dot product is taken between each alpha vector and the belief point and the action associated with the highest result is chosen.</p> <p>Forward Search exploration concept: It relies of the solution of the Fully-Observable (MDP) problem to guide the exploration of belief points. It makes an agent start randomly in the environment and makes him take steps following the MDP solution while generating belief points along the way. Each time the expand function is called it starts generated a new set of belief points and the update function uses only the latest generated belief points to make update the value function.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment to train the agent with.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.</p> <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <code>model</code> <code>Model</code> <p>A POMDP model to use to represent the olfactory environment. If not provided, the environment_converter parameter will be used.</p> <code>None</code> <code>environment_converter</code> <code>Callable</code> <p>A function to convert the olfactory environment instance to a POMDP Model instance. By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model. This parameter will be ignored if the model parameter is provided.</p> <code>exact_converter</code> <code>converter_parameters</code> <code>dict</code> <p>A set of additional parameters to be passed down to the environment converter.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>model</code> <code>Model</code> <p>The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.</p> <code>saved_at</code> <code>str</code> <p>The place on disk where the agent has been saved (None if not saved yet).</p> <code>on_gpu</code> <code>bool</code> <p>Whether the agent has been sent to the gpu or not.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>trained_at</code> <code>str</code> <p>A string timestamp of when the agent has been trained (None if not trained yet).</p> <code>value_function</code> <code>ValueFunction</code> <p>The value function used for the agent to make decisions.</p> <code>belief</code> <code>BeliefSet</code> <p>Used only during simulations. Part of the Agent's status. Where the agent believes he is over the state space. It is a list of n belief points based on how many simulations are running at once.</p> <code>action_played</code> <code>list[int]</code> <p>Used only during simulations. Part of the Agent's status. Records what action was last played by the agent. A list of n actions played based on how many simulations are running at once.</p> <code>mdp_policy</code> <code>ValueFunction</code> <p>The solution to the fully version of the problem.</p> Source code in <code>olfactory_navigation/agents/fsvi_agent.py</code> <pre><code>class FSVI_Agent(PBVI_Agent):\n    '''\n    A particular flavor of the Point-Based Value Iteration based agent.\n    The general concept relies on Model-Based reinforcement learning as described in: Pineau, J., Gordon, G., &amp; Thrun, S. (2003, August). Point-based value iteration: An anytime algorithm for POMDPs\n    The Forward Search Value Iteration algorithm is described in: Shani, G., Brafman, R. I., &amp; Shimony, S. E. (2007, January). Forward Search Value Iteration for POMDPs\n\n    The training consist in two steps:\n\n    - Expand: Where belief points are explored based on the some strategy (to be defined by subclasses).\n\n    - Backup: Using the generated belief points, the value function is updated.\n\n    The belief points are probability distributions over the state space and are therefore vectors of |S| elements.\n\n    Actions are chosen based on a value function. A value function is a set of alpha vectors of dimentionality |S|.\n    Each alpha vector is associated to a single action but multiple alpha vectors can be associated to the same action.\n    To choose an action at a given belief point, a dot product is taken between each alpha vector and the belief point and the action associated with the highest result is chosen.\n\n    Forward Search exploration concept:\n    It relies of the solution of the Fully-Observable (MDP) problem to guide the exploration of belief points.\n    It makes an agent start randomly in the environment and makes him take steps following the MDP solution while generating belief points along the way.\n    Each time the expand function is called it starts generated a new set of belief points and the update function uses only the latest generated belief points to make update the value function.\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment to train the agent with.\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.\n    seed : int, default=12131415\n        For reproducible randomness.\n    model : Model, optional\n        A POMDP model to use to represent the olfactory environment.\n        If not provided, the environment_converter parameter will be used.\n    environment_converter : Callable, default=exact_converter\n        A function to convert the olfactory environment instance to a POMDP Model instance.\n        By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model.\n        This parameter will be ignored if the model parameter is provided.\n    converter_parameters : dict, optional\n        A set of additional parameters to be passed down to the environment converter.\n\n    Attributes\n    ---------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    model : pomdp.Model\n        The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.\n    saved_at : str\n        The place on disk where the agent has been saved (None if not saved yet).\n    on_gpu : bool\n        Whether the agent has been sent to the gpu or not.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    trained_at : str\n        A string timestamp of when the agent has been trained (None if not trained yet).\n    value_function : ValueFunction\n        The value function used for the agent to make decisions.\n    belief : BeliefSet\n        Used only during simulations.\n        Part of the Agent's status. Where the agent believes he is over the state space.\n        It is a list of n belief points based on how many simulations are running at once.\n    action_played : list[int]\n        Used only during simulations.\n        Part of the Agent's status. Records what action was last played by the agent.\n        A list of n actions played based on how many simulations are running at once.\n    mdp_policy : ValueFunction\n        The solution to the fully version of the problem.\n    '''\n    # FSVI special attribute\n    mdp_policy = None\n\n    def expand(self,\n               belief_set: BeliefSet,\n               value_function: ValueFunction,\n               max_generation: int,\n               mdp_policy: ValueFunction\n               ) -&gt; BeliefSet:\n        '''\n        Function implementing the exploration process using the MDP policy in order to generate a sequence of Beliefs following the the Forward Search Value Iteration principles.\n        It is a loop is started by a initial state 's' and using the MDP policy, chooses the best action to take.\n        Following this, a random next state 's_p' is being sampled from the transition probabilities and a random observation 'o' based on the observation probabilities.\n        Then the given belief is updated using the chosen action and the observation received and the updated belief is added to the sequence.\n        Once the state is a goal state, the loop is done and the belief sequence is returned.\n\n        Parameters\n        ----------\n        belief_set : BeliefSet\n            A belief set containing a single belief to start the sequence with.\n            A random state will be chosen based on the probability distribution of the belief.\n        value_function : ValueFunction\n            The current value function. (NOT USED)\n        max_generation : int\n            How many beliefs to be generated at most.\n        mdp_policy : ValueFunction\n            The mdp policy used to choose the action from with the given state 's'.\n\n        Returns\n        -------\n        belief_set : BeliefSet\n            A new sequence of beliefs.\n        '''\n        # GPU support\n        xp = np if not self.on_gpu else cp\n        model = self.model\n\n        # Getting initial belief\n        b0 = belief_set.belief_list[0]\n        belief_list = [b0]\n\n        # Choose a random starting state\n        s = b0.random_state()\n\n        # Setting the working belief\n        b = b0\n\n        for _ in range(max_generation - 1): #-1 due to a one belief already being present in the set\n            # Choose action based on mdp value function\n            a_star = xp.argmax(mdp_policy.alpha_vector_array[:,s])\n\n            # Pick a random next state (weighted by transition probabilities)\n            s_p = model.transition(s, a_star)\n\n            # Pick a random observation weighted by observation probabilities in state s_p and after having done action a_star\n            o = model.observe(s_p, a_star)\n\n            # Generate a new belief based on a_star and o\n            b_p = b.update(a_star, o)\n\n            # Record new belief\n            belief_list.append(b_p)\n\n            # Updating s and b\n            s = s_p\n            b = b_p\n\n            # Reset and belief if end state is reached\n            if s in model.end_states:\n                s = b0.random_state()\n                b = b0\n\n        return BeliefSet(model, belief_list)\n\n\n    def train(self,\n              expansions: int,\n              update_passes: int = 1,\n              max_belief_growth: int = 10,\n              initial_belief: BeliefSet | Belief | None = None,\n              initial_value_function: ValueFunction | None = None,\n              mdp_policy: ValueFunction | None = None,\n              prune_level: int = 1,\n              prune_interval: int = 10,\n              limit_value_function_size: int = -1,\n              gamma: float = 0.99,\n              eps: float = 1e-6,\n              use_gpu: bool = False,\n              history_tracking_level: int = 1,\n              overwrite_training: bool = False,\n              print_progress: bool = True,\n              print_stats: bool = True\n              ) -&gt; TrainingHistory:\n        '''\n        Main loop of the Point-Based Value Iteration algorithm.\n        It consists in 2 steps, Backup and Expand.\n        1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n        2. Backup: Updates the alpha vectors based on the current belief set\n\n        Foward Search Value Iteration:\n        - By default it performs the backup only on set of beliefs generated by the expand function. (so it full_backup=False)\n\n        Parameters\n        ----------\n        expansions : int\n            How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n        update_passes : int, default=1\n            How many times the backup function has to be run every time the belief set is expanded.\n        max_belief_growth : int, default=10\n            How many beliefs can be added at every expansion step to the belief set.\n        initial_belief : BeliefSet or Belief, optional\n            An initial list of beliefs to start with.\n        initial_value_function : ValueFunction, optional\n            An initial value function to start the solving process with.\n        mdp_policy : ValueFunction, optional\n            The MDP solution to guide the expand process.\n            If it is not provided, the Value Iteration for the MDP version of the problem will be run. (using the same gamma and eps as set here; horizon=1000)\n        prune_level : int, default=1\n            Parameter to prune the value function further before the expand function.\n        prune_interval : int, default=10\n            How often to prune the value function. It is counted in number of backup iterations.\n        limit_value_function_size : int, default=-1\n            When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n            If set to -1, the value function can grow without bounds.\n        use_gpu : bool, default=False\n            Whether to use the GPU with cupy array to accelerate solving.\n        gamma : float, default=0.99\n            The discount factor to value immediate rewards more than long term rewards.\n            The learning rate is 1/gamma.\n        eps : float, default=1e-6\n            The smallest allowed changed for the value function.\n            Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n        history_tracking_level : int, default=1\n            How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n        overwrite_training : bool, default=False\n            Whether to force the overwriting of the training if a value function already exists for this agent.\n        print_progress : bool, default=True\n            Whether or not to print out the progress of the value iteration process.\n        print_stats : bool, default=True\n            Whether or not to print out statistics at the end of the training run.\n\n        Returns\n        -------\n        solver_history : SolverHistory\n            The history of the solving process with some plotting options.\n        '''\n        if mdp_policy is not None:\n            self.mdp_policy = mdp_policy\n        elif (self.mdp_policy is None) or overwrite_training:\n            log('MDP_policy, not provided. Solving MDP with Value Iteration...')\n            self.mdp_policy, hist = vi_solver.solve(model = self.model,\n                                                    horizon = 1000,\n                                                    initial_value_function = initial_value_function,\n                                                    gamma = gamma,\n                                                    eps = eps,\n                                                    use_gpu = use_gpu,\n                                                    history_tracking_level = 1,\n                                                    print_progress = print_progress)\n\n            if print_stats:\n                print(hist.summary)\n\n        return super().train(expansions = expansions,\n                             full_backup = False,\n                             update_passes = update_passes,\n                             max_belief_growth = max_belief_growth,\n                             initial_belief = initial_belief,\n                             initial_value_function = initial_value_function,\n                             prune_level = prune_level,\n                             prune_interval = prune_interval,\n                             limit_value_function_size = limit_value_function_size,\n                             gamma = gamma,\n                             eps = eps,\n                             use_gpu = use_gpu,\n                             history_tracking_level = history_tracking_level,\n                             overwrite_training = overwrite_training,\n                             print_progress = print_progress,\n                             print_stats = print_stats,\n                             mdp_policy = self.mdp_policy)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.FSVI_Agent.expand","title":"<code>expand(belief_set, value_function, max_generation, mdp_policy)</code>","text":"<p>Function implementing the exploration process using the MDP policy in order to generate a sequence of Beliefs following the the Forward Search Value Iteration principles. It is a loop is started by a initial state 's' and using the MDP policy, chooses the best action to take. Following this, a random next state 's_p' is being sampled from the transition probabilities and a random observation 'o' based on the observation probabilities. Then the given belief is updated using the chosen action and the observation received and the updated belief is added to the sequence. Once the state is a goal state, the loop is done and the belief sequence is returned.</p> <p>Parameters:</p> Name Type Description Default <code>belief_set</code> <code>BeliefSet</code> <p>A belief set containing a single belief to start the sequence with. A random state will be chosen based on the probability distribution of the belief.</p> required <code>value_function</code> <code>ValueFunction</code> <p>The current value function. (NOT USED)</p> required <code>max_generation</code> <code>int</code> <p>How many beliefs to be generated at most.</p> required <code>mdp_policy</code> <code>ValueFunction</code> <p>The mdp policy used to choose the action from with the given state 's'.</p> required <p>Returns:</p> Name Type Description <code>belief_set</code> <code>BeliefSet</code> <p>A new sequence of beliefs.</p> Source code in <code>olfactory_navigation/agents/fsvi_agent.py</code> <pre><code>def expand(self,\n           belief_set: BeliefSet,\n           value_function: ValueFunction,\n           max_generation: int,\n           mdp_policy: ValueFunction\n           ) -&gt; BeliefSet:\n    '''\n    Function implementing the exploration process using the MDP policy in order to generate a sequence of Beliefs following the the Forward Search Value Iteration principles.\n    It is a loop is started by a initial state 's' and using the MDP policy, chooses the best action to take.\n    Following this, a random next state 's_p' is being sampled from the transition probabilities and a random observation 'o' based on the observation probabilities.\n    Then the given belief is updated using the chosen action and the observation received and the updated belief is added to the sequence.\n    Once the state is a goal state, the loop is done and the belief sequence is returned.\n\n    Parameters\n    ----------\n    belief_set : BeliefSet\n        A belief set containing a single belief to start the sequence with.\n        A random state will be chosen based on the probability distribution of the belief.\n    value_function : ValueFunction\n        The current value function. (NOT USED)\n    max_generation : int\n        How many beliefs to be generated at most.\n    mdp_policy : ValueFunction\n        The mdp policy used to choose the action from with the given state 's'.\n\n    Returns\n    -------\n    belief_set : BeliefSet\n        A new sequence of beliefs.\n    '''\n    # GPU support\n    xp = np if not self.on_gpu else cp\n    model = self.model\n\n    # Getting initial belief\n    b0 = belief_set.belief_list[0]\n    belief_list = [b0]\n\n    # Choose a random starting state\n    s = b0.random_state()\n\n    # Setting the working belief\n    b = b0\n\n    for _ in range(max_generation - 1): #-1 due to a one belief already being present in the set\n        # Choose action based on mdp value function\n        a_star = xp.argmax(mdp_policy.alpha_vector_array[:,s])\n\n        # Pick a random next state (weighted by transition probabilities)\n        s_p = model.transition(s, a_star)\n\n        # Pick a random observation weighted by observation probabilities in state s_p and after having done action a_star\n        o = model.observe(s_p, a_star)\n\n        # Generate a new belief based on a_star and o\n        b_p = b.update(a_star, o)\n\n        # Record new belief\n        belief_list.append(b_p)\n\n        # Updating s and b\n        s = s_p\n        b = b_p\n\n        # Reset and belief if end state is reached\n        if s in model.end_states:\n            s = b0.random_state()\n            b = b0\n\n    return BeliefSet(model, belief_list)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.FSVI_Agent.train","title":"<code>train(expansions, update_passes=1, max_belief_growth=10, initial_belief=None, initial_value_function=None, mdp_policy=None, prune_level=1, prune_interval=10, limit_value_function_size=-1, gamma=0.99, eps=1e-06, use_gpu=False, history_tracking_level=1, overwrite_training=False, print_progress=True, print_stats=True)</code>","text":"<p>Main loop of the Point-Based Value Iteration algorithm. It consists in 2 steps, Backup and Expand. 1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function 2. Backup: Updates the alpha vectors based on the current belief set</p> <p>Foward Search Value Iteration: - By default it performs the backup only on set of beliefs generated by the expand function. (so it full_backup=False)</p> <p>Parameters:</p> Name Type Description Default <code>expansions</code> <code>int</code> <p>How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)</p> required <code>update_passes</code> <code>int</code> <p>How many times the backup function has to be run every time the belief set is expanded.</p> <code>1</code> <code>max_belief_growth</code> <code>int</code> <p>How many beliefs can be added at every expansion step to the belief set.</p> <code>10</code> <code>initial_belief</code> <code>BeliefSet or Belief</code> <p>An initial list of beliefs to start with.</p> <code>None</code> <code>initial_value_function</code> <code>ValueFunction</code> <p>An initial value function to start the solving process with.</p> <code>None</code> <code>mdp_policy</code> <code>ValueFunction</code> <p>The MDP solution to guide the expand process. If it is not provided, the Value Iteration for the MDP version of the problem will be run. (using the same gamma and eps as set here; horizon=1000)</p> <code>None</code> <code>prune_level</code> <code>int</code> <p>Parameter to prune the value function further before the expand function.</p> <code>1</code> <code>prune_interval</code> <code>int</code> <p>How often to prune the value function. It is counted in number of backup iterations.</p> <code>10</code> <code>limit_value_function_size</code> <code>int</code> <p>When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function If set to -1, the value function can grow without bounds.</p> <code>-1</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU with cupy array to accelerate solving.</p> <code>False</code> <code>gamma</code> <code>float</code> <p>The discount factor to value immediate rewards more than long term rewards. The learning rate is 1/gamma.</p> <code>0.99</code> <code>eps</code> <code>float</code> <p>The smallest allowed changed for the value function. Bellow the amound of change, the value function is considered converged and the value iteration process will end early.</p> <code>1e-6</code> <code>history_tracking_level</code> <code>int</code> <p>How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)</p> <code>1</code> <code>overwrite_training</code> <code>bool</code> <p>Whether to force the overwriting of the training if a value function already exists for this agent.</p> <code>False</code> <code>print_progress</code> <code>bool</code> <p>Whether or not to print out the progress of the value iteration process.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether or not to print out statistics at the end of the training run.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>solver_history</code> <code>SolverHistory</code> <p>The history of the solving process with some plotting options.</p> Source code in <code>olfactory_navigation/agents/fsvi_agent.py</code> <pre><code>def train(self,\n          expansions: int,\n          update_passes: int = 1,\n          max_belief_growth: int = 10,\n          initial_belief: BeliefSet | Belief | None = None,\n          initial_value_function: ValueFunction | None = None,\n          mdp_policy: ValueFunction | None = None,\n          prune_level: int = 1,\n          prune_interval: int = 10,\n          limit_value_function_size: int = -1,\n          gamma: float = 0.99,\n          eps: float = 1e-6,\n          use_gpu: bool = False,\n          history_tracking_level: int = 1,\n          overwrite_training: bool = False,\n          print_progress: bool = True,\n          print_stats: bool = True\n          ) -&gt; TrainingHistory:\n    '''\n    Main loop of the Point-Based Value Iteration algorithm.\n    It consists in 2 steps, Backup and Expand.\n    1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n    2. Backup: Updates the alpha vectors based on the current belief set\n\n    Foward Search Value Iteration:\n    - By default it performs the backup only on set of beliefs generated by the expand function. (so it full_backup=False)\n\n    Parameters\n    ----------\n    expansions : int\n        How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n    update_passes : int, default=1\n        How many times the backup function has to be run every time the belief set is expanded.\n    max_belief_growth : int, default=10\n        How many beliefs can be added at every expansion step to the belief set.\n    initial_belief : BeliefSet or Belief, optional\n        An initial list of beliefs to start with.\n    initial_value_function : ValueFunction, optional\n        An initial value function to start the solving process with.\n    mdp_policy : ValueFunction, optional\n        The MDP solution to guide the expand process.\n        If it is not provided, the Value Iteration for the MDP version of the problem will be run. (using the same gamma and eps as set here; horizon=1000)\n    prune_level : int, default=1\n        Parameter to prune the value function further before the expand function.\n    prune_interval : int, default=10\n        How often to prune the value function. It is counted in number of backup iterations.\n    limit_value_function_size : int, default=-1\n        When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n        If set to -1, the value function can grow without bounds.\n    use_gpu : bool, default=False\n        Whether to use the GPU with cupy array to accelerate solving.\n    gamma : float, default=0.99\n        The discount factor to value immediate rewards more than long term rewards.\n        The learning rate is 1/gamma.\n    eps : float, default=1e-6\n        The smallest allowed changed for the value function.\n        Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n    history_tracking_level : int, default=1\n        How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n    overwrite_training : bool, default=False\n        Whether to force the overwriting of the training if a value function already exists for this agent.\n    print_progress : bool, default=True\n        Whether or not to print out the progress of the value iteration process.\n    print_stats : bool, default=True\n        Whether or not to print out statistics at the end of the training run.\n\n    Returns\n    -------\n    solver_history : SolverHistory\n        The history of the solving process with some plotting options.\n    '''\n    if mdp_policy is not None:\n        self.mdp_policy = mdp_policy\n    elif (self.mdp_policy is None) or overwrite_training:\n        log('MDP_policy, not provided. Solving MDP with Value Iteration...')\n        self.mdp_policy, hist = vi_solver.solve(model = self.model,\n                                                horizon = 1000,\n                                                initial_value_function = initial_value_function,\n                                                gamma = gamma,\n                                                eps = eps,\n                                                use_gpu = use_gpu,\n                                                history_tracking_level = 1,\n                                                print_progress = print_progress)\n\n        if print_stats:\n            print(hist.summary)\n\n    return super().train(expansions = expansions,\n                         full_backup = False,\n                         update_passes = update_passes,\n                         max_belief_growth = max_belief_growth,\n                         initial_belief = initial_belief,\n                         initial_value_function = initial_value_function,\n                         prune_level = prune_level,\n                         prune_interval = prune_interval,\n                         limit_value_function_size = limit_value_function_size,\n                         gamma = gamma,\n                         eps = eps,\n                         use_gpu = use_gpu,\n                         history_tracking_level = history_tracking_level,\n                         overwrite_training = overwrite_training,\n                         print_progress = print_progress,\n                         print_stats = print_stats,\n                         mdp_policy = self.mdp_policy)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.HSVI_Agent","title":"<code>HSVI_Agent</code>","text":"<p>               Bases: <code>PBVI_Agent</code></p> <p>A flavor of the PBVI Agent.</p>"},{"location":"reference/agents/#olfactory_navigation.agents.HSVI_Agent--todo-do-document-of-hsvi-agent","title":"TODO: Do document of HSVI agent","text":""},{"location":"reference/agents/#olfactory_navigation.agents.HSVI_Agent--todo-fix-hsvi-expand","title":"TODO: FIX HSVI expand","text":"<p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment to train the agent with.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.</p> <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <code>model</code> <code>Model</code> <p>A POMDP model to use to represent the olfactory environment. If not provided, the environment_converter parameter will be used.</p> <code>None</code> <code>environment_converter</code> <code>Callable</code> <p>A function to convert the olfactory environment instance to a POMDP Model instance. By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model. This parameter will be ignored if the model parameter is provided.</p> <code>exact_converter</code> <code>converter_parameters</code> <code>dict</code> <p>A set of additional parameters to be passed down to the environment converter.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>model</code> <code>Model</code> <p>The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.</p> <code>saved_at</code> <code>str</code> <p>The place on disk where the agent has been saved (None if not saved yet).</p> <code>on_gpu</code> <code>bool</code> <p>Whether the agent has been sent to the gpu or not.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>trained_at</code> <code>str</code> <p>A string timestamp of when the agent has been trained (None if not trained yet).</p> <code>value_function</code> <code>ValueFunction</code> <p>The value function used for the agent to make decisions.</p> <code>belief</code> <code>BeliefSet</code> <p>Used only during simulations. Part of the Agent's status. Where the agent believes he is over the state space. It is a list of n belief points based on how many simulations are running at once.</p> <code>action_played</code> <code>list[int]</code> <p>Used only during simulations. Part of the Agent's status. Records what action was last played by the agent. A list of n actions played based on how many simulations are running at once.</p> Source code in <code>olfactory_navigation/agents/hsvi_agent.py</code> <pre><code>class HSVI_Agent(PBVI_Agent):\n    '''\n    A flavor of the PBVI Agent.\n\n    # TODO: Do document of HSVI agent\n    # TODO: FIX HSVI expand\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment to train the agent with.\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.\n    seed : int, default=12131415\n        For reproducible randomness.\n    model : Model, optional\n        A POMDP model to use to represent the olfactory environment.\n        If not provided, the environment_converter parameter will be used.\n    environment_converter : Callable, default=exact_converter\n        A function to convert the olfactory environment instance to a POMDP Model instance.\n        By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model.\n        This parameter will be ignored if the model parameter is provided.\n    converter_parameters : dict, optional\n        A set of additional parameters to be passed down to the environment converter.\n\n    Attributes\n    ---------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    model : pomdp.Model\n        The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.\n    saved_at : str\n        The place on disk where the agent has been saved (None if not saved yet).\n    on_gpu : bool\n        Whether the agent has been sent to the gpu or not.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    trained_at : str\n        A string timestamp of when the agent has been trained (None if not trained yet).\n    value_function : ValueFunction\n        The value function used for the agent to make decisions.\n    belief : BeliefSet\n        Used only during simulations.\n        Part of the Agent's status. Where the agent believes he is over the state space.\n        It is a list of n belief points based on how many simulations are running at once.\n    action_played : list[int]\n        Used only during simulations.\n        Part of the Agent's status. Records what action was last played by the agent.\n        A list of n actions played based on how many simulations are running at once.\n    '''\n    def expand(self,\n               belief_set: BeliefSet,\n               value_function: ValueFunction,\n               max_generation: int\n               ) -&gt; BeliefSet:\n        '''\n        The expand function of the  Heuristic Search Value Iteration (HSVI) technique.\n        It is a redursive function attempting to minimize the bound between the upper and lower estimations of the value function.\n\n        It is developped by Smith T. and Simmons R. and described in the paper \"Heuristic Search Value Iteration for POMDPs\".\n\n        Parameters\n        ----------\n        belief_set : BeliefSet\n            List of beliefs to expand on.\n        value_function : ValueFunction\n            The current value function. Used to compute the value at belief points.\n        max_generation : int, default=10\n            The max amount of beliefs that can be added to the belief set at once.\n\n        Returns\n        -------\n        belief_set : BeliefSet\n            A new sequence of beliefs.\n        '''\n        # GPU support\n        xp = np if not self.on_gpu else cp\n        model = self.model\n\n        if conv_term is None:\n            conv_term = self.eps\n\n        # Update convergence term\n        conv_term /= self.gamma\n\n        # Find best a based on upper bound v\n        max_qv = -xp.inf\n        best_a = -1\n        for a in model.actions:\n            b_probs = xp.einsum('sor,s-&gt;o', model.reachable_transitional_observation_table[:,a,:,:], b.values)\n\n            b_prob_val = 0\n            for o in model.observations:\n                b_prob_val += (b_probs[o] * upper_bound_belief_value_map.evaluate(b.update(a,o)))\n\n            qva = float(xp.dot(model.expected_rewards_table[:,a], b.values) + (self.gamma * b_prob_val))\n\n            # qva = upper_bound_belief_value_map.qva(b, a, gamma=self.gamma)\n            if qva &gt; max_qv:\n                max_qv = qva\n                best_a = a\n\n        # Choose o that max gap between bounds\n        b_probs = xp.einsum('sor,s-&gt;o', model.reachable_transitional_observation_table[:,best_a,:,:], b.values)\n\n        max_o_val = -xp.inf\n        best_v_diff = -xp.inf\n        next_b = b\n\n        for o in model.observations:\n            bao = b.update(best_a, o)\n\n            upper_v_bao = upper_bound_belief_value_map.evaluate(bao)\n            lower_v_bao = xp.max(xp.dot(value_function.alpha_vector_array, bao.values))\n\n            v_diff = (upper_v_bao - lower_v_bao)\n\n            o_val = b_probs[o] * v_diff\n\n            if o_val &gt; max_o_val:\n                max_o_val = o_val\n                best_v_diff = v_diff\n                next_b = bao\n\n        # if bounds_split &lt; conv_term or max_generation &lt;= 0:\n        if best_v_diff &lt; conv_term or max_generation &lt;= 1:\n            return BeliefSet(model, [next_b])\n\n        # Add the belief point and associated value to the belief-value mapping\n        upper_bound_belief_value_map.add(b, max_qv)\n\n        # Go one step deeper in the recursion\n        b_set = self.expand_hsvi(model=model,\n                                 b=next_b,\n                                 value_function=value_function,\n                                 upper_bound_belief_value_map=upper_bound_belief_value_map,\n                                 conv_term=conv_term,\n                                 max_generation=max_generation-1)\n\n        # Append the nex belief of this iteration to the deeper beliefs\n        new_belief_list = b_set.belief_list\n        new_belief_list.append(next_b)\n\n        return BeliefSet(model, new_belief_list)\n\n\n    def train(self,\n              expansions: int,\n              update_passes: int = 1,\n              max_belief_growth: int = 10,\n              initial_belief: BeliefSet | Belief | None = None,\n              initial_value_function: ValueFunction | None = None,\n              prune_level: int = 1,\n              prune_interval: int = 10,\n              limit_value_function_size: int = -1,\n              gamma: float = 0.99,\n              eps: float = 1e-6,\n              use_gpu: bool = False,\n              history_tracking_level: int = 1,\n              overwrite_training: bool = False,\n              print_progress: bool = True,\n              print_stats: bool = True\n              ) -&gt; TrainingHistory:\n        '''\n        Main loop of the Point-Based Value Iteration algorithm.\n        It consists in 2 steps, Backup and Expand.\n        1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n        2. Backup: Updates the alpha vectors based on the current belief set\n\n        Heuristic Search Value Iteration:\n        - By default it performs the backup only on set of beliefs generated by the expand function. (so it full_backup=False)\n\n        Parameters\n        ----------\n        expansions : int\n            How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n        update_passes : int, default=1\n            How many times the backup function has to be run every time the belief set is expanded.\n        max_belief_growth : int, default=10\n            How many beliefs can be added at every expansion step to the belief set.\n        initial_belief : BeliefSet or Belief, optional\n            An initial list of beliefs to start with.\n        initial_value_function : ValueFunction, optional\n            An initial value function to start the solving process with.\n        prune_level : int, default=1\n            Parameter to prune the value function further before the expand function.\n        prune_interval : int, default=10\n            How often to prune the value function. It is counted in number of backup iterations.\n        limit_value_function_size : int, default=-1\n            When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n            If set to -1, the value function can grow without bounds.\n        use_gpu : bool, default=False\n            Whether to use the GPU with cupy array to accelerate solving.\n        gamma : float, default=0.99\n            The discount factor to value immediate rewards more than long term rewards.\n            The learning rate is 1/gamma.\n        eps : float, default=1e-6\n            The smallest allowed changed for the value function.\n            Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n        history_tracking_level : int, default=1\n            How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n        overwrite_training : bool, default=False\n            Whether to force the overwriting of the training if a value function already exists for this agent.\n        print_progress : bool, default=True\n            Whether or not to print out the progress of the value iteration process.\n        print_stats : bool, default=True\n            Whether or not to print out statistics at the end of the training run.\n\n        Returns\n        -------\n        solver_history : SolverHistory\n            The history of the solving process with some plotting options.\n        '''\n        return super().train(expansions = expansions,\n                             full_backup = False,\n                             update_passes = update_passes,\n                             max_belief_growth = max_belief_growth,\n                             initial_belief = initial_belief,\n                             initial_value_function = initial_value_function,\n                             prune_level = prune_level,\n                             prune_interval = prune_interval,\n                             limit_value_function_size = limit_value_function_size,\n                             gamma = gamma,\n                             eps = eps,\n                             use_gpu = use_gpu,\n                             history_tracking_level = history_tracking_level,\n                             overwrite_training = overwrite_training,\n                             print_progress = print_progress,\n                             print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.HSVI_Agent.expand","title":"<code>expand(belief_set, value_function, max_generation)</code>","text":"<p>The expand function of the  Heuristic Search Value Iteration (HSVI) technique. It is a redursive function attempting to minimize the bound between the upper and lower estimations of the value function.</p> <p>It is developped by Smith T. and Simmons R. and described in the paper \"Heuristic Search Value Iteration for POMDPs\".</p> <p>Parameters:</p> Name Type Description Default <code>belief_set</code> <code>BeliefSet</code> <p>List of beliefs to expand on.</p> required <code>value_function</code> <code>ValueFunction</code> <p>The current value function. Used to compute the value at belief points.</p> required <code>max_generation</code> <code>int</code> <p>The max amount of beliefs that can be added to the belief set at once.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>belief_set</code> <code>BeliefSet</code> <p>A new sequence of beliefs.</p> Source code in <code>olfactory_navigation/agents/hsvi_agent.py</code> <pre><code>def expand(self,\n           belief_set: BeliefSet,\n           value_function: ValueFunction,\n           max_generation: int\n           ) -&gt; BeliefSet:\n    '''\n    The expand function of the  Heuristic Search Value Iteration (HSVI) technique.\n    It is a redursive function attempting to minimize the bound between the upper and lower estimations of the value function.\n\n    It is developped by Smith T. and Simmons R. and described in the paper \"Heuristic Search Value Iteration for POMDPs\".\n\n    Parameters\n    ----------\n    belief_set : BeliefSet\n        List of beliefs to expand on.\n    value_function : ValueFunction\n        The current value function. Used to compute the value at belief points.\n    max_generation : int, default=10\n        The max amount of beliefs that can be added to the belief set at once.\n\n    Returns\n    -------\n    belief_set : BeliefSet\n        A new sequence of beliefs.\n    '''\n    # GPU support\n    xp = np if not self.on_gpu else cp\n    model = self.model\n\n    if conv_term is None:\n        conv_term = self.eps\n\n    # Update convergence term\n    conv_term /= self.gamma\n\n    # Find best a based on upper bound v\n    max_qv = -xp.inf\n    best_a = -1\n    for a in model.actions:\n        b_probs = xp.einsum('sor,s-&gt;o', model.reachable_transitional_observation_table[:,a,:,:], b.values)\n\n        b_prob_val = 0\n        for o in model.observations:\n            b_prob_val += (b_probs[o] * upper_bound_belief_value_map.evaluate(b.update(a,o)))\n\n        qva = float(xp.dot(model.expected_rewards_table[:,a], b.values) + (self.gamma * b_prob_val))\n\n        # qva = upper_bound_belief_value_map.qva(b, a, gamma=self.gamma)\n        if qva &gt; max_qv:\n            max_qv = qva\n            best_a = a\n\n    # Choose o that max gap between bounds\n    b_probs = xp.einsum('sor,s-&gt;o', model.reachable_transitional_observation_table[:,best_a,:,:], b.values)\n\n    max_o_val = -xp.inf\n    best_v_diff = -xp.inf\n    next_b = b\n\n    for o in model.observations:\n        bao = b.update(best_a, o)\n\n        upper_v_bao = upper_bound_belief_value_map.evaluate(bao)\n        lower_v_bao = xp.max(xp.dot(value_function.alpha_vector_array, bao.values))\n\n        v_diff = (upper_v_bao - lower_v_bao)\n\n        o_val = b_probs[o] * v_diff\n\n        if o_val &gt; max_o_val:\n            max_o_val = o_val\n            best_v_diff = v_diff\n            next_b = bao\n\n    # if bounds_split &lt; conv_term or max_generation &lt;= 0:\n    if best_v_diff &lt; conv_term or max_generation &lt;= 1:\n        return BeliefSet(model, [next_b])\n\n    # Add the belief point and associated value to the belief-value mapping\n    upper_bound_belief_value_map.add(b, max_qv)\n\n    # Go one step deeper in the recursion\n    b_set = self.expand_hsvi(model=model,\n                             b=next_b,\n                             value_function=value_function,\n                             upper_bound_belief_value_map=upper_bound_belief_value_map,\n                             conv_term=conv_term,\n                             max_generation=max_generation-1)\n\n    # Append the nex belief of this iteration to the deeper beliefs\n    new_belief_list = b_set.belief_list\n    new_belief_list.append(next_b)\n\n    return BeliefSet(model, new_belief_list)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.HSVI_Agent.train","title":"<code>train(expansions, update_passes=1, max_belief_growth=10, initial_belief=None, initial_value_function=None, prune_level=1, prune_interval=10, limit_value_function_size=-1, gamma=0.99, eps=1e-06, use_gpu=False, history_tracking_level=1, overwrite_training=False, print_progress=True, print_stats=True)</code>","text":"<p>Main loop of the Point-Based Value Iteration algorithm. It consists in 2 steps, Backup and Expand. 1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function 2. Backup: Updates the alpha vectors based on the current belief set</p> <p>Heuristic Search Value Iteration: - By default it performs the backup only on set of beliefs generated by the expand function. (so it full_backup=False)</p> <p>Parameters:</p> Name Type Description Default <code>expansions</code> <code>int</code> <p>How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)</p> required <code>update_passes</code> <code>int</code> <p>How many times the backup function has to be run every time the belief set is expanded.</p> <code>1</code> <code>max_belief_growth</code> <code>int</code> <p>How many beliefs can be added at every expansion step to the belief set.</p> <code>10</code> <code>initial_belief</code> <code>BeliefSet or Belief</code> <p>An initial list of beliefs to start with.</p> <code>None</code> <code>initial_value_function</code> <code>ValueFunction</code> <p>An initial value function to start the solving process with.</p> <code>None</code> <code>prune_level</code> <code>int</code> <p>Parameter to prune the value function further before the expand function.</p> <code>1</code> <code>prune_interval</code> <code>int</code> <p>How often to prune the value function. It is counted in number of backup iterations.</p> <code>10</code> <code>limit_value_function_size</code> <code>int</code> <p>When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function If set to -1, the value function can grow without bounds.</p> <code>-1</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU with cupy array to accelerate solving.</p> <code>False</code> <code>gamma</code> <code>float</code> <p>The discount factor to value immediate rewards more than long term rewards. The learning rate is 1/gamma.</p> <code>0.99</code> <code>eps</code> <code>float</code> <p>The smallest allowed changed for the value function. Bellow the amound of change, the value function is considered converged and the value iteration process will end early.</p> <code>1e-6</code> <code>history_tracking_level</code> <code>int</code> <p>How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)</p> <code>1</code> <code>overwrite_training</code> <code>bool</code> <p>Whether to force the overwriting of the training if a value function already exists for this agent.</p> <code>False</code> <code>print_progress</code> <code>bool</code> <p>Whether or not to print out the progress of the value iteration process.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether or not to print out statistics at the end of the training run.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>solver_history</code> <code>SolverHistory</code> <p>The history of the solving process with some plotting options.</p> Source code in <code>olfactory_navigation/agents/hsvi_agent.py</code> <pre><code>def train(self,\n          expansions: int,\n          update_passes: int = 1,\n          max_belief_growth: int = 10,\n          initial_belief: BeliefSet | Belief | None = None,\n          initial_value_function: ValueFunction | None = None,\n          prune_level: int = 1,\n          prune_interval: int = 10,\n          limit_value_function_size: int = -1,\n          gamma: float = 0.99,\n          eps: float = 1e-6,\n          use_gpu: bool = False,\n          history_tracking_level: int = 1,\n          overwrite_training: bool = False,\n          print_progress: bool = True,\n          print_stats: bool = True\n          ) -&gt; TrainingHistory:\n    '''\n    Main loop of the Point-Based Value Iteration algorithm.\n    It consists in 2 steps, Backup and Expand.\n    1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n    2. Backup: Updates the alpha vectors based on the current belief set\n\n    Heuristic Search Value Iteration:\n    - By default it performs the backup only on set of beliefs generated by the expand function. (so it full_backup=False)\n\n    Parameters\n    ----------\n    expansions : int\n        How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n    update_passes : int, default=1\n        How many times the backup function has to be run every time the belief set is expanded.\n    max_belief_growth : int, default=10\n        How many beliefs can be added at every expansion step to the belief set.\n    initial_belief : BeliefSet or Belief, optional\n        An initial list of beliefs to start with.\n    initial_value_function : ValueFunction, optional\n        An initial value function to start the solving process with.\n    prune_level : int, default=1\n        Parameter to prune the value function further before the expand function.\n    prune_interval : int, default=10\n        How often to prune the value function. It is counted in number of backup iterations.\n    limit_value_function_size : int, default=-1\n        When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n        If set to -1, the value function can grow without bounds.\n    use_gpu : bool, default=False\n        Whether to use the GPU with cupy array to accelerate solving.\n    gamma : float, default=0.99\n        The discount factor to value immediate rewards more than long term rewards.\n        The learning rate is 1/gamma.\n    eps : float, default=1e-6\n        The smallest allowed changed for the value function.\n        Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n    history_tracking_level : int, default=1\n        How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n    overwrite_training : bool, default=False\n        Whether to force the overwriting of the training if a value function already exists for this agent.\n    print_progress : bool, default=True\n        Whether or not to print out the progress of the value iteration process.\n    print_stats : bool, default=True\n        Whether or not to print out statistics at the end of the training run.\n\n    Returns\n    -------\n    solver_history : SolverHistory\n        The history of the solving process with some plotting options.\n    '''\n    return super().train(expansions = expansions,\n                         full_backup = False,\n                         update_passes = update_passes,\n                         max_belief_growth = max_belief_growth,\n                         initial_belief = initial_belief,\n                         initial_value_function = initial_value_function,\n                         prune_level = prune_level,\n                         prune_interval = prune_interval,\n                         limit_value_function_size = limit_value_function_size,\n                         gamma = gamma,\n                         eps = eps,\n                         use_gpu = use_gpu,\n                         history_tracking_level = history_tracking_level,\n                         overwrite_training = overwrite_training,\n                         print_progress = print_progress,\n                         print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.Infotaxis_Agent","title":"<code>Infotaxis_Agent</code>","text":"<p>               Bases: <code>Agent</code></p> <p>An agent following the Infotaxis principle. It is a Model-Based approach that aims to make steps towards where the agent has the greatest likelihood to minimize the entropy of the belief. The belief is (as for the PBVI agent) a probability distribution over the state space of how much the agent is to be confident in each state. The technique was developped and described in the following article: Vergassola, M., Villermaux, E., &amp; Shraiman, B. I. (2007). 'Infotaxis' as a strategy for searching without gradients.</p> <p>It does not need to be trained to the train(), save() and load() function are not implemented.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment to train the agent with.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.</p> <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <code>model</code> <code>Model</code> <p>A POMDP model to use to represent the olfactory environment. If not provided, the environment_converter parameter will be used.</p> <code>None</code> <code>environment_converter</code> <code>Callable</code> <p>A function to convert the olfactory environment instance to a POMDP Model instance. By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model. This parameter will be ignored if the model parameter is provided.</p> <code>exact_converter</code> <code>converter_parameters</code> <code>dict</code> <p>A set of additional parameters to be passed down to the environment converter.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>model</code> <code>Model</code> <p>The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.</p> <code>saved_at</code> <code>str</code> <p>The place on disk where the agent has been saved (None if not saved yet).</p> <code>on_gpu</code> <code>bool</code> <p>Whether the agent has been sent to the gpu or not.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>belief</code> <code>BeliefSet</code> <p>Used only during simulations. Part of the Agent's status. Where the agent believes he is over the state space. It is a list of n belief points based on how many simulations are running at once.</p> <code>action_played</code> <code>list[int]</code> <p>Used only during simulations. Part of the Agent's status. Records what action was last played by the agent. A list of n actions played based on how many simulations are running at once.</p> Source code in <code>olfactory_navigation/agents/infotaxis_agent.py</code> <pre><code>class Infotaxis_Agent(Agent):\n    '''\n    An agent following the Infotaxis principle.\n    It is a Model-Based approach that aims to make steps towards where the agent has the greatest likelihood to minimize the entropy of the belief.\n    The belief is (as for the PBVI agent) a probability distribution over the state space of how much the agent is to be confident in each state.\n    The technique was developped and described in the following article: Vergassola, M., Villermaux, E., &amp; Shraiman, B. I. (2007). 'Infotaxis' as a strategy for searching without gradients.\n\n    It does not need to be trained to the train(), save() and load() function are not implemented.\n\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment to train the agent with.\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.\n    seed : int, default=12131415\n        For reproducible randomness.\n    model : Model, optional\n        A POMDP model to use to represent the olfactory environment.\n        If not provided, the environment_converter parameter will be used.\n    environment_converter : Callable, default=exact_converter\n        A function to convert the olfactory environment instance to a POMDP Model instance.\n        By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model.\n        This parameter will be ignored if the model parameter is provided.\n    converter_parameters : dict, optional\n        A set of additional parameters to be passed down to the environment converter.\n\n    Attributes\n    ---------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    model : pomdp.Model\n        The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.\n    saved_at : str\n        The place on disk where the agent has been saved (None if not saved yet).\n    on_gpu : bool\n        Whether the agent has been sent to the gpu or not.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    belief : BeliefSet\n        Used only during simulations.\n        Part of the Agent's status. Where the agent believes he is over the state space.\n        It is a list of n belief points based on how many simulations are running at once.\n    action_played : list[int]\n        Used only during simulations.\n        Part of the Agent's status. Records what action was last played by the agent.\n        A list of n actions played based on how many simulations are running at once.\n    '''\n    def __init__(self,\n                 environment: Environment,\n                 thresholds: float | list[float] | dict[str, float] | dict[str, list[float]] = 3e-6,\n                 space_aware: bool = False,\n                 spacial_subdivisions: np.ndarray | None = None,\n                 actions: dict[str, np.ndarray] | np.ndarray | None = None,\n                 name: str | None=None,\n                 seed: int = 12131415,\n                 model: Model | None = None,\n                 environment_converter: Callable | None = None,\n                 **converter_parameters\n                 ) -&gt; None:\n        super().__init__(\n            environment = environment,\n            thresholds = thresholds,\n            space_aware = space_aware,\n            spacial_subdivisions = spacial_subdivisions,\n            actions = actions,\n            name = name,\n            seed = seed\n        )\n\n        # Converting the olfactory environment to a POMDP Model\n        if model is not None:\n            loaded_model = model\n        elif callable(environment_converter):\n            loaded_model = environment_converter(agent=self, **converter_parameters)\n        else:\n            # Using the exact converter\n            loaded_model = exact_converter(agent=self)\n        self.model:Model = loaded_model\n\n        # Status variables\n        self.belief = None\n        self.action_played = None\n\n\n    def to_gpu(self) -&gt; Agent:\n        '''\n        Function to send the numpy arrays of the agent to the gpu.\n        It returns a new instance of the Agent class with the arrays on the gpu.\n\n        Returns\n        -------\n        gpu_agent\n        '''\n        # Check whether the agent is already on the gpu or not\n        if self.on_gpu:\n            return self\n\n        # Warn and overwrite alternate_version in case it already exists\n        if self._alternate_version is not None:\n            print('[warning] A GPU instance already existed and is being recreated.')\n            self._alternate_version = None\n\n        assert gpu_support, \"GPU support is not enabled, Cupy might need to be installed...\"\n\n        # Generating a new instance\n        cls = self.__class__\n        gpu_agent = cls.__new__(cls)\n\n        # Copying arguments to gpu\n        for arg, val in self.__dict__.items():\n            if isinstance(val, np.ndarray):\n                setattr(gpu_agent, arg, cp.array(val))\n            elif arg == 'rnd_state':\n                setattr(gpu_agent, arg, cp.random.RandomState(self.seed))\n            elif isinstance(val, Model):\n                setattr(gpu_agent, arg, val.gpu_model)\n            elif isinstance(val, BeliefSet) or isinstance(val, Belief):\n                setattr(gpu_agent, arg, val.to_gpu())\n            else:\n                setattr(gpu_agent, arg, val)\n\n        # Self reference instances\n        self._alternate_version = gpu_agent\n        gpu_agent._alternate_version = self\n\n        gpu_agent.on_gpu = True\n        return gpu_agent\n\n\n    def initialize_state(self,\n                         n: int = 1,\n                         belief: BeliefSet | None = None\n                         ) -&gt; None:\n        '''\n        To use an agent within a simulation, the agent's state needs to be initialized.\n        The initialization consists of setting the agent's initial belief.\n        Multiple agents can be used at once for simulations, for this reason, the belief parameter is a BeliefSet by default.\n\n        Parameters\n        ----------\n        n : int, default=1\n            How many agents are to be used during the simulation.\n        belief : BeliefSet, optional\n            An optional set of beliefs to initialize the simulations with.\n        '''\n        if belief is None:\n            self.belief = BeliefSet(self.model, [Belief(self.model) for _ in range(n)])\n        else:\n            assert len(belief) == n, f\"The amount of beliefs provided ({len(belief)}) to initialize the state need to match the amount of stimulations to initialize (n={n}).\"\n\n            if self.on_gpu and not belief.is_on_gpu:\n                self.belief = belief.to_gpu()\n            elif not self.on_gpu and belief.is_on_gpu:\n                self.belief = belief.to_cpu()\n            else:\n                self.belief = belief\n\n\n    def choose_action(self) -&gt; np.ndarray:\n        '''\n        Function to let the agent or set of agents choose an action based on their current belief.\n        Following the Infotaxis principle, it will choose an action that will minimize the sum of next entropies.\n\n        Returns\n        -------\n        movement_vector : np.ndarray\n            A single or a list of actions chosen by the agent(s) based on their belief.\n        '''\n        xp = np if not self.on_gpu else cp\n\n        n = len(self.belief)\n\n        best_entropy = xp.ones(n) * -1\n        best_action = xp.ones(n, dtype=int) * -1\n\n        current_entropy = self.belief.entropies\n\n        for a in self.model.actions:\n            total_entropy = xp.zeros(n)\n\n            for o in self.model.observations:\n                b_ao = self.belief.update(actions=xp.ones(n, dtype=int)*a,\n                                           observations=xp.ones(n, dtype=int)*o,\n                                           throw_error=False)\n\n                # Computing entropy\n                with warnings.catch_warnings():\n                    warnings.simplefilter('ignore')\n                    b_ao_entropy = b_ao.entropies\n\n                b_prob = xp.dot(self.belief.belief_array, xp.sum(self.model.reachable_transitional_observation_table[:,a,o,:], axis=1))\n\n                total_entropy += (b_prob * (current_entropy - b_ao_entropy))\n\n            # Checking if action is superior to previous best\n            superiority_mask = best_entropy &lt; total_entropy\n            best_action[superiority_mask] = a\n            best_entropy[superiority_mask] = total_entropy[superiority_mask]\n\n        # Recording the action played\n        self.action_played = best_action\n\n        # Converting action indexes to movement vectors\n        movemement_vector = self.action_set[best_action,:]\n\n        return movemement_vector\n\n\n    def update_state(self,\n                     action: np.ndarray,\n                     observation: np.ndarray,\n                     source_reached: np.ndarray\n                     ) -&gt; None | np.ndarray:\n        '''\n        Function to update the internal state(s) of the agent(s) based on the previous action(s) taken and the observation(s) received.\n\n        Parameters\n        ----------\n        action : np.ndarray\n            A 2D array of n movement vectors. If the environment is layered, the 1st component should be the layer.\n        observation : np.ndarray\n            The observation(s) the agent(s) made.\n        source_reached : np.ndarray\n            A boolean array of whether the agent(s) have reached the source or not.\n\n        Returns\n        -------\n        update_successfull : np.ndarray, optional\n            If nothing is returned, it means all the agent's state updates have been successfull.\n            Else, a boolean np.ndarray of size n can be returned confirming for each agent whether the update has been successful or not.\n        '''\n        assert self.belief is not None, \"Agent was not initialized yet, run the initialize_state function first\"\n\n\n        # Discretizing observations\n        observation_ids = self.discretize_observations(observation=observation, action=action, source_reached=source_reached)\n\n        # Update the set of belief\n        self.belief = self.belief.update(actions=self.action_played, observations=observation_ids)\n\n        # Check for failed updates\n        update_successful = (self.belief.belief_array.sum(axis=1) != 0.0)\n\n        return update_successful\n\n\n    def kill(self,\n             simulations_to_kill: np.ndarray\n             ) -&gt; None:\n        '''\n        Function to kill any simulations that have not reached the source but can't continue further\n\n        Parameters\n        ----------\n        simulations_to_kill : np.ndarray\n            A boolean array of the simulations to kill.\n        '''\n        if all(simulations_to_kill):\n            self.belief = None\n        else:\n            self.belief = BeliefSet(self.belief.model, self.belief.belief_array[~simulations_to_kill])\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.Infotaxis_Agent.choose_action","title":"<code>choose_action()</code>","text":"<p>Function to let the agent or set of agents choose an action based on their current belief. Following the Infotaxis principle, it will choose an action that will minimize the sum of next entropies.</p> <p>Returns:</p> Name Type Description <code>movement_vector</code> <code>ndarray</code> <p>A single or a list of actions chosen by the agent(s) based on their belief.</p> Source code in <code>olfactory_navigation/agents/infotaxis_agent.py</code> <pre><code>def choose_action(self) -&gt; np.ndarray:\n    '''\n    Function to let the agent or set of agents choose an action based on their current belief.\n    Following the Infotaxis principle, it will choose an action that will minimize the sum of next entropies.\n\n    Returns\n    -------\n    movement_vector : np.ndarray\n        A single or a list of actions chosen by the agent(s) based on their belief.\n    '''\n    xp = np if not self.on_gpu else cp\n\n    n = len(self.belief)\n\n    best_entropy = xp.ones(n) * -1\n    best_action = xp.ones(n, dtype=int) * -1\n\n    current_entropy = self.belief.entropies\n\n    for a in self.model.actions:\n        total_entropy = xp.zeros(n)\n\n        for o in self.model.observations:\n            b_ao = self.belief.update(actions=xp.ones(n, dtype=int)*a,\n                                       observations=xp.ones(n, dtype=int)*o,\n                                       throw_error=False)\n\n            # Computing entropy\n            with warnings.catch_warnings():\n                warnings.simplefilter('ignore')\n                b_ao_entropy = b_ao.entropies\n\n            b_prob = xp.dot(self.belief.belief_array, xp.sum(self.model.reachable_transitional_observation_table[:,a,o,:], axis=1))\n\n            total_entropy += (b_prob * (current_entropy - b_ao_entropy))\n\n        # Checking if action is superior to previous best\n        superiority_mask = best_entropy &lt; total_entropy\n        best_action[superiority_mask] = a\n        best_entropy[superiority_mask] = total_entropy[superiority_mask]\n\n    # Recording the action played\n    self.action_played = best_action\n\n    # Converting action indexes to movement vectors\n    movemement_vector = self.action_set[best_action,:]\n\n    return movemement_vector\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.Infotaxis_Agent.initialize_state","title":"<code>initialize_state(n=1, belief=None)</code>","text":"<p>To use an agent within a simulation, the agent's state needs to be initialized. The initialization consists of setting the agent's initial belief. Multiple agents can be used at once for simulations, for this reason, the belief parameter is a BeliefSet by default.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>How many agents are to be used during the simulation.</p> <code>1</code> <code>belief</code> <code>BeliefSet</code> <p>An optional set of beliefs to initialize the simulations with.</p> <code>None</code> Source code in <code>olfactory_navigation/agents/infotaxis_agent.py</code> <pre><code>def initialize_state(self,\n                     n: int = 1,\n                     belief: BeliefSet | None = None\n                     ) -&gt; None:\n    '''\n    To use an agent within a simulation, the agent's state needs to be initialized.\n    The initialization consists of setting the agent's initial belief.\n    Multiple agents can be used at once for simulations, for this reason, the belief parameter is a BeliefSet by default.\n\n    Parameters\n    ----------\n    n : int, default=1\n        How many agents are to be used during the simulation.\n    belief : BeliefSet, optional\n        An optional set of beliefs to initialize the simulations with.\n    '''\n    if belief is None:\n        self.belief = BeliefSet(self.model, [Belief(self.model) for _ in range(n)])\n    else:\n        assert len(belief) == n, f\"The amount of beliefs provided ({len(belief)}) to initialize the state need to match the amount of stimulations to initialize (n={n}).\"\n\n        if self.on_gpu and not belief.is_on_gpu:\n            self.belief = belief.to_gpu()\n        elif not self.on_gpu and belief.is_on_gpu:\n            self.belief = belief.to_cpu()\n        else:\n            self.belief = belief\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.Infotaxis_Agent.kill","title":"<code>kill(simulations_to_kill)</code>","text":"<p>Function to kill any simulations that have not reached the source but can't continue further</p> <p>Parameters:</p> Name Type Description Default <code>simulations_to_kill</code> <code>ndarray</code> <p>A boolean array of the simulations to kill.</p> required Source code in <code>olfactory_navigation/agents/infotaxis_agent.py</code> <pre><code>def kill(self,\n         simulations_to_kill: np.ndarray\n         ) -&gt; None:\n    '''\n    Function to kill any simulations that have not reached the source but can't continue further\n\n    Parameters\n    ----------\n    simulations_to_kill : np.ndarray\n        A boolean array of the simulations to kill.\n    '''\n    if all(simulations_to_kill):\n        self.belief = None\n    else:\n        self.belief = BeliefSet(self.belief.model, self.belief.belief_array[~simulations_to_kill])\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.Infotaxis_Agent.to_gpu","title":"<code>to_gpu()</code>","text":"<p>Function to send the numpy arrays of the agent to the gpu. It returns a new instance of the Agent class with the arrays on the gpu.</p> <p>Returns:</p> Type Description <code>gpu_agent</code> Source code in <code>olfactory_navigation/agents/infotaxis_agent.py</code> <pre><code>def to_gpu(self) -&gt; Agent:\n    '''\n    Function to send the numpy arrays of the agent to the gpu.\n    It returns a new instance of the Agent class with the arrays on the gpu.\n\n    Returns\n    -------\n    gpu_agent\n    '''\n    # Check whether the agent is already on the gpu or not\n    if self.on_gpu:\n        return self\n\n    # Warn and overwrite alternate_version in case it already exists\n    if self._alternate_version is not None:\n        print('[warning] A GPU instance already existed and is being recreated.')\n        self._alternate_version = None\n\n    assert gpu_support, \"GPU support is not enabled, Cupy might need to be installed...\"\n\n    # Generating a new instance\n    cls = self.__class__\n    gpu_agent = cls.__new__(cls)\n\n    # Copying arguments to gpu\n    for arg, val in self.__dict__.items():\n        if isinstance(val, np.ndarray):\n            setattr(gpu_agent, arg, cp.array(val))\n        elif arg == 'rnd_state':\n            setattr(gpu_agent, arg, cp.random.RandomState(self.seed))\n        elif isinstance(val, Model):\n            setattr(gpu_agent, arg, val.gpu_model)\n        elif isinstance(val, BeliefSet) or isinstance(val, Belief):\n            setattr(gpu_agent, arg, val.to_gpu())\n        else:\n            setattr(gpu_agent, arg, val)\n\n    # Self reference instances\n    self._alternate_version = gpu_agent\n    gpu_agent._alternate_version = self\n\n    gpu_agent.on_gpu = True\n    return gpu_agent\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.Infotaxis_Agent.update_state","title":"<code>update_state(action, observation, source_reached)</code>","text":"<p>Function to update the internal state(s) of the agent(s) based on the previous action(s) taken and the observation(s) received.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>ndarray</code> <p>A 2D array of n movement vectors. If the environment is layered, the 1st component should be the layer.</p> required <code>observation</code> <code>ndarray</code> <p>The observation(s) the agent(s) made.</p> required <code>source_reached</code> <code>ndarray</code> <p>A boolean array of whether the agent(s) have reached the source or not.</p> required <p>Returns:</p> Name Type Description <code>update_successfull</code> <code>(ndarray, optional)</code> <p>If nothing is returned, it means all the agent's state updates have been successfull. Else, a boolean np.ndarray of size n can be returned confirming for each agent whether the update has been successful or not.</p> Source code in <code>olfactory_navigation/agents/infotaxis_agent.py</code> <pre><code>def update_state(self,\n                 action: np.ndarray,\n                 observation: np.ndarray,\n                 source_reached: np.ndarray\n                 ) -&gt; None | np.ndarray:\n    '''\n    Function to update the internal state(s) of the agent(s) based on the previous action(s) taken and the observation(s) received.\n\n    Parameters\n    ----------\n    action : np.ndarray\n        A 2D array of n movement vectors. If the environment is layered, the 1st component should be the layer.\n    observation : np.ndarray\n        The observation(s) the agent(s) made.\n    source_reached : np.ndarray\n        A boolean array of whether the agent(s) have reached the source or not.\n\n    Returns\n    -------\n    update_successfull : np.ndarray, optional\n        If nothing is returned, it means all the agent's state updates have been successfull.\n        Else, a boolean np.ndarray of size n can be returned confirming for each agent whether the update has been successful or not.\n    '''\n    assert self.belief is not None, \"Agent was not initialized yet, run the initialize_state function first\"\n\n\n    # Discretizing observations\n    observation_ids = self.discretize_observations(observation=observation, action=action, source_reached=source_reached)\n\n    # Update the set of belief\n    self.belief = self.belief.update(actions=self.action_played, observations=observation_ids)\n\n    # Check for failed updates\n    update_successful = (self.belief.belief_array.sum(axis=1) != 0.0)\n\n    return update_successful\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_Agent","title":"<code>PBVI_Agent</code>","text":"<p>               Bases: <code>Agent</code></p> <p>A generic Point-Based Value Iteration based agent. It relies on Model-Based reinforcement learning as described in: Pineau J. et al, Point-based value iteration: An anytime algorithm for POMDPs The training consist in two steps:</p> <ul> <li> <p>Expand: Where belief points are explored based on the some strategy (to be defined by subclasses).</p> </li> <li> <p>Backup: Using the generated belief points, the value function is updated.</p> </li> </ul> <p>The belief points are probability distributions over the state space and are therefore vectors of |S| elements.</p> <p>Actions are chosen based on a value function. A value function is a set of alpha vectors of dimentionality |S|. Each alpha vector is associated to a single action but multiple alpha vectors can be associated to the same action. To choose an action at a given belief point, a dot product is taken between each alpha vector and the belief point and the action associated with the highest result is chosen.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment to train the agent with.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.</p> <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <code>model</code> <code>Model</code> <p>A POMDP model to use to represent the olfactory environment. If not provided, the environment_converter parameter will be used.</p> <code>None</code> <code>environment_converter</code> <code>Callable</code> <p>A function to convert the olfactory environment instance to a POMDP Model instance. By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model. This parameter will be ignored if the model parameter is provided.</p> <code>exact_converter</code> <code>converter_parameters</code> <code>dict</code> <p>A set of additional parameters to be passed down to the environment converter.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>model</code> <code>Model</code> <p>The environment converted to a POMDP model using the \"from_environment\" constructor of the Model class.</p> <code>saved_at</code> <code>str</code> <p>The place on disk where the agent has been saved (None if not saved yet).</p> <code>on_gpu</code> <code>bool</code> <p>Whether the agent has been sent to the gpu or not.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>trained_at</code> <code>str</code> <p>A string timestamp of when the agent has been trained (None if not trained yet).</p> <code>value_function</code> <code>ValueFunction</code> <p>The value function used for the agent to make decisions.</p> <code>belief</code> <code>BeliefSet</code> <p>Used only during simulations. Part of the Agent's status. Where the agent believes he is over the state space. It is a list of n belief points based on how many simulations are running at once.</p> <code>action_played</code> <code>list[int]</code> <p>Used only during simulations. Part of the Agent's status. Records what action was last played by the agent. A list of n actions played based on how many simulations are running at once.</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>class PBVI_Agent(Agent):\n    '''\n    A generic Point-Based Value Iteration based agent. It relies on Model-Based reinforcement learning as described in: Pineau J. et al, Point-based value iteration: An anytime algorithm for POMDPs\n    The training consist in two steps:\n\n    - Expand: Where belief points are explored based on the some strategy (to be defined by subclasses).\n\n    - Backup: Using the generated belief points, the value function is updated.\n\n    The belief points are probability distributions over the state space and are therefore vectors of |S| elements.\n\n    Actions are chosen based on a value function. A value function is a set of alpha vectors of dimentionality |S|.\n    Each alpha vector is associated to a single action but multiple alpha vectors can be associated to the same action.\n    To choose an action at a given belief point, a dot product is taken between each alpha vector and the belief point and the action associated with the highest result is chosen.\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment to train the agent with.\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.\n    seed : int, default=12131415\n        For reproducible randomness.\n    model : Model, optional\n        A POMDP model to use to represent the olfactory environment.\n        If not provided, the environment_converter parameter will be used.\n    environment_converter : Callable, default=exact_converter\n        A function to convert the olfactory environment instance to a POMDP Model instance.\n        By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model.\n        This parameter will be ignored if the model parameter is provided.\n    converter_parameters : dict, optional\n        A set of additional parameters to be passed down to the environment converter.\n\n    Attributes\n    ---------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    model : Model\n        The environment converted to a POMDP model using the \"from_environment\" constructor of the Model class.\n    saved_at : str\n        The place on disk where the agent has been saved (None if not saved yet).\n    on_gpu : bool\n        Whether the agent has been sent to the gpu or not.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    trained_at : str\n        A string timestamp of when the agent has been trained (None if not trained yet).\n    value_function : ValueFunction\n        The value function used for the agent to make decisions.\n    belief : BeliefSet\n        Used only during simulations.\n        Part of the Agent's status. Where the agent believes he is over the state space.\n        It is a list of n belief points based on how many simulations are running at once.\n    action_played : list[int]\n        Used only during simulations.\n        Part of the Agent's status. Records what action was last played by the agent.\n        A list of n actions played based on how many simulations are running at once.\n    '''\n    def __init__(self,\n                 environment: Environment,\n                 thresholds: float | list[float] | dict[str, float] | dict[str, list[float]] = 3e-6,\n                 space_aware: bool = False,\n                 spacial_subdivisions: np.ndarray | None = None,\n                 actions: dict[str, np.ndarray] | np.ndarray | None = None,\n                 name: str | None = None,\n                 seed: int = 12131415,\n                 model: Model | None = None,\n                 environment_converter: Callable | None = None,\n                 **converter_parameters\n                 ) -&gt; None:\n        super().__init__(\n            environment = environment,\n            thresholds = thresholds,\n            space_aware = space_aware,\n            spacial_subdivisions = spacial_subdivisions,\n            actions = actions,\n            name = name,\n            seed = seed\n        )\n\n        # Converting the olfactory environment to a POMDP Model\n        if model is not None:\n            loaded_model = model\n        elif callable(environment_converter):\n            loaded_model = environment_converter(agent=self, **converter_parameters)\n        else:\n            # Using the exact converter\n            loaded_model = exact_converter(agent=self)\n        self.model:Model = loaded_model\n\n        # Trainable variables\n        self.trained_at = None\n        self.value_function = None\n\n        # Status variables\n        self.belief = None\n        self.action_played = None\n\n\n    def to_gpu(self) -&gt; 'PBVI_Agent':\n        '''\n        Function to send the numpy arrays of the agent to the gpu.\n        It returns a new instance of the Agent class with the arrays on the gpu.\n\n        Returns\n        -------\n        gpu_agent : Agent\n            A copy of the agent with the arrays on the GPU.\n        '''\n        # Check whether the agent is already on the gpu or not\n        if self.on_gpu:\n            return self\n\n        # Warn and overwrite alternate_version in case it already exists\n        if self._alternate_version is not None:\n            print('[warning] A GPU instance already existed and is being recreated.')\n            self._alternate_version = None\n\n        assert gpu_support, \"GPU support is not enabled, Cupy might need to be installed...\"\n\n        # Generating a new instance\n        cls = self.__class__\n        gpu_agent = cls.__new__(cls)\n\n        # Copying arguments to gpu\n        for arg, val in self.__dict__.items():\n            if isinstance(val, np.ndarray):\n                setattr(gpu_agent, arg, cp.array(val))\n            elif arg == 'rnd_state':\n                setattr(gpu_agent, arg, cp.random.RandomState(self.seed))\n            elif isinstance(val, Model):\n                setattr(gpu_agent, arg, val.gpu_model)\n            elif isinstance(val, ValueFunction):\n                setattr(gpu_agent, arg, val.to_gpu())\n            elif isinstance(val, BeliefSet) or isinstance(val, Belief):\n                setattr(gpu_agent, arg, val.to_gpu())\n            else:\n                setattr(gpu_agent, arg, val)\n\n        # Self reference instances\n        self._alternate_version = gpu_agent\n        gpu_agent._alternate_version = self\n\n        gpu_agent.on_gpu = True\n        return gpu_agent\n\n\n    def to_cpu(self) -&gt; 'PBVI_Agent':\n        '''\n        Function to send the numpy arrays of the agent to the cpu.\n        It returns a new instance of the Agent class with the arrays on the cpu.\n\n        Returns\n        -------\n        cpu_agent : Agent\n            A new environment instance where the arrays are on the cpu memory.\n        '''\n        # Check whether the agent is already on the cpu or not\n        if not self.on_gpu:\n            return self\n\n        if self._alternate_version is not None:\n            print('[warning] A CPU instance already existed and is being recreated.')\n            self._alternate_version = None\n\n        # Generating a new instance\n        cls = self.__class__\n        cpu_agent = cls.__new__(cls)\n\n        # Copying arguments to gpu\n        for arg, val in self.__dict__.items():\n            if isinstance(val, cp.ndarray):\n                setattr(cpu_agent, arg, cp.asnumpy(val))\n            elif arg == 'rnd_state':\n                setattr(cpu_agent, arg, np.random.RandomState(self.seed))\n            elif isinstance(val, Model):\n                setattr(cpu_agent, arg, val.cpu_model)\n            elif isinstance(val, ValueFunction):\n                setattr(cpu_agent, arg, val.to_cpu())\n            elif isinstance(val, BeliefSet) or isinstance(val, Belief):\n                setattr(cpu_agent, arg, val.to_cpu())\n            else:\n                setattr(cpu_agent, arg, val)\n\n        # Self reference instances\n        self._alternate_version = cpu_agent\n        cpu_agent._alternate_version = self\n\n        cpu_agent.on_gpu = True\n        return cpu_agent\n\n\n    def save(self,\n             folder: str | None = None,\n             force: bool = False,\n             save_environment: bool = False\n             ) -&gt; None:\n        '''\n        The save function for PBVI Agents consists in recording the value function after the training.\n        It saves the agent in a folder with the name of the agent (class name + training timestamp).\n        In this folder, there will be the metadata of the agent (all the attributes) in a json format and the value function.\n\n        Optionally, the environment can be saved too to be able to load it alongside the agent for future reuse.\n        If the agent has already been saved, the saving will not happen unless the force parameter is toggled.\n\n        Parameters\n        ----------\n        folder : str, optional\n            The folder under which to save the agent (a subfolder will be created under this folder).\n            The agent will therefore be saved at &lt;folder&gt;/Agent-&lt;agent_name&gt; .\n            By default the current folder is used.\n        force : bool, default=False\n            Whether to overwrite an already saved agent with the same name at the same path.\n        save_environment : bool, default=False\n            Whether to save the environment data along with the agent.\n        '''\n        assert self.trained_at is not None, \"The agent is not trained, there is nothing to save.\"\n\n        # GPU support\n        if self.on_gpu:\n            self.cpu_version.save(folder=folder, force=force, save_environment=save_environment)\n            return\n\n        # Adding env name to folder path\n        if folder is None:\n            folder = f'./Agent-{self.name}'\n        else:\n            folder += '/Agent-' + self.name\n\n        # Checking the folder exists or creates it\n        if not os.path.exists(folder):\n            os.mkdir(folder)\n        elif len(os.listdir(folder)):\n            if force:\n                shutil.rmtree(folder)\n                os.mkdir(folder)\n            else:\n                raise Exception(f'{folder} is not empty. If you want to overwrite the saved model, enable \"force\".')\n\n        # If requested save environment\n        if save_environment:\n            self.environment.save(folder=folder)\n\n        # TODO: Add MODEL to save function\n        # Generating the metadata arguments dictionary\n        arguments = {}\n        arguments['name'] = self.name\n        arguments['class'] = self.class_name\n        if len(self.thresholds.shape) == 2:\n            arguments['thresholds'] = {layer_lab: layer_thresholds for layer_lab, layer_thresholds in zip(self.environment.layer_labels, self.thresholds.tolist())}\n        else:\n            arguments['thresholds'] = self.thresholds.tolist()\n        arguments['environment_name'] = self.environment.name\n        arguments['environment_saved_at'] = self.environment.saved_at\n        arguments['space_aware'] = self.space_aware\n        arguments['spacial_subdivisions'] = self.spacial_subdivisions.tolist()\n        arguments['action_labels'] = self.action_labels\n        arguments['action_set'] = self.action_set.tolist()\n        arguments['trained_at'] = self.trained_at\n        arguments['seed'] = self.seed\n\n        # Output the arguments to a METADATA file\n        with open(folder + '/METADATA.json', 'w') as json_file:\n            json.dump(arguments, json_file, indent=4)\n\n        # Save value function\n        self.value_function.save(folder=folder, file_name='Value_Function.npy')\n\n        # Finalization\n        self.saved_at = os.path.abspath(folder).replace('\\\\', '/')\n        print(f'Agent saved to: {folder}')\n\n\n    @classmethod\n    def load(cls,\n             folder: str\n             ) -&gt; 'PBVI_Agent':\n        '''\n        Function to load a PBVI agent from a given folder it has been saved to.\n        It will load the environment the agent has been trained on along with it.\n\n        If it is a subclass of the PBVI_Agent, an instance of that specific subclass will be returned.\n\n        Parameters\n        ----------\n        folder : str\n            The agent folder.\n\n        Returns\n        -------\n        instance : PBVI_Agent\n            The loaded instance of the PBVI Agent.\n        '''\n        # Load arguments\n        arguments = None\n        with open(folder + '/METADATA.json', 'r') as json_file:\n            arguments = json.load(json_file)\n\n        # Load environment\n        environment = Environment.load(arguments['environment_saved_at'])\n\n        # Load specific class\n        if arguments['class'] != 'PBVI_Agent':\n            from olfactory_navigation import agents\n            cls = {name:obj for name, obj in inspect.getmembers(agents)}[arguments['class']]\n\n        # Build instance\n        instance = cls(\n            environment = environment,\n            thresholds = arguments['thresholds'],\n            space_aware = arguments['space_aware'],\n            spacial_subdivisions = np.array(arguments['spacial_subdivisions']),\n            actions = {a_label: a_vector for a_label, a_vector in zip(arguments['action_labels'], arguments['action_set'])},\n            name = arguments['name'],\n            seed = arguments['seed']\n        )\n\n        # Load and set the value function on the instance\n        instance.value_function = ValueFunction.load(\n            file=folder + '/Value_Function.npy',\n            model=instance.model\n        )\n        instance.trained_at = arguments['trained_at']\n        instance.saved_at = folder\n\n        return instance\n\n\n    def train(self,\n              expansions: int,\n              full_backup: bool = True,\n              update_passes: int = 1,\n              max_belief_growth: int = 10,\n              initial_belief: BeliefSet | Belief | None = None,\n              initial_value_function: ValueFunction | None = None,\n              prune_level: int = 1,\n              prune_interval: int = 10,\n              limit_value_function_size: int = -1,\n              gamma: float = 0.99,\n              eps: float = 1e-6,\n              use_gpu: bool = False,\n              history_tracking_level: int = 1,\n              overwrite_training: bool = False,\n              print_progress: bool = True,\n              print_stats: bool = True,\n              **expand_arguments\n              ) -&gt; TrainingHistory:\n        '''\n        Main loop of the Point-Based Value Iteration algorithm.\n        It consists in 2 steps, Backup and Expand.\n        1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n        2. Backup: Updates the alpha vectors based on the current belief set\n\n        Parameters\n        ----------\n        expansions : int\n            How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n        full_backup : bool, default=True\n            Whether to force the backup function has to be run on the full set beliefs uncovered since the beginning or only on the new points.\n        update_passes : int, default=1\n            How many times the backup function has to be run every time the belief set is expanded.\n        max_belief_growth : int, default=10\n            How many beliefs can be added at every expansion step to the belief set.\n        initial_belief : BeliefSet or Belief, optional\n            An initial list of beliefs to start with.\n        initial_value_function : ValueFunction, optional\n            An initial value function to start the solving process with.\n        prune_level : int, default=1\n            Parameter to prune the value function further before the expand function.\n        prune_interval : int, default=10\n            How often to prune the value function. It is counted in number of backup iterations.\n        limit_value_function_size : int, default=-1\n            When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n            If set to -1, the value function can grow without bounds.\n        use_gpu : bool, default=False\n            Whether to use the GPU with cupy array to accelerate solving.\n        gamma : float, default=0.99\n            The discount factor to value immediate rewards more than long term rewards.\n            The learning rate is 1/gamma.\n        eps : float, default=1e-6\n            The smallest allowed changed for the value function.\n            Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n        history_tracking_level : int, default=1\n            How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n        overwrite_training : bool, default=False\n            Whether to force the overwriting of the training if a value function already exists for this agent.\n        print_progress : bool, default=True\n            Whether or not to print out the progress of the value iteration process.\n        print_stats : bool, default=True\n            Whether or not to print out statistics at the end of the training run.\n        expand_arguments : kwargs\n            An arbitrary amount of parameters that will be passed on to the expand function.\n\n        Returns\n        -------\n        solver_history : SolverHistory\n            The history of the solving process with some plotting options.\n        '''\n        # GPU support\n        if use_gpu and not self.on_gpu:\n            gpu_agent = self.to_gpu()\n            solver_history = super(self.__class__, gpu_agent).train(\n                expansions=expansions,\n                full_backup=full_backup,\n                update_passes=update_passes,\n                max_belief_growth=max_belief_growth,\n                initial_belief=initial_belief,\n                initial_value_function=initial_value_function,\n                prune_level=prune_level,\n                prune_interval=prune_interval,\n                limit_value_function_size=limit_value_function_size,\n                gamma=gamma,\n                eps=eps,\n                use_gpu=use_gpu,\n                history_tracking_level=history_tracking_level,\n                overwrite_training=overwrite_training,\n                print_progress=print_progress,\n                print_stats=print_stats,\n                **expand_arguments\n            )\n\n            # Setting parameters of CPU agent after the training\n            self.value_function = gpu_agent.value_function.to_cpu()\n            self.trained_at = gpu_agent.trained_at\n            self.name = gpu_agent.name\n\n            return solver_history\n\n        xp = np if not self.on_gpu else cp\n\n        # Getting model\n        model = self.model\n\n        # Initial belief\n        if initial_belief is None:\n            belief_set = BeliefSet(model, [Belief(model)])\n        elif isinstance(initial_belief, BeliefSet):\n            belief_set = initial_belief.to_gpu() if self.on_gpu else initial_belief\n        else:\n            initial_belief = Belief(model, xp.array(initial_belief.values))\n            belief_set = BeliefSet(model, [initial_belief])\n\n        # Handeling the case where the agent is already trained\n        if (self.value_function is not None):\n            if overwrite_training:\n                print('[warning] The value function is being overwritten')\n                self.trained_at = None\n                self.name = '-'.join(self.name.split('-')[:-1])\n                self.value_function = None\n            else:\n                initial_value_function = self.value_function\n\n        # Initial value function\n        if initial_value_function is None:\n            value_function = ValueFunction(model, model.expected_rewards_table.T, model.actions)\n        else:\n            value_function = initial_value_function.to_gpu() if self.on_gpu else initial_value_function\n\n        # Convergence check boundary\n        max_allowed_change = eps * (gamma / (1-gamma))\n\n        # History tracking\n        training_history = TrainingHistory(tracking_level=history_tracking_level,\n                                           model=model,\n                                           gamma=gamma,\n                                           eps=eps,\n                                           expand_append=full_backup,\n                                           initial_value_function=value_function,\n                                           initial_belief_set=belief_set)\n\n        # Loop\n        iteration = 0\n        expand_value_function = value_function\n        old_value_function = value_function\n\n        try:\n            iterator = trange(expansions, desc='Expansions') if print_progress else range(expansions)\n            iterator_postfix = {}\n            for expansion_i in iterator:\n\n                # 1: Expand belief set\n                start_ts = datetime.now()\n\n                new_belief_set = self.expand(belief_set=belief_set,\n                                             value_function=value_function,\n                                             max_generation=max_belief_growth,\n                                             **expand_arguments)\n\n                # Add new beliefs points to the total belief_set\n                belief_set = belief_set.union(new_belief_set)\n\n                expand_time = (datetime.now() - start_ts).total_seconds()\n                training_history.add_expand_step(expansion_time=expand_time, belief_set=belief_set)\n\n                # 2: Backup, update value function (alpha vector set)\n                for _ in range(update_passes) if (not print_progress or update_passes &lt;= 1) else trange(update_passes, desc=f'Backups {expansion_i}'):\n                    start_ts = datetime.now()\n\n                    # Backup step\n                    value_function = self.backup(belief_set if full_backup else new_belief_set,\n                                                 value_function,\n                                                 gamma=gamma,\n                                                 append=(not full_backup),\n                                                 belief_dominance_prune=False)\n                    backup_time = (datetime.now() - start_ts).total_seconds()\n\n                    # Additional pruning\n                    if (iteration % prune_interval) == 0 and iteration &gt; 0:\n                        start_ts = datetime.now()\n                        vf_len = len(value_function)\n\n                        value_function.prune(prune_level)\n\n                        prune_time = (datetime.now() - start_ts).total_seconds()\n                        alpha_vectors_pruned = len(value_function) - vf_len\n                        training_history.add_prune_step(prune_time, alpha_vectors_pruned)\n\n                    # Check if value function size is above threshold\n                    if limit_value_function_size &gt;= 0 and len(value_function) &gt; limit_value_function_size:\n                        # Compute matrix multiplications between avs and beliefs\n                        alpha_value_per_belief = xp.matmul(value_function.alpha_vector_array, belief_set.belief_array.T)\n\n                        # Select the useful alpha vectors\n                        best_alpha_vector_per_belief = xp.argmax(alpha_value_per_belief, axis=0)\n                        useful_alpha_vectors = xp.unique(best_alpha_vector_per_belief)\n\n                        # Select a random selection of vectors to delete\n                        unuseful_alpha_vectors = xp.delete(xp.arange(len(value_function)), useful_alpha_vectors)\n                        random_vectors_to_delete = self.rnd_state.choice(unuseful_alpha_vectors,\n                                                                         size=max_belief_growth,\n                                                                         p=(xp.arange(len(unuseful_alpha_vectors))[::-1] / xp.sum(xp.arange(len(unuseful_alpha_vectors)))))\n                                                                         # replace=False,\n                                                                         # p=1/len(unuseful_alpha_vectors))\n\n                        value_function = ValueFunction(model=model,\n                                                       alpha_vectors=xp.delete(value_function.alpha_vector_array, random_vectors_to_delete, axis=0),\n                                                       action_list=xp.delete(value_function.actions, random_vectors_to_delete))\n\n                        iterator_postfix['|useful|'] = useful_alpha_vectors.shape[0]\n\n                    # Compute the change between value functions\n                    max_change = self.compute_change(value_function, old_value_function, belief_set)\n\n                    # History tracking\n                    training_history.add_backup_step(backup_time, max_change, value_function)\n\n                    # Convergence check\n                    if max_change &lt; max_allowed_change:\n                        break\n\n                    old_value_function = value_function\n\n                    # Update iteration counter\n                    iteration += 1\n\n                # Compute change with old expansion value function\n                expand_max_change = self.compute_change(expand_value_function, value_function, belief_set)\n\n                if expand_max_change &lt; max_allowed_change:\n                    if print_progress:\n                        print('Converged!')\n                    break\n\n                expand_value_function = value_function\n\n                iterator_postfix['|V|'] = len(value_function)\n                iterator_postfix['|B|'] = len(belief_set)\n\n                if print_progress:\n                    iterator.set_postfix(iterator_postfix)\n\n        except MemoryError as e:\n            print(f'Memory full: {e}')\n            print('Returning value function and history as is...\\n')\n\n        # Final pruning\n        start_ts = datetime.now()\n        vf_len = len(value_function)\n\n        value_function.prune(prune_level)\n\n        # History tracking\n        prune_time = (datetime.now() - start_ts).total_seconds()\n        alpha_vectors_pruned = len(value_function) - vf_len\n        training_history.add_prune_step(prune_time, alpha_vectors_pruned)\n\n        # Record when it was trained\n        self.trained_at = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        self.name += f'-trained_{self.trained_at}'\n\n        # Saving value function\n        self.value_function = value_function\n\n        # Print stats if requested\n        if print_stats:\n            print(training_history.summary)\n\n        return training_history\n\n\n    def compute_change(self,\n                       value_function: ValueFunction,\n                       new_value_function: ValueFunction,\n                       belief_set: BeliefSet\n                       ) -&gt; float:\n        '''\n        Function to compute whether the change between two value functions can be considered as having converged based on the eps parameter of the Solver.\n        It check for each belief, the maximum value and take the max change between believe's value functions.\n        If this max change is lower than eps * (gamma / (1 - gamma)).\n\n        Parameters\n        ----------\n        value_function : ValueFunction\n            The first value function to compare.\n        new_value_function : ValueFunction\n            The second value function to compare.\n        belief_set : BeliefSet\n            The set of believes to check the values on to compute the max change on.\n\n        Returns\n        -------\n        max_change : float\n            The maximum change between value functions at belief points.\n        '''\n        # Get numpy corresponding to the arrays\n        xp = np if not gpu_support else cp.get_array_module(value_function.alpha_vector_array)\n\n        # Computing Delta for each beliefs\n        max_val_per_belief = xp.max(xp.matmul(belief_set.belief_array, value_function.alpha_vector_array.T), axis=1)\n        new_max_val_per_belief = xp.max(xp.matmul(belief_set.belief_array, new_value_function.alpha_vector_array.T), axis=1)\n        max_change = xp.max(xp.abs(new_max_val_per_belief - max_val_per_belief))\n\n        return max_change\n\n\n    def expand(self,\n               belief_set: BeliefSet,\n               value_function: ValueFunction,\n               max_generation: int,\n               **kwargs\n               ) -&gt; BeliefSet:\n        '''\n        Abstract function!\n        This function should be implemented in subclasses.\n        The expand function consists in the exploration of the belief set.\n        It takes as input a belief set and generates at most 'max_generation' beliefs from it.\n\n        The current value function is also passed as an argument as it is used in some PBVI techniques to guide the belief exploration.\n\n        Parameters\n        ----------\n        belief_set : BeliefSet\n            The belief or set of beliefs to be used as a starting point for the exploration.\n        value_function : ValueFunction\n            The current value function. To be used to guide the exploration process.\n        max_generation : int\n            How many beliefs to be generated at most.\n        kwargs\n            Special parameters for the particular flavors of the PBVI Agent.\n\n        Returns\n        -------\n        new_belief_set : BeliefSet\n            A new (or expanded) set of beliefs.\n        '''\n        raise NotImplementedError('PBVI class is abstract so expand function is not implemented, make an PBVI_agent subclass to implement the method')\n\n\n    def backup(self,\n               belief_set: BeliefSet,\n               value_function: ValueFunction,\n               gamma: float = 0.99,\n               append: bool = False,\n               belief_dominance_prune: bool = True\n               ) -&gt; ValueFunction:\n        '''\n        This function has purpose to update the set of alpha vectors. It does so in 3 steps:\n        1. It creates projections from each alpha vector for each possible action and each possible observation\n        2. It collapses this set of generated alpha vectors by taking the weighted sum of the alpha vectors weighted by the observation probability and this for each action and for each belief.\n        3. Then it further collapses the set to take the best alpha vector and action per belief\n        In the end we have a set of alpha vectors as large as the amount of beliefs.\n\n        The alpha vectors are also pruned to avoid duplicates and remove dominated ones.\n\n        Parameters\n        ----------\n        belief_set : BeliefSet\n            The belief set to use to generate the new alpha vectors with.\n        value_function : ValueFunction\n            The alpha vectors to generate the new set from.\n        gamma : float, default=0.99\n            The discount factor to value immediate rewards more than long term rewards.\n            The learning rate is 1/gamma.\n        append : bool, default=False\n            Whether to append the new alpha vectors generated to the old alpha vectors before pruning.\n        belief_dominance_prune : bool, default=True\n            Whether, before returning the new value function, checks what alpha vectors have a supperior value, if so it adds it.\n\n        Returns\n        -------\n        new_alpha_set : ValueFunction\n            A list of updated alpha vectors.\n        '''\n        xp = np if not self.on_gpu else cp\n        model = self.model\n\n        # Step 1\n        vector_array = value_function.alpha_vector_array\n        vectors_array_reachable_states = vector_array[xp.arange(vector_array.shape[0])[:,None,None,None], model.reachable_states[None,:,:,:]]\n\n        gamma_a_o_t = gamma * xp.einsum('saor,vsar-&gt;aovs', model.reachable_transitional_observation_table, vectors_array_reachable_states)\n\n        # Step 2\n        belief_array = belief_set.belief_array # bs\n        best_alpha_ind = xp.argmax(xp.tensordot(belief_array, gamma_a_o_t, (1,3)), axis=3) # argmax(bs,aovs-&gt;baov) -&gt; bao\n\n        best_alphas_per_o = gamma_a_o_t[model.actions[None,:,None,None], model.observations[None,None,:,None], best_alpha_ind[:,:,:,None], model.states[None,None,None,:]] # baos\n\n        alpha_a = model.expected_rewards_table.T + xp.sum(best_alphas_per_o, axis=2) # as + bas\n\n        # Step 3\n        best_actions = xp.argmax(xp.einsum('bas,bs-&gt;ba', alpha_a, belief_array), axis=1)\n        alpha_vectors = xp.take_along_axis(alpha_a, best_actions[:,None,None],axis=1)[:,0,:]\n\n        # Belief domination\n        if belief_dominance_prune:\n            best_value_per_belief = xp.sum((belief_array * alpha_vectors), axis=1)\n            old_best_value_per_belief = xp.max(xp.matmul(belief_array, vector_array.T), axis=1)\n            dominating_vectors = best_value_per_belief &gt; old_best_value_per_belief\n\n            best_actions = best_actions[dominating_vectors]\n            alpha_vectors = alpha_vectors[dominating_vectors]\n\n        # Creation of value function\n        new_value_function = ValueFunction(model, alpha_vectors, best_actions)\n\n        # Union with previous value function\n        if append:\n            new_value_function.extend(value_function)\n\n        return new_value_function\n\n\n    def modify_environment(self,\n                           new_environment: Environment\n                           ) -&gt; 'Agent':\n        '''\n        Function to modify the environment of the agent.\n        If the agent is already trained, the trained element should also be adapted to fit this new environment.\n\n        Parameters\n        ----------\n        new_environment : Environment\n            A modified environment.\n\n        Returns\n        -------\n        modified_agent : PBVI_Agent\n            A new pbvi agent with a modified environment\n        '''\n        # TODO: Fix this to account for other init parameters\n        # GPU support\n        if self.on_gpu:\n            return self.to_cpu().modify_environment(new_environment=new_environment)\n\n        # Creating a new agent instance\n        modified_agent = self.__class__(environment = new_environment,\n                                        thresholds = self.thresholds,\n                                        name = self.name)\n\n        # Modifying the value function\n        if self.value_function is not None:\n            reshaped_vf_array = np.array([cv2.resize(av, np.array(modified_agent.model.state_grid.shape)[::-1]).ravel()\n                                          for av in self.value_function.alpha_vector_array.reshape(len(self.value_function), *self.model.state_grid.shape)])\n            modified_vf = ValueFunction(modified_agent.model, alpha_vectors=reshaped_vf_array, action_list=self.value_function.actions)\n            modified_agent.value_function = modified_vf\n\n        return modified_agent\n\n\n    def initialize_state(self,\n                         n: int = 1,\n                         belief: BeliefSet | None = None\n                         ) -&gt; None:\n        '''\n        To use an agent within a simulation, the agent's state needs to be initialized.\n        The initialization consists of setting the agent's initial belief.\n        Multiple agents can be used at once for simulations, for this reason, the belief parameter is a BeliefSet by default.\n\n        Parameters\n        ----------\n        n : int, default=1\n            How many agents are to be used during the simulation.\n        belief : BeliefSet, optional\n            An optional set of beliefs to initialize the simulations with.\n        '''\n        assert self.value_function is not None, \"Agent was not trained, run the training function first...\"\n\n        if belief is None:\n            self.belief = BeliefSet(self.model, [Belief(self.model) for _ in range(n)])\n        else:\n            assert len(belief) == n, f\"The amount of beliefs provided ({len(belief)}) to initialize the state need to match the amount of stimulations to initialize (n={n}).\"\n\n            if self.on_gpu and not belief.is_on_gpu:\n                self.belief = belief.to_gpu()\n            elif not self.on_gpu and belief.is_on_gpu:\n                self.belief = belief.to_cpu()\n            else:\n                self.belief = belief\n\n\n    def choose_action(self) -&gt; np.ndarray:\n        '''\n        Function to let the agent or set of agents choose an action based on their current belief.\n\n        Returns\n        -------\n        movement_vector : np.ndarray\n            A single or a list of actions chosen by the agent(s) based on their belief.\n        '''\n        assert self.belief is not None, \"Agent was not initialized yet, run the initialize_state function first\"\n\n        # Evaluated value function\n        _, action = self.value_function.evaluate_at(self.belief)\n\n        # Recording the action played\n        self.action_played = action\n\n        # Converting action indexes to movement vectors\n        movemement_vector = self.action_set[action,:]\n\n        return movemement_vector\n\n\n    def update_state(self,\n                     action: np.ndarray,\n                     observation: np.ndarray,\n                     source_reached: np.ndarray\n                     ) -&gt; None | np.ndarray:\n        '''\n        Function to update the internal state(s) of the agent(s) based on the previous action(s) taken and the observation(s) received.\n\n        Parameters\n        ----------\n        action : np.ndarray\n            A 2D array of n movement vectors. If the environment is layered, the 1st component should be the layer.\n        observation : np.ndarray\n            The observation(s) the agent(s) made.\n        source_reached : np.ndarray\n            A boolean array of whether the agent(s) have reached the source or not.\n\n        Returns\n        -------\n        update_successfull : np.ndarray, optional\n            If nothing is returned, it means all the agent's state updates have been successfull.\n            Else, a boolean np.ndarray of size n can be returned confirming for each agent whether the update has been successful or not.\n        '''\n        assert self.belief is not None, \"Agent was not initialized yet, run the initialize_state function first\"\n\n        # Discretizing observations\n        observation_ids = self.discretize_observations(observation=observation, action=action, source_reached=source_reached)\n\n        # Update the set of beliefs\n        self.belief = self.belief.update(actions=self.action_played, observations=observation_ids, throw_error=False)\n\n        # Check for failed updates\n        update_successful = (self.belief.belief_array.sum(axis=1) != 0.0)\n\n        return update_successful\n\n\n    def kill(self,\n             simulations_to_kill: np.ndarray\n             ) -&gt; None:\n        '''\n        Function to kill any simulations that have not reached the source but can't continue further\n\n        Parameters\n        ----------\n        simulations_to_kill : np.ndarray\n            A boolean array of the simulations to kill.\n        '''\n        if all(simulations_to_kill):\n            self.belief = None\n        else:\n            self.belief = BeliefSet(self.belief.model, self.belief.belief_array[~simulations_to_kill])\n\n\n    def generate_beliefs_from_trajectory(self,\n                                         history: SimulationHistory,\n                                         trajectory_i: int = 0,\n                                         initial_belief: Belief | None = None\n                                         ) -&gt; BeliefSet:\n        '''\n        Function to generate a sequence of belief points from the trajectory from SimulationHistory instance.\n\n        Parameters\n        ----------\n        history : SimulationHistory\n            The simulation history from which the agent's trajectory is extracted.\n        trajectory_i : int, default=0\n            The id of the trajectory from which to build the belief sequence.\n        initial_belief : Belief, optional\n            The initial belief point from which to start the sequence.\n\n        Returns\n        -------\n        belief_sequence : BeliefSet\n            The sequence of beliefs the agent going through in the the trajectory of the simulation.\n        '''\n        # If the initial belief is not provided, generate one\n        if initial_belief is None:\n            initial_belief = Belief(self.model)\n\n        # Retrieve the trjactory's simulation dataframe\n        df = history.simulation_dfs[trajectory_i]\n\n        # Set the belief that will be iterate on\n        belief = initial_belief\n\n        # Belief sequence to be returned at the end\n        belief_sequence = [initial_belief]\n\n        for row_id, row in enumerate(df.iterrows()):\n            row = row[1]\n\n            # Skip initial position\n            if row_id == 0:\n                continue\n\n            # Check the ID of the action\n            a = np.argwhere(np.all((self.action_set == [row['dy'],row['dx']]), axis=1))[0,0]\n\n            # Retrieve observations\n            o = [row['o']]\n            if self.space_aware:\n                o += [row['y'],row['x']]\n\n            # Discretize observations\n            discrete_o = self.discretize_observations(observation=np.array([o]), action=np.array([a]), source_reached=np.array([False]))[0]\n\n            try:\n                # Update belief\n                belief = belief.update(a=a, o=discrete_o)\n                belief_sequence.append(belief)\n            except:\n                print(f'[Warning] Update of belief failed at step {row_id}...')\n\n        return BeliefSet(self.model, belief_sequence)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_Agent.backup","title":"<code>backup(belief_set, value_function, gamma=0.99, append=False, belief_dominance_prune=True)</code>","text":"<p>This function has purpose to update the set of alpha vectors. It does so in 3 steps: 1. It creates projections from each alpha vector for each possible action and each possible observation 2. It collapses this set of generated alpha vectors by taking the weighted sum of the alpha vectors weighted by the observation probability and this for each action and for each belief. 3. Then it further collapses the set to take the best alpha vector and action per belief In the end we have a set of alpha vectors as large as the amount of beliefs.</p> <p>The alpha vectors are also pruned to avoid duplicates and remove dominated ones.</p> <p>Parameters:</p> Name Type Description Default <code>belief_set</code> <code>BeliefSet</code> <p>The belief set to use to generate the new alpha vectors with.</p> required <code>value_function</code> <code>ValueFunction</code> <p>The alpha vectors to generate the new set from.</p> required <code>gamma</code> <code>float</code> <p>The discount factor to value immediate rewards more than long term rewards. The learning rate is 1/gamma.</p> <code>0.99</code> <code>append</code> <code>bool</code> <p>Whether to append the new alpha vectors generated to the old alpha vectors before pruning.</p> <code>False</code> <code>belief_dominance_prune</code> <code>bool</code> <p>Whether, before returning the new value function, checks what alpha vectors have a supperior value, if so it adds it.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>new_alpha_set</code> <code>ValueFunction</code> <p>A list of updated alpha vectors.</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def backup(self,\n           belief_set: BeliefSet,\n           value_function: ValueFunction,\n           gamma: float = 0.99,\n           append: bool = False,\n           belief_dominance_prune: bool = True\n           ) -&gt; ValueFunction:\n    '''\n    This function has purpose to update the set of alpha vectors. It does so in 3 steps:\n    1. It creates projections from each alpha vector for each possible action and each possible observation\n    2. It collapses this set of generated alpha vectors by taking the weighted sum of the alpha vectors weighted by the observation probability and this for each action and for each belief.\n    3. Then it further collapses the set to take the best alpha vector and action per belief\n    In the end we have a set of alpha vectors as large as the amount of beliefs.\n\n    The alpha vectors are also pruned to avoid duplicates and remove dominated ones.\n\n    Parameters\n    ----------\n    belief_set : BeliefSet\n        The belief set to use to generate the new alpha vectors with.\n    value_function : ValueFunction\n        The alpha vectors to generate the new set from.\n    gamma : float, default=0.99\n        The discount factor to value immediate rewards more than long term rewards.\n        The learning rate is 1/gamma.\n    append : bool, default=False\n        Whether to append the new alpha vectors generated to the old alpha vectors before pruning.\n    belief_dominance_prune : bool, default=True\n        Whether, before returning the new value function, checks what alpha vectors have a supperior value, if so it adds it.\n\n    Returns\n    -------\n    new_alpha_set : ValueFunction\n        A list of updated alpha vectors.\n    '''\n    xp = np if not self.on_gpu else cp\n    model = self.model\n\n    # Step 1\n    vector_array = value_function.alpha_vector_array\n    vectors_array_reachable_states = vector_array[xp.arange(vector_array.shape[0])[:,None,None,None], model.reachable_states[None,:,:,:]]\n\n    gamma_a_o_t = gamma * xp.einsum('saor,vsar-&gt;aovs', model.reachable_transitional_observation_table, vectors_array_reachable_states)\n\n    # Step 2\n    belief_array = belief_set.belief_array # bs\n    best_alpha_ind = xp.argmax(xp.tensordot(belief_array, gamma_a_o_t, (1,3)), axis=3) # argmax(bs,aovs-&gt;baov) -&gt; bao\n\n    best_alphas_per_o = gamma_a_o_t[model.actions[None,:,None,None], model.observations[None,None,:,None], best_alpha_ind[:,:,:,None], model.states[None,None,None,:]] # baos\n\n    alpha_a = model.expected_rewards_table.T + xp.sum(best_alphas_per_o, axis=2) # as + bas\n\n    # Step 3\n    best_actions = xp.argmax(xp.einsum('bas,bs-&gt;ba', alpha_a, belief_array), axis=1)\n    alpha_vectors = xp.take_along_axis(alpha_a, best_actions[:,None,None],axis=1)[:,0,:]\n\n    # Belief domination\n    if belief_dominance_prune:\n        best_value_per_belief = xp.sum((belief_array * alpha_vectors), axis=1)\n        old_best_value_per_belief = xp.max(xp.matmul(belief_array, vector_array.T), axis=1)\n        dominating_vectors = best_value_per_belief &gt; old_best_value_per_belief\n\n        best_actions = best_actions[dominating_vectors]\n        alpha_vectors = alpha_vectors[dominating_vectors]\n\n    # Creation of value function\n    new_value_function = ValueFunction(model, alpha_vectors, best_actions)\n\n    # Union with previous value function\n    if append:\n        new_value_function.extend(value_function)\n\n    return new_value_function\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_Agent.choose_action","title":"<code>choose_action()</code>","text":"<p>Function to let the agent or set of agents choose an action based on their current belief.</p> <p>Returns:</p> Name Type Description <code>movement_vector</code> <code>ndarray</code> <p>A single or a list of actions chosen by the agent(s) based on their belief.</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def choose_action(self) -&gt; np.ndarray:\n    '''\n    Function to let the agent or set of agents choose an action based on their current belief.\n\n    Returns\n    -------\n    movement_vector : np.ndarray\n        A single or a list of actions chosen by the agent(s) based on their belief.\n    '''\n    assert self.belief is not None, \"Agent was not initialized yet, run the initialize_state function first\"\n\n    # Evaluated value function\n    _, action = self.value_function.evaluate_at(self.belief)\n\n    # Recording the action played\n    self.action_played = action\n\n    # Converting action indexes to movement vectors\n    movemement_vector = self.action_set[action,:]\n\n    return movemement_vector\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_Agent.compute_change","title":"<code>compute_change(value_function, new_value_function, belief_set)</code>","text":"<p>Function to compute whether the change between two value functions can be considered as having converged based on the eps parameter of the Solver. It check for each belief, the maximum value and take the max change between believe's value functions. If this max change is lower than eps * (gamma / (1 - gamma)).</p> <p>Parameters:</p> Name Type Description Default <code>value_function</code> <code>ValueFunction</code> <p>The first value function to compare.</p> required <code>new_value_function</code> <code>ValueFunction</code> <p>The second value function to compare.</p> required <code>belief_set</code> <code>BeliefSet</code> <p>The set of believes to check the values on to compute the max change on.</p> required <p>Returns:</p> Name Type Description <code>max_change</code> <code>float</code> <p>The maximum change between value functions at belief points.</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def compute_change(self,\n                   value_function: ValueFunction,\n                   new_value_function: ValueFunction,\n                   belief_set: BeliefSet\n                   ) -&gt; float:\n    '''\n    Function to compute whether the change between two value functions can be considered as having converged based on the eps parameter of the Solver.\n    It check for each belief, the maximum value and take the max change between believe's value functions.\n    If this max change is lower than eps * (gamma / (1 - gamma)).\n\n    Parameters\n    ----------\n    value_function : ValueFunction\n        The first value function to compare.\n    new_value_function : ValueFunction\n        The second value function to compare.\n    belief_set : BeliefSet\n        The set of believes to check the values on to compute the max change on.\n\n    Returns\n    -------\n    max_change : float\n        The maximum change between value functions at belief points.\n    '''\n    # Get numpy corresponding to the arrays\n    xp = np if not gpu_support else cp.get_array_module(value_function.alpha_vector_array)\n\n    # Computing Delta for each beliefs\n    max_val_per_belief = xp.max(xp.matmul(belief_set.belief_array, value_function.alpha_vector_array.T), axis=1)\n    new_max_val_per_belief = xp.max(xp.matmul(belief_set.belief_array, new_value_function.alpha_vector_array.T), axis=1)\n    max_change = xp.max(xp.abs(new_max_val_per_belief - max_val_per_belief))\n\n    return max_change\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_Agent.expand","title":"<code>expand(belief_set, value_function, max_generation, **kwargs)</code>","text":"<p>Abstract function! This function should be implemented in subclasses. The expand function consists in the exploration of the belief set. It takes as input a belief set and generates at most 'max_generation' beliefs from it.</p> <p>The current value function is also passed as an argument as it is used in some PBVI techniques to guide the belief exploration.</p> <p>Parameters:</p> Name Type Description Default <code>belief_set</code> <code>BeliefSet</code> <p>The belief or set of beliefs to be used as a starting point for the exploration.</p> required <code>value_function</code> <code>ValueFunction</code> <p>The current value function. To be used to guide the exploration process.</p> required <code>max_generation</code> <code>int</code> <p>How many beliefs to be generated at most.</p> required <code>kwargs</code> <p>Special parameters for the particular flavors of the PBVI Agent.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>new_belief_set</code> <code>BeliefSet</code> <p>A new (or expanded) set of beliefs.</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def expand(self,\n           belief_set: BeliefSet,\n           value_function: ValueFunction,\n           max_generation: int,\n           **kwargs\n           ) -&gt; BeliefSet:\n    '''\n    Abstract function!\n    This function should be implemented in subclasses.\n    The expand function consists in the exploration of the belief set.\n    It takes as input a belief set and generates at most 'max_generation' beliefs from it.\n\n    The current value function is also passed as an argument as it is used in some PBVI techniques to guide the belief exploration.\n\n    Parameters\n    ----------\n    belief_set : BeliefSet\n        The belief or set of beliefs to be used as a starting point for the exploration.\n    value_function : ValueFunction\n        The current value function. To be used to guide the exploration process.\n    max_generation : int\n        How many beliefs to be generated at most.\n    kwargs\n        Special parameters for the particular flavors of the PBVI Agent.\n\n    Returns\n    -------\n    new_belief_set : BeliefSet\n        A new (or expanded) set of beliefs.\n    '''\n    raise NotImplementedError('PBVI class is abstract so expand function is not implemented, make an PBVI_agent subclass to implement the method')\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_Agent.generate_beliefs_from_trajectory","title":"<code>generate_beliefs_from_trajectory(history, trajectory_i=0, initial_belief=None)</code>","text":"<p>Function to generate a sequence of belief points from the trajectory from SimulationHistory instance.</p> <p>Parameters:</p> Name Type Description Default <code>history</code> <code>SimulationHistory</code> <p>The simulation history from which the agent's trajectory is extracted.</p> required <code>trajectory_i</code> <code>int</code> <p>The id of the trajectory from which to build the belief sequence.</p> <code>0</code> <code>initial_belief</code> <code>Belief</code> <p>The initial belief point from which to start the sequence.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>belief_sequence</code> <code>BeliefSet</code> <p>The sequence of beliefs the agent going through in the the trajectory of the simulation.</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def generate_beliefs_from_trajectory(self,\n                                     history: SimulationHistory,\n                                     trajectory_i: int = 0,\n                                     initial_belief: Belief | None = None\n                                     ) -&gt; BeliefSet:\n    '''\n    Function to generate a sequence of belief points from the trajectory from SimulationHistory instance.\n\n    Parameters\n    ----------\n    history : SimulationHistory\n        The simulation history from which the agent's trajectory is extracted.\n    trajectory_i : int, default=0\n        The id of the trajectory from which to build the belief sequence.\n    initial_belief : Belief, optional\n        The initial belief point from which to start the sequence.\n\n    Returns\n    -------\n    belief_sequence : BeliefSet\n        The sequence of beliefs the agent going through in the the trajectory of the simulation.\n    '''\n    # If the initial belief is not provided, generate one\n    if initial_belief is None:\n        initial_belief = Belief(self.model)\n\n    # Retrieve the trjactory's simulation dataframe\n    df = history.simulation_dfs[trajectory_i]\n\n    # Set the belief that will be iterate on\n    belief = initial_belief\n\n    # Belief sequence to be returned at the end\n    belief_sequence = [initial_belief]\n\n    for row_id, row in enumerate(df.iterrows()):\n        row = row[1]\n\n        # Skip initial position\n        if row_id == 0:\n            continue\n\n        # Check the ID of the action\n        a = np.argwhere(np.all((self.action_set == [row['dy'],row['dx']]), axis=1))[0,0]\n\n        # Retrieve observations\n        o = [row['o']]\n        if self.space_aware:\n            o += [row['y'],row['x']]\n\n        # Discretize observations\n        discrete_o = self.discretize_observations(observation=np.array([o]), action=np.array([a]), source_reached=np.array([False]))[0]\n\n        try:\n            # Update belief\n            belief = belief.update(a=a, o=discrete_o)\n            belief_sequence.append(belief)\n        except:\n            print(f'[Warning] Update of belief failed at step {row_id}...')\n\n    return BeliefSet(self.model, belief_sequence)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_Agent.initialize_state","title":"<code>initialize_state(n=1, belief=None)</code>","text":"<p>To use an agent within a simulation, the agent's state needs to be initialized. The initialization consists of setting the agent's initial belief. Multiple agents can be used at once for simulations, for this reason, the belief parameter is a BeliefSet by default.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>How many agents are to be used during the simulation.</p> <code>1</code> <code>belief</code> <code>BeliefSet</code> <p>An optional set of beliefs to initialize the simulations with.</p> <code>None</code> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def initialize_state(self,\n                     n: int = 1,\n                     belief: BeliefSet | None = None\n                     ) -&gt; None:\n    '''\n    To use an agent within a simulation, the agent's state needs to be initialized.\n    The initialization consists of setting the agent's initial belief.\n    Multiple agents can be used at once for simulations, for this reason, the belief parameter is a BeliefSet by default.\n\n    Parameters\n    ----------\n    n : int, default=1\n        How many agents are to be used during the simulation.\n    belief : BeliefSet, optional\n        An optional set of beliefs to initialize the simulations with.\n    '''\n    assert self.value_function is not None, \"Agent was not trained, run the training function first...\"\n\n    if belief is None:\n        self.belief = BeliefSet(self.model, [Belief(self.model) for _ in range(n)])\n    else:\n        assert len(belief) == n, f\"The amount of beliefs provided ({len(belief)}) to initialize the state need to match the amount of stimulations to initialize (n={n}).\"\n\n        if self.on_gpu and not belief.is_on_gpu:\n            self.belief = belief.to_gpu()\n        elif not self.on_gpu and belief.is_on_gpu:\n            self.belief = belief.to_cpu()\n        else:\n            self.belief = belief\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_Agent.kill","title":"<code>kill(simulations_to_kill)</code>","text":"<p>Function to kill any simulations that have not reached the source but can't continue further</p> <p>Parameters:</p> Name Type Description Default <code>simulations_to_kill</code> <code>ndarray</code> <p>A boolean array of the simulations to kill.</p> required Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def kill(self,\n         simulations_to_kill: np.ndarray\n         ) -&gt; None:\n    '''\n    Function to kill any simulations that have not reached the source but can't continue further\n\n    Parameters\n    ----------\n    simulations_to_kill : np.ndarray\n        A boolean array of the simulations to kill.\n    '''\n    if all(simulations_to_kill):\n        self.belief = None\n    else:\n        self.belief = BeliefSet(self.belief.model, self.belief.belief_array[~simulations_to_kill])\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_Agent.load","title":"<code>load(folder)</code>  <code>classmethod</code>","text":"<p>Function to load a PBVI agent from a given folder it has been saved to. It will load the environment the agent has been trained on along with it.</p> <p>If it is a subclass of the PBVI_Agent, an instance of that specific subclass will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>The agent folder.</p> required <p>Returns:</p> Name Type Description <code>instance</code> <code>PBVI_Agent</code> <p>The loaded instance of the PBVI Agent.</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>@classmethod\ndef load(cls,\n         folder: str\n         ) -&gt; 'PBVI_Agent':\n    '''\n    Function to load a PBVI agent from a given folder it has been saved to.\n    It will load the environment the agent has been trained on along with it.\n\n    If it is a subclass of the PBVI_Agent, an instance of that specific subclass will be returned.\n\n    Parameters\n    ----------\n    folder : str\n        The agent folder.\n\n    Returns\n    -------\n    instance : PBVI_Agent\n        The loaded instance of the PBVI Agent.\n    '''\n    # Load arguments\n    arguments = None\n    with open(folder + '/METADATA.json', 'r') as json_file:\n        arguments = json.load(json_file)\n\n    # Load environment\n    environment = Environment.load(arguments['environment_saved_at'])\n\n    # Load specific class\n    if arguments['class'] != 'PBVI_Agent':\n        from olfactory_navigation import agents\n        cls = {name:obj for name, obj in inspect.getmembers(agents)}[arguments['class']]\n\n    # Build instance\n    instance = cls(\n        environment = environment,\n        thresholds = arguments['thresholds'],\n        space_aware = arguments['space_aware'],\n        spacial_subdivisions = np.array(arguments['spacial_subdivisions']),\n        actions = {a_label: a_vector for a_label, a_vector in zip(arguments['action_labels'], arguments['action_set'])},\n        name = arguments['name'],\n        seed = arguments['seed']\n    )\n\n    # Load and set the value function on the instance\n    instance.value_function = ValueFunction.load(\n        file=folder + '/Value_Function.npy',\n        model=instance.model\n    )\n    instance.trained_at = arguments['trained_at']\n    instance.saved_at = folder\n\n    return instance\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_Agent.modify_environment","title":"<code>modify_environment(new_environment)</code>","text":"<p>Function to modify the environment of the agent. If the agent is already trained, the trained element should also be adapted to fit this new environment.</p> <p>Parameters:</p> Name Type Description Default <code>new_environment</code> <code>Environment</code> <p>A modified environment.</p> required <p>Returns:</p> Name Type Description <code>modified_agent</code> <code>PBVI_Agent</code> <p>A new pbvi agent with a modified environment</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def modify_environment(self,\n                       new_environment: Environment\n                       ) -&gt; 'Agent':\n    '''\n    Function to modify the environment of the agent.\n    If the agent is already trained, the trained element should also be adapted to fit this new environment.\n\n    Parameters\n    ----------\n    new_environment : Environment\n        A modified environment.\n\n    Returns\n    -------\n    modified_agent : PBVI_Agent\n        A new pbvi agent with a modified environment\n    '''\n    # TODO: Fix this to account for other init parameters\n    # GPU support\n    if self.on_gpu:\n        return self.to_cpu().modify_environment(new_environment=new_environment)\n\n    # Creating a new agent instance\n    modified_agent = self.__class__(environment = new_environment,\n                                    thresholds = self.thresholds,\n                                    name = self.name)\n\n    # Modifying the value function\n    if self.value_function is not None:\n        reshaped_vf_array = np.array([cv2.resize(av, np.array(modified_agent.model.state_grid.shape)[::-1]).ravel()\n                                      for av in self.value_function.alpha_vector_array.reshape(len(self.value_function), *self.model.state_grid.shape)])\n        modified_vf = ValueFunction(modified_agent.model, alpha_vectors=reshaped_vf_array, action_list=self.value_function.actions)\n        modified_agent.value_function = modified_vf\n\n    return modified_agent\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_Agent.save","title":"<code>save(folder=None, force=False, save_environment=False)</code>","text":"<p>The save function for PBVI Agents consists in recording the value function after the training. It saves the agent in a folder with the name of the agent (class name + training timestamp). In this folder, there will be the metadata of the agent (all the attributes) in a json format and the value function.</p> <p>Optionally, the environment can be saved too to be able to load it alongside the agent for future reuse. If the agent has already been saved, the saving will not happen unless the force parameter is toggled.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>The folder under which to save the agent (a subfolder will be created under this folder). The agent will therefore be saved at /Agent- . By default the current folder is used. <code>None</code> <code>force</code> <code>bool</code> <p>Whether to overwrite an already saved agent with the same name at the same path.</p> <code>False</code> <code>save_environment</code> <code>bool</code> <p>Whether to save the environment data along with the agent.</p> <code>False</code> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def save(self,\n         folder: str | None = None,\n         force: bool = False,\n         save_environment: bool = False\n         ) -&gt; None:\n    '''\n    The save function for PBVI Agents consists in recording the value function after the training.\n    It saves the agent in a folder with the name of the agent (class name + training timestamp).\n    In this folder, there will be the metadata of the agent (all the attributes) in a json format and the value function.\n\n    Optionally, the environment can be saved too to be able to load it alongside the agent for future reuse.\n    If the agent has already been saved, the saving will not happen unless the force parameter is toggled.\n\n    Parameters\n    ----------\n    folder : str, optional\n        The folder under which to save the agent (a subfolder will be created under this folder).\n        The agent will therefore be saved at &lt;folder&gt;/Agent-&lt;agent_name&gt; .\n        By default the current folder is used.\n    force : bool, default=False\n        Whether to overwrite an already saved agent with the same name at the same path.\n    save_environment : bool, default=False\n        Whether to save the environment data along with the agent.\n    '''\n    assert self.trained_at is not None, \"The agent is not trained, there is nothing to save.\"\n\n    # GPU support\n    if self.on_gpu:\n        self.cpu_version.save(folder=folder, force=force, save_environment=save_environment)\n        return\n\n    # Adding env name to folder path\n    if folder is None:\n        folder = f'./Agent-{self.name}'\n    else:\n        folder += '/Agent-' + self.name\n\n    # Checking the folder exists or creates it\n    if not os.path.exists(folder):\n        os.mkdir(folder)\n    elif len(os.listdir(folder)):\n        if force:\n            shutil.rmtree(folder)\n            os.mkdir(folder)\n        else:\n            raise Exception(f'{folder} is not empty. If you want to overwrite the saved model, enable \"force\".')\n\n    # If requested save environment\n    if save_environment:\n        self.environment.save(folder=folder)\n\n    # TODO: Add MODEL to save function\n    # Generating the metadata arguments dictionary\n    arguments = {}\n    arguments['name'] = self.name\n    arguments['class'] = self.class_name\n    if len(self.thresholds.shape) == 2:\n        arguments['thresholds'] = {layer_lab: layer_thresholds for layer_lab, layer_thresholds in zip(self.environment.layer_labels, self.thresholds.tolist())}\n    else:\n        arguments['thresholds'] = self.thresholds.tolist()\n    arguments['environment_name'] = self.environment.name\n    arguments['environment_saved_at'] = self.environment.saved_at\n    arguments['space_aware'] = self.space_aware\n    arguments['spacial_subdivisions'] = self.spacial_subdivisions.tolist()\n    arguments['action_labels'] = self.action_labels\n    arguments['action_set'] = self.action_set.tolist()\n    arguments['trained_at'] = self.trained_at\n    arguments['seed'] = self.seed\n\n    # Output the arguments to a METADATA file\n    with open(folder + '/METADATA.json', 'w') as json_file:\n        json.dump(arguments, json_file, indent=4)\n\n    # Save value function\n    self.value_function.save(folder=folder, file_name='Value_Function.npy')\n\n    # Finalization\n    self.saved_at = os.path.abspath(folder).replace('\\\\', '/')\n    print(f'Agent saved to: {folder}')\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_Agent.to_cpu","title":"<code>to_cpu()</code>","text":"<p>Function to send the numpy arrays of the agent to the cpu. It returns a new instance of the Agent class with the arrays on the cpu.</p> <p>Returns:</p> Name Type Description <code>cpu_agent</code> <code>Agent</code> <p>A new environment instance where the arrays are on the cpu memory.</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def to_cpu(self) -&gt; 'PBVI_Agent':\n    '''\n    Function to send the numpy arrays of the agent to the cpu.\n    It returns a new instance of the Agent class with the arrays on the cpu.\n\n    Returns\n    -------\n    cpu_agent : Agent\n        A new environment instance where the arrays are on the cpu memory.\n    '''\n    # Check whether the agent is already on the cpu or not\n    if not self.on_gpu:\n        return self\n\n    if self._alternate_version is not None:\n        print('[warning] A CPU instance already existed and is being recreated.')\n        self._alternate_version = None\n\n    # Generating a new instance\n    cls = self.__class__\n    cpu_agent = cls.__new__(cls)\n\n    # Copying arguments to gpu\n    for arg, val in self.__dict__.items():\n        if isinstance(val, cp.ndarray):\n            setattr(cpu_agent, arg, cp.asnumpy(val))\n        elif arg == 'rnd_state':\n            setattr(cpu_agent, arg, np.random.RandomState(self.seed))\n        elif isinstance(val, Model):\n            setattr(cpu_agent, arg, val.cpu_model)\n        elif isinstance(val, ValueFunction):\n            setattr(cpu_agent, arg, val.to_cpu())\n        elif isinstance(val, BeliefSet) or isinstance(val, Belief):\n            setattr(cpu_agent, arg, val.to_cpu())\n        else:\n            setattr(cpu_agent, arg, val)\n\n    # Self reference instances\n    self._alternate_version = cpu_agent\n    cpu_agent._alternate_version = self\n\n    cpu_agent.on_gpu = True\n    return cpu_agent\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_Agent.to_gpu","title":"<code>to_gpu()</code>","text":"<p>Function to send the numpy arrays of the agent to the gpu. It returns a new instance of the Agent class with the arrays on the gpu.</p> <p>Returns:</p> Name Type Description <code>gpu_agent</code> <code>Agent</code> <p>A copy of the agent with the arrays on the GPU.</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def to_gpu(self) -&gt; 'PBVI_Agent':\n    '''\n    Function to send the numpy arrays of the agent to the gpu.\n    It returns a new instance of the Agent class with the arrays on the gpu.\n\n    Returns\n    -------\n    gpu_agent : Agent\n        A copy of the agent with the arrays on the GPU.\n    '''\n    # Check whether the agent is already on the gpu or not\n    if self.on_gpu:\n        return self\n\n    # Warn and overwrite alternate_version in case it already exists\n    if self._alternate_version is not None:\n        print('[warning] A GPU instance already existed and is being recreated.')\n        self._alternate_version = None\n\n    assert gpu_support, \"GPU support is not enabled, Cupy might need to be installed...\"\n\n    # Generating a new instance\n    cls = self.__class__\n    gpu_agent = cls.__new__(cls)\n\n    # Copying arguments to gpu\n    for arg, val in self.__dict__.items():\n        if isinstance(val, np.ndarray):\n            setattr(gpu_agent, arg, cp.array(val))\n        elif arg == 'rnd_state':\n            setattr(gpu_agent, arg, cp.random.RandomState(self.seed))\n        elif isinstance(val, Model):\n            setattr(gpu_agent, arg, val.gpu_model)\n        elif isinstance(val, ValueFunction):\n            setattr(gpu_agent, arg, val.to_gpu())\n        elif isinstance(val, BeliefSet) or isinstance(val, Belief):\n            setattr(gpu_agent, arg, val.to_gpu())\n        else:\n            setattr(gpu_agent, arg, val)\n\n    # Self reference instances\n    self._alternate_version = gpu_agent\n    gpu_agent._alternate_version = self\n\n    gpu_agent.on_gpu = True\n    return gpu_agent\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_Agent.train","title":"<code>train(expansions, full_backup=True, update_passes=1, max_belief_growth=10, initial_belief=None, initial_value_function=None, prune_level=1, prune_interval=10, limit_value_function_size=-1, gamma=0.99, eps=1e-06, use_gpu=False, history_tracking_level=1, overwrite_training=False, print_progress=True, print_stats=True, **expand_arguments)</code>","text":"<p>Main loop of the Point-Based Value Iteration algorithm. It consists in 2 steps, Backup and Expand. 1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function 2. Backup: Updates the alpha vectors based on the current belief set</p> <p>Parameters:</p> Name Type Description Default <code>expansions</code> <code>int</code> <p>How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)</p> required <code>full_backup</code> <code>bool</code> <p>Whether to force the backup function has to be run on the full set beliefs uncovered since the beginning or only on the new points.</p> <code>True</code> <code>update_passes</code> <code>int</code> <p>How many times the backup function has to be run every time the belief set is expanded.</p> <code>1</code> <code>max_belief_growth</code> <code>int</code> <p>How many beliefs can be added at every expansion step to the belief set.</p> <code>10</code> <code>initial_belief</code> <code>BeliefSet or Belief</code> <p>An initial list of beliefs to start with.</p> <code>None</code> <code>initial_value_function</code> <code>ValueFunction</code> <p>An initial value function to start the solving process with.</p> <code>None</code> <code>prune_level</code> <code>int</code> <p>Parameter to prune the value function further before the expand function.</p> <code>1</code> <code>prune_interval</code> <code>int</code> <p>How often to prune the value function. It is counted in number of backup iterations.</p> <code>10</code> <code>limit_value_function_size</code> <code>int</code> <p>When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function If set to -1, the value function can grow without bounds.</p> <code>-1</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU with cupy array to accelerate solving.</p> <code>False</code> <code>gamma</code> <code>float</code> <p>The discount factor to value immediate rewards more than long term rewards. The learning rate is 1/gamma.</p> <code>0.99</code> <code>eps</code> <code>float</code> <p>The smallest allowed changed for the value function. Bellow the amound of change, the value function is considered converged and the value iteration process will end early.</p> <code>1e-6</code> <code>history_tracking_level</code> <code>int</code> <p>How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)</p> <code>1</code> <code>overwrite_training</code> <code>bool</code> <p>Whether to force the overwriting of the training if a value function already exists for this agent.</p> <code>False</code> <code>print_progress</code> <code>bool</code> <p>Whether or not to print out the progress of the value iteration process.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether or not to print out statistics at the end of the training run.</p> <code>True</code> <code>expand_arguments</code> <code>kwargs</code> <p>An arbitrary amount of parameters that will be passed on to the expand function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>solver_history</code> <code>SolverHistory</code> <p>The history of the solving process with some plotting options.</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def train(self,\n          expansions: int,\n          full_backup: bool = True,\n          update_passes: int = 1,\n          max_belief_growth: int = 10,\n          initial_belief: BeliefSet | Belief | None = None,\n          initial_value_function: ValueFunction | None = None,\n          prune_level: int = 1,\n          prune_interval: int = 10,\n          limit_value_function_size: int = -1,\n          gamma: float = 0.99,\n          eps: float = 1e-6,\n          use_gpu: bool = False,\n          history_tracking_level: int = 1,\n          overwrite_training: bool = False,\n          print_progress: bool = True,\n          print_stats: bool = True,\n          **expand_arguments\n          ) -&gt; TrainingHistory:\n    '''\n    Main loop of the Point-Based Value Iteration algorithm.\n    It consists in 2 steps, Backup and Expand.\n    1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n    2. Backup: Updates the alpha vectors based on the current belief set\n\n    Parameters\n    ----------\n    expansions : int\n        How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n    full_backup : bool, default=True\n        Whether to force the backup function has to be run on the full set beliefs uncovered since the beginning or only on the new points.\n    update_passes : int, default=1\n        How many times the backup function has to be run every time the belief set is expanded.\n    max_belief_growth : int, default=10\n        How many beliefs can be added at every expansion step to the belief set.\n    initial_belief : BeliefSet or Belief, optional\n        An initial list of beliefs to start with.\n    initial_value_function : ValueFunction, optional\n        An initial value function to start the solving process with.\n    prune_level : int, default=1\n        Parameter to prune the value function further before the expand function.\n    prune_interval : int, default=10\n        How often to prune the value function. It is counted in number of backup iterations.\n    limit_value_function_size : int, default=-1\n        When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n        If set to -1, the value function can grow without bounds.\n    use_gpu : bool, default=False\n        Whether to use the GPU with cupy array to accelerate solving.\n    gamma : float, default=0.99\n        The discount factor to value immediate rewards more than long term rewards.\n        The learning rate is 1/gamma.\n    eps : float, default=1e-6\n        The smallest allowed changed for the value function.\n        Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n    history_tracking_level : int, default=1\n        How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n    overwrite_training : bool, default=False\n        Whether to force the overwriting of the training if a value function already exists for this agent.\n    print_progress : bool, default=True\n        Whether or not to print out the progress of the value iteration process.\n    print_stats : bool, default=True\n        Whether or not to print out statistics at the end of the training run.\n    expand_arguments : kwargs\n        An arbitrary amount of parameters that will be passed on to the expand function.\n\n    Returns\n    -------\n    solver_history : SolverHistory\n        The history of the solving process with some plotting options.\n    '''\n    # GPU support\n    if use_gpu and not self.on_gpu:\n        gpu_agent = self.to_gpu()\n        solver_history = super(self.__class__, gpu_agent).train(\n            expansions=expansions,\n            full_backup=full_backup,\n            update_passes=update_passes,\n            max_belief_growth=max_belief_growth,\n            initial_belief=initial_belief,\n            initial_value_function=initial_value_function,\n            prune_level=prune_level,\n            prune_interval=prune_interval,\n            limit_value_function_size=limit_value_function_size,\n            gamma=gamma,\n            eps=eps,\n            use_gpu=use_gpu,\n            history_tracking_level=history_tracking_level,\n            overwrite_training=overwrite_training,\n            print_progress=print_progress,\n            print_stats=print_stats,\n            **expand_arguments\n        )\n\n        # Setting parameters of CPU agent after the training\n        self.value_function = gpu_agent.value_function.to_cpu()\n        self.trained_at = gpu_agent.trained_at\n        self.name = gpu_agent.name\n\n        return solver_history\n\n    xp = np if not self.on_gpu else cp\n\n    # Getting model\n    model = self.model\n\n    # Initial belief\n    if initial_belief is None:\n        belief_set = BeliefSet(model, [Belief(model)])\n    elif isinstance(initial_belief, BeliefSet):\n        belief_set = initial_belief.to_gpu() if self.on_gpu else initial_belief\n    else:\n        initial_belief = Belief(model, xp.array(initial_belief.values))\n        belief_set = BeliefSet(model, [initial_belief])\n\n    # Handeling the case where the agent is already trained\n    if (self.value_function is not None):\n        if overwrite_training:\n            print('[warning] The value function is being overwritten')\n            self.trained_at = None\n            self.name = '-'.join(self.name.split('-')[:-1])\n            self.value_function = None\n        else:\n            initial_value_function = self.value_function\n\n    # Initial value function\n    if initial_value_function is None:\n        value_function = ValueFunction(model, model.expected_rewards_table.T, model.actions)\n    else:\n        value_function = initial_value_function.to_gpu() if self.on_gpu else initial_value_function\n\n    # Convergence check boundary\n    max_allowed_change = eps * (gamma / (1-gamma))\n\n    # History tracking\n    training_history = TrainingHistory(tracking_level=history_tracking_level,\n                                       model=model,\n                                       gamma=gamma,\n                                       eps=eps,\n                                       expand_append=full_backup,\n                                       initial_value_function=value_function,\n                                       initial_belief_set=belief_set)\n\n    # Loop\n    iteration = 0\n    expand_value_function = value_function\n    old_value_function = value_function\n\n    try:\n        iterator = trange(expansions, desc='Expansions') if print_progress else range(expansions)\n        iterator_postfix = {}\n        for expansion_i in iterator:\n\n            # 1: Expand belief set\n            start_ts = datetime.now()\n\n            new_belief_set = self.expand(belief_set=belief_set,\n                                         value_function=value_function,\n                                         max_generation=max_belief_growth,\n                                         **expand_arguments)\n\n            # Add new beliefs points to the total belief_set\n            belief_set = belief_set.union(new_belief_set)\n\n            expand_time = (datetime.now() - start_ts).total_seconds()\n            training_history.add_expand_step(expansion_time=expand_time, belief_set=belief_set)\n\n            # 2: Backup, update value function (alpha vector set)\n            for _ in range(update_passes) if (not print_progress or update_passes &lt;= 1) else trange(update_passes, desc=f'Backups {expansion_i}'):\n                start_ts = datetime.now()\n\n                # Backup step\n                value_function = self.backup(belief_set if full_backup else new_belief_set,\n                                             value_function,\n                                             gamma=gamma,\n                                             append=(not full_backup),\n                                             belief_dominance_prune=False)\n                backup_time = (datetime.now() - start_ts).total_seconds()\n\n                # Additional pruning\n                if (iteration % prune_interval) == 0 and iteration &gt; 0:\n                    start_ts = datetime.now()\n                    vf_len = len(value_function)\n\n                    value_function.prune(prune_level)\n\n                    prune_time = (datetime.now() - start_ts).total_seconds()\n                    alpha_vectors_pruned = len(value_function) - vf_len\n                    training_history.add_prune_step(prune_time, alpha_vectors_pruned)\n\n                # Check if value function size is above threshold\n                if limit_value_function_size &gt;= 0 and len(value_function) &gt; limit_value_function_size:\n                    # Compute matrix multiplications between avs and beliefs\n                    alpha_value_per_belief = xp.matmul(value_function.alpha_vector_array, belief_set.belief_array.T)\n\n                    # Select the useful alpha vectors\n                    best_alpha_vector_per_belief = xp.argmax(alpha_value_per_belief, axis=0)\n                    useful_alpha_vectors = xp.unique(best_alpha_vector_per_belief)\n\n                    # Select a random selection of vectors to delete\n                    unuseful_alpha_vectors = xp.delete(xp.arange(len(value_function)), useful_alpha_vectors)\n                    random_vectors_to_delete = self.rnd_state.choice(unuseful_alpha_vectors,\n                                                                     size=max_belief_growth,\n                                                                     p=(xp.arange(len(unuseful_alpha_vectors))[::-1] / xp.sum(xp.arange(len(unuseful_alpha_vectors)))))\n                                                                     # replace=False,\n                                                                     # p=1/len(unuseful_alpha_vectors))\n\n                    value_function = ValueFunction(model=model,\n                                                   alpha_vectors=xp.delete(value_function.alpha_vector_array, random_vectors_to_delete, axis=0),\n                                                   action_list=xp.delete(value_function.actions, random_vectors_to_delete))\n\n                    iterator_postfix['|useful|'] = useful_alpha_vectors.shape[0]\n\n                # Compute the change between value functions\n                max_change = self.compute_change(value_function, old_value_function, belief_set)\n\n                # History tracking\n                training_history.add_backup_step(backup_time, max_change, value_function)\n\n                # Convergence check\n                if max_change &lt; max_allowed_change:\n                    break\n\n                old_value_function = value_function\n\n                # Update iteration counter\n                iteration += 1\n\n            # Compute change with old expansion value function\n            expand_max_change = self.compute_change(expand_value_function, value_function, belief_set)\n\n            if expand_max_change &lt; max_allowed_change:\n                if print_progress:\n                    print('Converged!')\n                break\n\n            expand_value_function = value_function\n\n            iterator_postfix['|V|'] = len(value_function)\n            iterator_postfix['|B|'] = len(belief_set)\n\n            if print_progress:\n                iterator.set_postfix(iterator_postfix)\n\n    except MemoryError as e:\n        print(f'Memory full: {e}')\n        print('Returning value function and history as is...\\n')\n\n    # Final pruning\n    start_ts = datetime.now()\n    vf_len = len(value_function)\n\n    value_function.prune(prune_level)\n\n    # History tracking\n    prune_time = (datetime.now() - start_ts).total_seconds()\n    alpha_vectors_pruned = len(value_function) - vf_len\n    training_history.add_prune_step(prune_time, alpha_vectors_pruned)\n\n    # Record when it was trained\n    self.trained_at = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    self.name += f'-trained_{self.trained_at}'\n\n    # Saving value function\n    self.value_function = value_function\n\n    # Print stats if requested\n    if print_stats:\n        print(training_history.summary)\n\n    return training_history\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_Agent.update_state","title":"<code>update_state(action, observation, source_reached)</code>","text":"<p>Function to update the internal state(s) of the agent(s) based on the previous action(s) taken and the observation(s) received.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>ndarray</code> <p>A 2D array of n movement vectors. If the environment is layered, the 1st component should be the layer.</p> required <code>observation</code> <code>ndarray</code> <p>The observation(s) the agent(s) made.</p> required <code>source_reached</code> <code>ndarray</code> <p>A boolean array of whether the agent(s) have reached the source or not.</p> required <p>Returns:</p> Name Type Description <code>update_successfull</code> <code>(ndarray, optional)</code> <p>If nothing is returned, it means all the agent's state updates have been successfull. Else, a boolean np.ndarray of size n can be returned confirming for each agent whether the update has been successful or not.</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def update_state(self,\n                 action: np.ndarray,\n                 observation: np.ndarray,\n                 source_reached: np.ndarray\n                 ) -&gt; None | np.ndarray:\n    '''\n    Function to update the internal state(s) of the agent(s) based on the previous action(s) taken and the observation(s) received.\n\n    Parameters\n    ----------\n    action : np.ndarray\n        A 2D array of n movement vectors. If the environment is layered, the 1st component should be the layer.\n    observation : np.ndarray\n        The observation(s) the agent(s) made.\n    source_reached : np.ndarray\n        A boolean array of whether the agent(s) have reached the source or not.\n\n    Returns\n    -------\n    update_successfull : np.ndarray, optional\n        If nothing is returned, it means all the agent's state updates have been successfull.\n        Else, a boolean np.ndarray of size n can be returned confirming for each agent whether the update has been successful or not.\n    '''\n    assert self.belief is not None, \"Agent was not initialized yet, run the initialize_state function first\"\n\n    # Discretizing observations\n    observation_ids = self.discretize_observations(observation=observation, action=action, source_reached=source_reached)\n\n    # Update the set of beliefs\n    self.belief = self.belief.update(actions=self.action_played, observations=observation_ids, throw_error=False)\n\n    # Check for failed updates\n    update_successful = (self.belief.belief_array.sum(axis=1) != 0.0)\n\n    return update_successful\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_GER_Agent","title":"<code>PBVI_GER_Agent</code>","text":"<p>               Bases: <code>PBVI_Agent</code></p> <p>A flavor of the PBVI Agent. The expand function consists in choosing belief points that will most decrease the error in the value function (so increasing most the value).</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment to train the agent with.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.</p> <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <code>model</code> <code>Model</code> <p>A POMDP model to use to represent the olfactory environment. If not provided, the environment_converter parameter will be used.</p> <code>None</code> <code>environment_converter</code> <code>Callable</code> <p>A function to convert the olfactory environment instance to a POMDP Model instance. By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model. This parameter will be ignored if the model parameter is provided.</p> <code>exact_converter</code> <code>converter_parameters</code> <code>dict</code> <p>A set of additional parameters to be passed down to the environment converter.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>model</code> <code>Model</code> <p>The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.</p> <code>saved_at</code> <code>str</code> <p>The place on disk where the agent has been saved (None if not saved yet).</p> <code>on_gpu</code> <code>bool</code> <p>Whether the agent has been sent to the gpu or not.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>trained_at</code> <code>str</code> <p>A string timestamp of when the agent has been trained (None if not trained yet).</p> <code>value_function</code> <code>ValueFunction</code> <p>The value function used for the agent to make decisions.</p> <code>belief</code> <code>BeliefSet</code> <p>Used only during simulations. Part of the Agent's status. Where the agent believes he is over the state space. It is a list of n belief points based on how many simulations are running at once.</p> <code>action_played</code> <code>list[int]</code> <p>Used only during simulations. Part of the Agent's status. Records what action was last played by the agent. A list of n actions played based on how many simulations are running at once.</p> Source code in <code>olfactory_navigation/agents/pbvi_ger_agent.py</code> <pre><code>class PBVI_GER_Agent(PBVI_Agent):\n    '''\n    A flavor of the PBVI Agent. The expand function consists in choosing belief points that will most decrease the error in the value function (so increasing most the value).\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment to train the agent with.\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.\n    seed : int, default=12131415\n        For reproducible randomness.\n    model : Model, optional\n        A POMDP model to use to represent the olfactory environment.\n        If not provided, the environment_converter parameter will be used.\n    environment_converter : Callable, default=exact_converter\n        A function to convert the olfactory environment instance to a POMDP Model instance.\n        By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model.\n        This parameter will be ignored if the model parameter is provided.\n    converter_parameters : dict, optional\n        A set of additional parameters to be passed down to the environment converter.\n\n    Attributes\n    ---------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    model : pomdp.Model\n        The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.\n    saved_at : str\n        The place on disk where the agent has been saved (None if not saved yet).\n    on_gpu : bool\n        Whether the agent has been sent to the gpu or not.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    trained_at : str\n        A string timestamp of when the agent has been trained (None if not trained yet).\n    value_function : ValueFunction\n        The value function used for the agent to make decisions.\n    belief : BeliefSet\n        Used only during simulations.\n        Part of the Agent's status. Where the agent believes he is over the state space.\n        It is a list of n belief points based on how many simulations are running at once.\n    action_played : list[int]\n        Used only during simulations.\n        Part of the Agent's status. Records what action was last played by the agent.\n        A list of n actions played based on how many simulations are running at once.\n    '''\n    def expand(self,\n               belief_set: BeliefSet,\n               value_function: ValueFunction,\n               max_generation: int\n               ) -&gt; BeliefSet:\n        '''\n        Greedy Error Reduction.\n        It attempts to choose the believes that will maximize the improvement of the value function by minimizing the error.\n        The error is computed by the sum of the change between two beliefs and their two corresponding alpha vectors.\n\n        Parameters\n        ----------\n        belief_set : BeliefSet\n            List of beliefs to expand on.\n        value_function : ValueFunction\n            The current value function. Used to compute the value at belief points.\n        max_generation : int, default=10\n            The max amount of beliefs that can be added to the belief set at once.\n\n        Returns\n        -------\n        belief_set_new : BeliefSet\n            Union of the belief_set and the expansions of the beliefs in the belief_set.\n        '''\n        # GPU support\n        xp = np if not self.on_gpu else cp\n        model = self.model\n\n        old_shape = belief_set.belief_array.shape\n        to_generate = min(max_generation, old_shape[0])\n\n        new_belief_array = xp.empty((old_shape[0] + to_generate, old_shape[1]))\n        new_belief_array[:old_shape[0]] = belief_set.belief_array\n\n        # Finding the min and max rewards for computation of the epsilon\n        r_min = model._min_reward / (1 - self.gamma)\n        r_max = model._max_reward / (1 - self.gamma)\n\n        # Generation of all potential successor beliefs\n        successor_beliefs = xp.array([[[b.update(a,o).values for o in model.observations] for a in model.actions] for b in belief_set.belief_list])\n\n        # Finding the alphas associated with each previous beliefs\n        best_alpha = xp.argmax(xp.dot(belief_set.belief_array, value_function.alpha_vector_array.T), axis = 1)\n        b_alphas = value_function.alpha_vector_array[best_alpha]\n\n        # Difference between beliefs and their successors\n        b_diffs = successor_beliefs - belief_set.belief_array[:,None,None,:]\n\n        # Computing a 'next' alpha vector made of the max and min\n        alphas_p = xp.where(b_diffs &gt;= 0, r_max, r_min)\n\n        # Difference between alpha vectors and their successors alpha vector\n        alphas_diffs = alphas_p - b_alphas[:,None,None,:]\n\n        # Computing epsilon for all successor beliefs\n        eps = xp.einsum('baos,baos-&gt;bao', alphas_diffs, b_diffs)\n\n        # Computing the probability of the b and doing action a and receiving observation o\n        bao_probs = xp.einsum('bs,saor-&gt;bao', belief_set.belief_array, model.reachable_transitional_observation_table)\n\n        # Taking the sumproduct of the probs with the epsilons\n        res = xp.einsum('bao,bao-&gt;ba', bao_probs, eps)\n\n        # Picking the correct amount of initial beliefs and ideal actions\n        b_stars, a_stars = xp.unravel_index(xp.argsort(res, axis=None)[::-1][:to_generate], res.shape)\n\n        # And picking the ideal observations\n        o_star = xp.argmax(bao_probs[b_stars[:,None], a_stars[:,None], model.observations[None,:]] * eps[b_stars[:,None], a_stars[:,None], model.observations[None,:]], axis=1)\n\n        # Selecting the successor beliefs\n        new_belief_array = successor_beliefs[b_stars[:,None], a_stars[:,None], o_star[:,None], model.states[None,:]]\n\n        return BeliefSet(model, new_belief_array)\n\n\n    def train(self,\n              expansions: int,\n              update_passes: int = 1,\n              max_belief_growth: int = 10,\n              initial_belief: BeliefSet | Belief | None = None,\n              initial_value_function: ValueFunction | None = None,\n              prune_level: int = 1,\n              prune_interval: int = 10,\n              limit_value_function_size: int = -1,\n              gamma: float = 0.99,\n              eps: float = 1e-6,\n              use_gpu: bool = False,\n              history_tracking_level: int = 1,\n              overwrite_training: bool = False,\n              print_progress: bool = True,\n              print_stats: bool = True\n              ) -&gt; TrainingHistory:\n        '''\n        Main loop of the Point-Based Value Iteration algorithm.\n        It consists in 2 steps, Backup and Expand.\n        1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n        2. Backup: Updates the alpha vectors based on the current belief set\n\n        Greedy Error Reduction Point-Based Value Iteration:\n        - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)\n\n        Parameters\n        ----------\n        expansions : int\n            How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n        update_passes : int, default=1\n            How many times the backup function has to be run every time the belief set is expanded.\n        max_belief_growth : int, default=10\n            How many beliefs can be added at every expansion step to the belief set.\n        initial_belief : BeliefSet or Belief, optional\n            An initial list of beliefs to start with.\n        initial_value_function : ValueFunction, optional\n            An initial value function to start the solving process with.\n        prune_level : int, default=1\n            Parameter to prune the value function further before the expand function.\n        prune_interval : int, default=10\n            How often to prune the value function. It is counted in number of backup iterations.\n        limit_value_function_size : int, default=-1\n            When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n            If set to -1, the value function can grow without bounds.\n        use_gpu : bool, default=False\n            Whether to use the GPU with cupy array to accelerate solving.\n        gamma : float, default=0.99\n            The discount factor to value immediate rewards more than long term rewards.\n            The learning rate is 1/gamma.\n        eps : float, default=1e-6\n            The smallest allowed changed for the value function.\n            Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n        history_tracking_level : int, default=1\n            How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n        overwrite_training : bool, default=False\n            Whether to force the overwriting of the training if a value function already exists for this agent.\n        print_progress : bool, default=True\n            Whether or not to print out the progress of the value iteration process.\n        print_stats : bool, default=True\n            Whether or not to print out statistics at the end of the training run.\n\n        Returns\n        -------\n        solver_history : SolverHistory\n            The history of the solving process with some plotting options.\n        '''\n        return super().train(expansions = expansions,\n                             full_backup = True,\n                             update_passes = update_passes,\n                             max_belief_growth = max_belief_growth,\n                             initial_belief = initial_belief,\n                             initial_value_function = initial_value_function,\n                             prune_level = prune_level,\n                             prune_interval = prune_interval,\n                             limit_value_function_size = limit_value_function_size,\n                             gamma = gamma,\n                             eps = eps,\n                             use_gpu = use_gpu,\n                             history_tracking_level = history_tracking_level,\n                             overwrite_training = overwrite_training,\n                             print_progress = print_progress,\n                             print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_GER_Agent.expand","title":"<code>expand(belief_set, value_function, max_generation)</code>","text":"<p>Greedy Error Reduction. It attempts to choose the believes that will maximize the improvement of the value function by minimizing the error. The error is computed by the sum of the change between two beliefs and their two corresponding alpha vectors.</p> <p>Parameters:</p> Name Type Description Default <code>belief_set</code> <code>BeliefSet</code> <p>List of beliefs to expand on.</p> required <code>value_function</code> <code>ValueFunction</code> <p>The current value function. Used to compute the value at belief points.</p> required <code>max_generation</code> <code>int</code> <p>The max amount of beliefs that can be added to the belief set at once.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>belief_set_new</code> <code>BeliefSet</code> <p>Union of the belief_set and the expansions of the beliefs in the belief_set.</p> Source code in <code>olfactory_navigation/agents/pbvi_ger_agent.py</code> <pre><code>def expand(self,\n           belief_set: BeliefSet,\n           value_function: ValueFunction,\n           max_generation: int\n           ) -&gt; BeliefSet:\n    '''\n    Greedy Error Reduction.\n    It attempts to choose the believes that will maximize the improvement of the value function by minimizing the error.\n    The error is computed by the sum of the change between two beliefs and their two corresponding alpha vectors.\n\n    Parameters\n    ----------\n    belief_set : BeliefSet\n        List of beliefs to expand on.\n    value_function : ValueFunction\n        The current value function. Used to compute the value at belief points.\n    max_generation : int, default=10\n        The max amount of beliefs that can be added to the belief set at once.\n\n    Returns\n    -------\n    belief_set_new : BeliefSet\n        Union of the belief_set and the expansions of the beliefs in the belief_set.\n    '''\n    # GPU support\n    xp = np if not self.on_gpu else cp\n    model = self.model\n\n    old_shape = belief_set.belief_array.shape\n    to_generate = min(max_generation, old_shape[0])\n\n    new_belief_array = xp.empty((old_shape[0] + to_generate, old_shape[1]))\n    new_belief_array[:old_shape[0]] = belief_set.belief_array\n\n    # Finding the min and max rewards for computation of the epsilon\n    r_min = model._min_reward / (1 - self.gamma)\n    r_max = model._max_reward / (1 - self.gamma)\n\n    # Generation of all potential successor beliefs\n    successor_beliefs = xp.array([[[b.update(a,o).values for o in model.observations] for a in model.actions] for b in belief_set.belief_list])\n\n    # Finding the alphas associated with each previous beliefs\n    best_alpha = xp.argmax(xp.dot(belief_set.belief_array, value_function.alpha_vector_array.T), axis = 1)\n    b_alphas = value_function.alpha_vector_array[best_alpha]\n\n    # Difference between beliefs and their successors\n    b_diffs = successor_beliefs - belief_set.belief_array[:,None,None,:]\n\n    # Computing a 'next' alpha vector made of the max and min\n    alphas_p = xp.where(b_diffs &gt;= 0, r_max, r_min)\n\n    # Difference between alpha vectors and their successors alpha vector\n    alphas_diffs = alphas_p - b_alphas[:,None,None,:]\n\n    # Computing epsilon for all successor beliefs\n    eps = xp.einsum('baos,baos-&gt;bao', alphas_diffs, b_diffs)\n\n    # Computing the probability of the b and doing action a and receiving observation o\n    bao_probs = xp.einsum('bs,saor-&gt;bao', belief_set.belief_array, model.reachable_transitional_observation_table)\n\n    # Taking the sumproduct of the probs with the epsilons\n    res = xp.einsum('bao,bao-&gt;ba', bao_probs, eps)\n\n    # Picking the correct amount of initial beliefs and ideal actions\n    b_stars, a_stars = xp.unravel_index(xp.argsort(res, axis=None)[::-1][:to_generate], res.shape)\n\n    # And picking the ideal observations\n    o_star = xp.argmax(bao_probs[b_stars[:,None], a_stars[:,None], model.observations[None,:]] * eps[b_stars[:,None], a_stars[:,None], model.observations[None,:]], axis=1)\n\n    # Selecting the successor beliefs\n    new_belief_array = successor_beliefs[b_stars[:,None], a_stars[:,None], o_star[:,None], model.states[None,:]]\n\n    return BeliefSet(model, new_belief_array)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_GER_Agent.train","title":"<code>train(expansions, update_passes=1, max_belief_growth=10, initial_belief=None, initial_value_function=None, prune_level=1, prune_interval=10, limit_value_function_size=-1, gamma=0.99, eps=1e-06, use_gpu=False, history_tracking_level=1, overwrite_training=False, print_progress=True, print_stats=True)</code>","text":"<p>Main loop of the Point-Based Value Iteration algorithm. It consists in 2 steps, Backup and Expand. 1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function 2. Backup: Updates the alpha vectors based on the current belief set</p> <p>Greedy Error Reduction Point-Based Value Iteration: - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)</p> <p>Parameters:</p> Name Type Description Default <code>expansions</code> <code>int</code> <p>How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)</p> required <code>update_passes</code> <code>int</code> <p>How many times the backup function has to be run every time the belief set is expanded.</p> <code>1</code> <code>max_belief_growth</code> <code>int</code> <p>How many beliefs can be added at every expansion step to the belief set.</p> <code>10</code> <code>initial_belief</code> <code>BeliefSet or Belief</code> <p>An initial list of beliefs to start with.</p> <code>None</code> <code>initial_value_function</code> <code>ValueFunction</code> <p>An initial value function to start the solving process with.</p> <code>None</code> <code>prune_level</code> <code>int</code> <p>Parameter to prune the value function further before the expand function.</p> <code>1</code> <code>prune_interval</code> <code>int</code> <p>How often to prune the value function. It is counted in number of backup iterations.</p> <code>10</code> <code>limit_value_function_size</code> <code>int</code> <p>When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function If set to -1, the value function can grow without bounds.</p> <code>-1</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU with cupy array to accelerate solving.</p> <code>False</code> <code>gamma</code> <code>float</code> <p>The discount factor to value immediate rewards more than long term rewards. The learning rate is 1/gamma.</p> <code>0.99</code> <code>eps</code> <code>float</code> <p>The smallest allowed changed for the value function. Bellow the amound of change, the value function is considered converged and the value iteration process will end early.</p> <code>1e-6</code> <code>history_tracking_level</code> <code>int</code> <p>How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)</p> <code>1</code> <code>overwrite_training</code> <code>bool</code> <p>Whether to force the overwriting of the training if a value function already exists for this agent.</p> <code>False</code> <code>print_progress</code> <code>bool</code> <p>Whether or not to print out the progress of the value iteration process.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether or not to print out statistics at the end of the training run.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>solver_history</code> <code>SolverHistory</code> <p>The history of the solving process with some plotting options.</p> Source code in <code>olfactory_navigation/agents/pbvi_ger_agent.py</code> <pre><code>def train(self,\n          expansions: int,\n          update_passes: int = 1,\n          max_belief_growth: int = 10,\n          initial_belief: BeliefSet | Belief | None = None,\n          initial_value_function: ValueFunction | None = None,\n          prune_level: int = 1,\n          prune_interval: int = 10,\n          limit_value_function_size: int = -1,\n          gamma: float = 0.99,\n          eps: float = 1e-6,\n          use_gpu: bool = False,\n          history_tracking_level: int = 1,\n          overwrite_training: bool = False,\n          print_progress: bool = True,\n          print_stats: bool = True\n          ) -&gt; TrainingHistory:\n    '''\n    Main loop of the Point-Based Value Iteration algorithm.\n    It consists in 2 steps, Backup and Expand.\n    1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n    2. Backup: Updates the alpha vectors based on the current belief set\n\n    Greedy Error Reduction Point-Based Value Iteration:\n    - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)\n\n    Parameters\n    ----------\n    expansions : int\n        How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n    update_passes : int, default=1\n        How many times the backup function has to be run every time the belief set is expanded.\n    max_belief_growth : int, default=10\n        How many beliefs can be added at every expansion step to the belief set.\n    initial_belief : BeliefSet or Belief, optional\n        An initial list of beliefs to start with.\n    initial_value_function : ValueFunction, optional\n        An initial value function to start the solving process with.\n    prune_level : int, default=1\n        Parameter to prune the value function further before the expand function.\n    prune_interval : int, default=10\n        How often to prune the value function. It is counted in number of backup iterations.\n    limit_value_function_size : int, default=-1\n        When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n        If set to -1, the value function can grow without bounds.\n    use_gpu : bool, default=False\n        Whether to use the GPU with cupy array to accelerate solving.\n    gamma : float, default=0.99\n        The discount factor to value immediate rewards more than long term rewards.\n        The learning rate is 1/gamma.\n    eps : float, default=1e-6\n        The smallest allowed changed for the value function.\n        Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n    history_tracking_level : int, default=1\n        How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n    overwrite_training : bool, default=False\n        Whether to force the overwriting of the training if a value function already exists for this agent.\n    print_progress : bool, default=True\n        Whether or not to print out the progress of the value iteration process.\n    print_stats : bool, default=True\n        Whether or not to print out statistics at the end of the training run.\n\n    Returns\n    -------\n    solver_history : SolverHistory\n        The history of the solving process with some plotting options.\n    '''\n    return super().train(expansions = expansions,\n                         full_backup = True,\n                         update_passes = update_passes,\n                         max_belief_growth = max_belief_growth,\n                         initial_belief = initial_belief,\n                         initial_value_function = initial_value_function,\n                         prune_level = prune_level,\n                         prune_interval = prune_interval,\n                         limit_value_function_size = limit_value_function_size,\n                         gamma = gamma,\n                         eps = eps,\n                         use_gpu = use_gpu,\n                         history_tracking_level = history_tracking_level,\n                         overwrite_training = overwrite_training,\n                         print_progress = print_progress,\n                         print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_RA_Agent","title":"<code>PBVI_RA_Agent</code>","text":"<p>               Bases: <code>PBVI_Agent</code></p> <p>A flavor of the PBVI Agent. The expand function consists in choosing random belief points.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment to train the agent with.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.</p> <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <code>model</code> <code>Model</code> <p>A POMDP model to use to represent the olfactory environment. If not provided, the environment_converter parameter will be used.</p> <code>None</code> <code>environment_converter</code> <code>Callable</code> <p>A function to convert the olfactory environment instance to a POMDP Model instance. By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model. This parameter will be ignored if the model parameter is provided.</p> <code>exact_converter</code> <code>converter_parameters</code> <code>dict</code> <p>A set of additional parameters to be passed down to the environment converter.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>model</code> <code>Model</code> <p>The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.</p> <code>saved_at</code> <code>str</code> <p>The place on disk where the agent has been saved (None if not saved yet).</p> <code>on_gpu</code> <code>bool</code> <p>Whether the agent has been sent to the gpu or not.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>trained_at</code> <code>str</code> <p>A string timestamp of when the agent has been trained (None if not trained yet).</p> <code>value_function</code> <code>ValueFunction</code> <p>The value function used for the agent to make decisions.</p> <code>belief</code> <code>BeliefSet</code> <p>Used only during simulations. Part of the Agent's status. Where the agent believes he is over the state space. It is a list of n belief points based on how many simulations are running at once.</p> <code>action_played</code> <code>list[int]</code> <p>Used only during simulations. Part of the Agent's status. Records what action was last played by the agent. A list of n actions played based on how many simulations are running at once.</p> Source code in <code>olfactory_navigation/agents/pbvi_ra_agent.py</code> <pre><code>class PBVI_RA_Agent(PBVI_Agent):\n    '''\n    A flavor of the PBVI Agent. The expand function consists in choosing random belief points.\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment to train the agent with.\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.\n    seed : int, default=12131415\n        For reproducible randomness.\n    model : Model, optional\n        A POMDP model to use to represent the olfactory environment.\n        If not provided, the environment_converter parameter will be used.\n    environment_converter : Callable, default=exact_converter\n        A function to convert the olfactory environment instance to a POMDP Model instance.\n        By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model.\n        This parameter will be ignored if the model parameter is provided.\n    converter_parameters : dict, optional\n        A set of additional parameters to be passed down to the environment converter.\n\n    Attributes\n    ---------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    model : pomdp.Model\n        The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.\n    saved_at : str\n        The place on disk where the agent has been saved (None if not saved yet).\n    on_gpu : bool\n        Whether the agent has been sent to the gpu or not.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    trained_at : str\n        A string timestamp of when the agent has been trained (None if not trained yet).\n    value_function : ValueFunction\n        The value function used for the agent to make decisions.\n    belief : BeliefSet\n        Used only during simulations.\n        Part of the Agent's status. Where the agent believes he is over the state space.\n        It is a list of n belief points based on how many simulations are running at once.\n    action_played : list[int]\n        Used only during simulations.\n        Part of the Agent's status. Records what action was last played by the agent.\n        A list of n actions played based on how many simulations are running at once.\n    '''\n    def expand(self,\n               belief_set: BeliefSet,\n               value_function: ValueFunction,\n               max_generation: int\n               ) -&gt; BeliefSet:\n        '''\n        This expansion technique relies only randomness and will generate at most 'max_generation' beliefs.\n\n        Parameters\n        ----------\n        belief_set : BeliefSet\n            List of beliefs to expand on.\n        value_function : ValueFunction\n            The current value function. (NOT USED)\n        max_generation : int, default=10\n            The max amount of beliefs that can be added to the belief set at once.\n\n        Returns\n        -------\n        new_belief_set : BeliefSet\n            Union of the belief_set and the expansions of the beliefs in the belief_set.\n        '''\n        # GPU support\n        xp = np if not self.on_gpu else cp\n        model = self.model\n\n        # How many new beliefs to add\n        generation_count = min(belief_set.belief_array.shape[0], max_generation)\n\n        # Generation of the new beliefs at random\n        new_beliefs = self.rnd_state.random((generation_count, model.state_count))\n        new_beliefs /= xp.sum(new_beliefs, axis=1)[:,None]\n\n        return BeliefSet(model, new_beliefs)\n\n\n    def train(self,\n              expansions: int,\n              update_passes: int = 1,\n              max_belief_growth: int = 10,\n              initial_belief: BeliefSet | Belief | None = None,\n              initial_value_function: ValueFunction | None = None,\n              prune_level: int = 1,\n              prune_interval: int = 10,\n              limit_value_function_size: int = -1,\n              gamma: float = 0.99,\n              eps: float = 1e-6,\n              use_gpu: bool = False,\n              history_tracking_level: int = 1,\n              overwrite_training: bool = False,\n              print_progress: bool = True,\n              print_stats: bool = True\n              ) -&gt; TrainingHistory:\n        '''\n        Main loop of the Point-Based Value Iteration algorithm.\n        It consists in 2 steps, Backup and Expand.\n        1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n        2. Backup: Updates the alpha vectors based on the current belief set\n\n        Random Point-Based Value Iteration:\n        - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)\n\n        Parameters\n        ----------\n        expansions : int\n            How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n        update_passes : int, default=1\n            How many times the backup function has to be run every time the belief set is expanded.\n        max_belief_growth : int, default=10\n            How many beliefs can be added at every expansion step to the belief set.\n        initial_belief : BeliefSet or Belief, optional\n            An initial list of beliefs to start with.\n        initial_value_function : ValueFunction, optional\n            An initial value function to start the solving process with.\n        prune_level : int, default=1\n            Parameter to prune the value function further before the expand function.\n        prune_interval : int, default=10\n            How often to prune the value function. It is counted in number of backup iterations.\n        limit_value_function_size : int, default=-1\n            When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n            If set to -1, the value function can grow without bounds.\n        use_gpu : bool, default=False\n            Whether to use the GPU with cupy array to accelerate solving.\n        gamma : float, default=0.99\n            The discount factor to value immediate rewards more than long term rewards.\n            The learning rate is 1/gamma.\n        eps : float, default=1e-6\n            The smallest allowed changed for the value function.\n            Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n        history_tracking_level : int, default=1\n            How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n        overwrite_training : bool, default=False\n            Whether to force the overwriting of the training if a value function already exists for this agent.\n        print_progress : bool, default=True\n            Whether or not to print out the progress of the value iteration process.\n        print_stats : bool, default=True\n            Whether or not to print out statistics at the end of the training run.\n\n        Returns\n        -------\n        solver_history : SolverHistory\n            The history of the solving process with some plotting options.\n        '''\n        return super().train(expansions = expansions,\n                             full_backup = True,\n                             update_passes = update_passes,\n                             max_belief_growth = max_belief_growth,\n                             initial_belief = initial_belief,\n                             initial_value_function = initial_value_function,\n                             prune_level = prune_level,\n                             prune_interval = prune_interval,\n                             limit_value_function_size = limit_value_function_size,\n                             gamma = gamma,\n                             eps = eps,\n                             use_gpu = use_gpu,\n                             history_tracking_level = history_tracking_level,\n                             overwrite_training = overwrite_training,\n                             print_progress = print_progress,\n                             print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_RA_Agent.expand","title":"<code>expand(belief_set, value_function, max_generation)</code>","text":"<p>This expansion technique relies only randomness and will generate at most 'max_generation' beliefs.</p> <p>Parameters:</p> Name Type Description Default <code>belief_set</code> <code>BeliefSet</code> <p>List of beliefs to expand on.</p> required <code>value_function</code> <code>ValueFunction</code> <p>The current value function. (NOT USED)</p> required <code>max_generation</code> <code>int</code> <p>The max amount of beliefs that can be added to the belief set at once.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>new_belief_set</code> <code>BeliefSet</code> <p>Union of the belief_set and the expansions of the beliefs in the belief_set.</p> Source code in <code>olfactory_navigation/agents/pbvi_ra_agent.py</code> <pre><code>def expand(self,\n           belief_set: BeliefSet,\n           value_function: ValueFunction,\n           max_generation: int\n           ) -&gt; BeliefSet:\n    '''\n    This expansion technique relies only randomness and will generate at most 'max_generation' beliefs.\n\n    Parameters\n    ----------\n    belief_set : BeliefSet\n        List of beliefs to expand on.\n    value_function : ValueFunction\n        The current value function. (NOT USED)\n    max_generation : int, default=10\n        The max amount of beliefs that can be added to the belief set at once.\n\n    Returns\n    -------\n    new_belief_set : BeliefSet\n        Union of the belief_set and the expansions of the beliefs in the belief_set.\n    '''\n    # GPU support\n    xp = np if not self.on_gpu else cp\n    model = self.model\n\n    # How many new beliefs to add\n    generation_count = min(belief_set.belief_array.shape[0], max_generation)\n\n    # Generation of the new beliefs at random\n    new_beliefs = self.rnd_state.random((generation_count, model.state_count))\n    new_beliefs /= xp.sum(new_beliefs, axis=1)[:,None]\n\n    return BeliefSet(model, new_beliefs)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_RA_Agent.train","title":"<code>train(expansions, update_passes=1, max_belief_growth=10, initial_belief=None, initial_value_function=None, prune_level=1, prune_interval=10, limit_value_function_size=-1, gamma=0.99, eps=1e-06, use_gpu=False, history_tracking_level=1, overwrite_training=False, print_progress=True, print_stats=True)</code>","text":"<p>Main loop of the Point-Based Value Iteration algorithm. It consists in 2 steps, Backup and Expand. 1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function 2. Backup: Updates the alpha vectors based on the current belief set</p> <p>Random Point-Based Value Iteration: - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)</p> <p>Parameters:</p> Name Type Description Default <code>expansions</code> <code>int</code> <p>How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)</p> required <code>update_passes</code> <code>int</code> <p>How many times the backup function has to be run every time the belief set is expanded.</p> <code>1</code> <code>max_belief_growth</code> <code>int</code> <p>How many beliefs can be added at every expansion step to the belief set.</p> <code>10</code> <code>initial_belief</code> <code>BeliefSet or Belief</code> <p>An initial list of beliefs to start with.</p> <code>None</code> <code>initial_value_function</code> <code>ValueFunction</code> <p>An initial value function to start the solving process with.</p> <code>None</code> <code>prune_level</code> <code>int</code> <p>Parameter to prune the value function further before the expand function.</p> <code>1</code> <code>prune_interval</code> <code>int</code> <p>How often to prune the value function. It is counted in number of backup iterations.</p> <code>10</code> <code>limit_value_function_size</code> <code>int</code> <p>When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function If set to -1, the value function can grow without bounds.</p> <code>-1</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU with cupy array to accelerate solving.</p> <code>False</code> <code>gamma</code> <code>float</code> <p>The discount factor to value immediate rewards more than long term rewards. The learning rate is 1/gamma.</p> <code>0.99</code> <code>eps</code> <code>float</code> <p>The smallest allowed changed for the value function. Bellow the amound of change, the value function is considered converged and the value iteration process will end early.</p> <code>1e-6</code> <code>history_tracking_level</code> <code>int</code> <p>How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)</p> <code>1</code> <code>overwrite_training</code> <code>bool</code> <p>Whether to force the overwriting of the training if a value function already exists for this agent.</p> <code>False</code> <code>print_progress</code> <code>bool</code> <p>Whether or not to print out the progress of the value iteration process.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether or not to print out statistics at the end of the training run.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>solver_history</code> <code>SolverHistory</code> <p>The history of the solving process with some plotting options.</p> Source code in <code>olfactory_navigation/agents/pbvi_ra_agent.py</code> <pre><code>def train(self,\n          expansions: int,\n          update_passes: int = 1,\n          max_belief_growth: int = 10,\n          initial_belief: BeliefSet | Belief | None = None,\n          initial_value_function: ValueFunction | None = None,\n          prune_level: int = 1,\n          prune_interval: int = 10,\n          limit_value_function_size: int = -1,\n          gamma: float = 0.99,\n          eps: float = 1e-6,\n          use_gpu: bool = False,\n          history_tracking_level: int = 1,\n          overwrite_training: bool = False,\n          print_progress: bool = True,\n          print_stats: bool = True\n          ) -&gt; TrainingHistory:\n    '''\n    Main loop of the Point-Based Value Iteration algorithm.\n    It consists in 2 steps, Backup and Expand.\n    1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n    2. Backup: Updates the alpha vectors based on the current belief set\n\n    Random Point-Based Value Iteration:\n    - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)\n\n    Parameters\n    ----------\n    expansions : int\n        How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n    update_passes : int, default=1\n        How many times the backup function has to be run every time the belief set is expanded.\n    max_belief_growth : int, default=10\n        How many beliefs can be added at every expansion step to the belief set.\n    initial_belief : BeliefSet or Belief, optional\n        An initial list of beliefs to start with.\n    initial_value_function : ValueFunction, optional\n        An initial value function to start the solving process with.\n    prune_level : int, default=1\n        Parameter to prune the value function further before the expand function.\n    prune_interval : int, default=10\n        How often to prune the value function. It is counted in number of backup iterations.\n    limit_value_function_size : int, default=-1\n        When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n        If set to -1, the value function can grow without bounds.\n    use_gpu : bool, default=False\n        Whether to use the GPU with cupy array to accelerate solving.\n    gamma : float, default=0.99\n        The discount factor to value immediate rewards more than long term rewards.\n        The learning rate is 1/gamma.\n    eps : float, default=1e-6\n        The smallest allowed changed for the value function.\n        Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n    history_tracking_level : int, default=1\n        How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n    overwrite_training : bool, default=False\n        Whether to force the overwriting of the training if a value function already exists for this agent.\n    print_progress : bool, default=True\n        Whether or not to print out the progress of the value iteration process.\n    print_stats : bool, default=True\n        Whether or not to print out statistics at the end of the training run.\n\n    Returns\n    -------\n    solver_history : SolverHistory\n        The history of the solving process with some plotting options.\n    '''\n    return super().train(expansions = expansions,\n                         full_backup = True,\n                         update_passes = update_passes,\n                         max_belief_growth = max_belief_growth,\n                         initial_belief = initial_belief,\n                         initial_value_function = initial_value_function,\n                         prune_level = prune_level,\n                         prune_interval = prune_interval,\n                         limit_value_function_size = limit_value_function_size,\n                         gamma = gamma,\n                         eps = eps,\n                         use_gpu = use_gpu,\n                         history_tracking_level = history_tracking_level,\n                         overwrite_training = overwrite_training,\n                         print_progress = print_progress,\n                         print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_SSEA_Agent","title":"<code>PBVI_SSEA_Agent</code>","text":"<p>               Bases: <code>PBVI_Agent</code></p> <p>A flavor of the PBVI Agent. The expand function consists in choosing belief points furtest away (L2 distance) from any other belief point already in the belief set based on that.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment to train the agent with.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.</p> <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <code>model</code> <code>Model</code> <p>A POMDP model to use to represent the olfactory environment. If not provided, the environment_converter parameter will be used.</p> <code>None</code> <code>environment_converter</code> <code>Callable</code> <p>A function to convert the olfactory environment instance to a POMDP Model instance. By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model. This parameter will be ignored if the model parameter is provided.</p> <code>exact_converter</code> <code>converter_parameters</code> <code>dict</code> <p>A set of additional parameters to be passed down to the environment converter.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>model</code> <code>Model</code> <p>The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.</p> <code>saved_at</code> <code>str</code> <p>The place on disk where the agent has been saved (None if not saved yet).</p> <code>on_gpu</code> <code>bool</code> <p>Whether the agent has been sent to the gpu or not.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>trained_at</code> <code>str</code> <p>A string timestamp of when the agent has been trained (None if not trained yet).</p> <code>value_function</code> <code>ValueFunction</code> <p>The value function used for the agent to make decisions.</p> <code>belief</code> <code>BeliefSet</code> <p>Used only during simulations. Part of the Agent's status. Where the agent believes he is over the state space. It is a list of n belief points based on how many simulations are running at once.</p> <code>action_played</code> <code>list[int]</code> <p>Used only during simulations. Part of the Agent's status. Records what action was last played by the agent. A list of n actions played based on how many simulations are running at once.</p> Source code in <code>olfactory_navigation/agents/pbvi_ssea_agent.py</code> <pre><code>class PBVI_SSEA_Agent(PBVI_Agent):\n    '''\n    A flavor of the PBVI Agent. The expand function consists in choosing belief points furtest away (L2 distance) from any other belief point already in the belief set based on that.\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment to train the agent with.\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.\n    seed : int, default=12131415\n        For reproducible randomness.\n    model : Model, optional\n        A POMDP model to use to represent the olfactory environment.\n        If not provided, the environment_converter parameter will be used.\n    environment_converter : Callable, default=exact_converter\n        A function to convert the olfactory environment instance to a POMDP Model instance.\n        By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model.\n        This parameter will be ignored if the model parameter is provided.\n    converter_parameters : dict, optional\n        A set of additional parameters to be passed down to the environment converter.\n\n    Attributes\n    ---------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    model : pomdp.Model\n        The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.\n    saved_at : str\n        The place on disk where the agent has been saved (None if not saved yet).\n    on_gpu : bool\n        Whether the agent has been sent to the gpu or not.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    trained_at : str\n        A string timestamp of when the agent has been trained (None if not trained yet).\n    value_function : ValueFunction\n        The value function used for the agent to make decisions.\n    belief : BeliefSet\n        Used only during simulations.\n        Part of the Agent's status. Where the agent believes he is over the state space.\n        It is a list of n belief points based on how many simulations are running at once.\n    action_played : list[int]\n        Used only during simulations.\n        Part of the Agent's status. Records what action was last played by the agent.\n        A list of n actions played based on how many simulations are running at once.\n    '''\n    def expand(self,\n               belief_set: BeliefSet,\n               value_function: ValueFunction,\n               max_generation: int\n               ) -&gt; BeliefSet:\n        '''\n        Stochastic Simulation with Exploratory Action.\n        Simulates running steps forward for each possible action knowing we are a state s, chosen randomly with according to the belief probability.\n        These lead to a new state s_p and a observation o for each action.\n        From all these and observation o we can generate updated beliefs.\n        Then it takes the belief that is furthest away from other beliefs, meaning it explores the most the belief space.\n\n        Parameters\n        ----------\n        belief_set : BeliefSet\n            List of beliefs to expand on.\n        value_function : ValueFunction\n            The current value function. (NOT USED)\n        max_generation : int, default=10\n            The max amount of beliefs that can be added to the belief set at once.\n\n        Returns\n        -------\n        belief_set_new : BeliefSet\n            Union of the belief_set and the expansions of the beliefs in the belief_set.\n        '''\n        # GPU support\n        xp = np if not self.on_gpu else cp\n        model = self.model\n\n        old_shape = belief_set.belief_array.shape\n        to_generate = min(max_generation, old_shape[0])\n\n        # Generation of successors\n        successor_beliefs = xp.array([[[b.update(a,o).values for o in model.observations] for a in model.actions] for b in belief_set.belief_list])\n\n        # Compute the distances between each pair and of successor are source beliefs\n        diff = (belief_set.belief_array[:, None,None,None, :] - successor_beliefs)\n        dist = xp.sqrt(xp.einsum('bnaos,bnaos-&gt;bnao', diff, diff))\n\n        # Taking the min distance for each belief\n        belief_min_dists = xp.min(dist,axis=0)\n\n        # Taking the max distanced successors\n        b_star, a_star, o_star = xp.unravel_index(xp.argsort(belief_min_dists, axis=None)[::-1][:to_generate], successor_beliefs.shape[:-1])\n\n        # Selecting successor beliefs\n        new_belief_array = successor_beliefs[b_star[:,None], a_star[:,None], o_star[:,None], model.states[None,:]]\n\n        return BeliefSet(model, new_belief_array)\n\n\n    def train(self,\n              expansions: int,\n              update_passes: int = 1,\n              max_belief_growth: int = 10,\n              initial_belief: BeliefSet | Belief | None = None,\n              initial_value_function: ValueFunction | None = None,\n              prune_level: int = 1,\n              prune_interval: int = 10,\n              limit_value_function_size: int = -1,\n              gamma: float = 0.99,\n              eps: float = 1e-6,\n              use_gpu: bool = False,\n              history_tracking_level: int = 1,\n              overwrite_training: bool = False,\n              print_progress: bool = True,\n              print_stats: bool = True\n              ) -&gt; TrainingHistory:\n        '''\n        Main loop of the Point-Based Value Iteration algorithm.\n        It consists in 2 steps, Backup and Expand.\n        1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n        2. Backup: Updates the alpha vectors based on the current belief set\n\n        Stochastic Search with Exploratory Action Point-Based Value Iteration:\n        - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)\n\n        Parameters\n        ----------\n        expansions : int\n            How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n        update_passes : int, default=1\n            How many times the backup function has to be run every time the belief set is expanded.\n        max_belief_growth : int, default=10\n            How many beliefs can be added at every expansion step to the belief set.\n        initial_belief : BeliefSet or Belief, optional\n            An initial list of beliefs to start with.\n        initial_value_function : ValueFunction, optional\n            An initial value function to start the solving process with.\n        prune_level : int, default=1\n            Parameter to prune the value function further before the expand function.\n        prune_interval : int, default=10\n            How often to prune the value function. It is counted in number of backup iterations.\n        limit_value_function_size : int, default=-1\n            When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n            If set to -1, the value function can grow without bounds.\n        use_gpu : bool, default=False\n            Whether to use the GPU with cupy array to accelerate solving.\n        gamma : float, default=0.99\n            The discount factor to value immediate rewards more than long term rewards.\n            The learning rate is 1/gamma.\n        eps : float, default=1e-6\n            The smallest allowed changed for the value function.\n            Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n        history_tracking_level : int, default=1\n            How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n        overwrite_training : bool, default=False\n            Whether to force the overwriting of the training if a value function already exists for this agent.\n        print_progress : bool, default=True\n            Whether or not to print out the progress of the value iteration process.\n        print_stats : bool, default=True\n            Whether or not to print out statistics at the end of the training run.\n\n        Returns\n        -------\n        solver_history : SolverHistory\n            The history of the solving process with some plotting options.\n        '''\n        return super().train(expansions = expansions,\n                             full_backup = True,\n                             update_passes = update_passes,\n                             max_belief_growth = max_belief_growth,\n                             initial_belief = initial_belief,\n                             initial_value_function = initial_value_function,\n                             prune_level = prune_level,\n                             prune_interval = prune_interval,\n                             limit_value_function_size = limit_value_function_size,\n                             gamma = gamma,\n                             eps = eps,\n                             use_gpu = use_gpu,\n                             history_tracking_level = history_tracking_level,\n                             overwrite_training = overwrite_training,\n                             print_progress = print_progress,\n                             print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_SSEA_Agent.expand","title":"<code>expand(belief_set, value_function, max_generation)</code>","text":"<p>Stochastic Simulation with Exploratory Action. Simulates running steps forward for each possible action knowing we are a state s, chosen randomly with according to the belief probability. These lead to a new state s_p and a observation o for each action. From all these and observation o we can generate updated beliefs. Then it takes the belief that is furthest away from other beliefs, meaning it explores the most the belief space.</p> <p>Parameters:</p> Name Type Description Default <code>belief_set</code> <code>BeliefSet</code> <p>List of beliefs to expand on.</p> required <code>value_function</code> <code>ValueFunction</code> <p>The current value function. (NOT USED)</p> required <code>max_generation</code> <code>int</code> <p>The max amount of beliefs that can be added to the belief set at once.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>belief_set_new</code> <code>BeliefSet</code> <p>Union of the belief_set and the expansions of the beliefs in the belief_set.</p> Source code in <code>olfactory_navigation/agents/pbvi_ssea_agent.py</code> <pre><code>def expand(self,\n           belief_set: BeliefSet,\n           value_function: ValueFunction,\n           max_generation: int\n           ) -&gt; BeliefSet:\n    '''\n    Stochastic Simulation with Exploratory Action.\n    Simulates running steps forward for each possible action knowing we are a state s, chosen randomly with according to the belief probability.\n    These lead to a new state s_p and a observation o for each action.\n    From all these and observation o we can generate updated beliefs.\n    Then it takes the belief that is furthest away from other beliefs, meaning it explores the most the belief space.\n\n    Parameters\n    ----------\n    belief_set : BeliefSet\n        List of beliefs to expand on.\n    value_function : ValueFunction\n        The current value function. (NOT USED)\n    max_generation : int, default=10\n        The max amount of beliefs that can be added to the belief set at once.\n\n    Returns\n    -------\n    belief_set_new : BeliefSet\n        Union of the belief_set and the expansions of the beliefs in the belief_set.\n    '''\n    # GPU support\n    xp = np if not self.on_gpu else cp\n    model = self.model\n\n    old_shape = belief_set.belief_array.shape\n    to_generate = min(max_generation, old_shape[0])\n\n    # Generation of successors\n    successor_beliefs = xp.array([[[b.update(a,o).values for o in model.observations] for a in model.actions] for b in belief_set.belief_list])\n\n    # Compute the distances between each pair and of successor are source beliefs\n    diff = (belief_set.belief_array[:, None,None,None, :] - successor_beliefs)\n    dist = xp.sqrt(xp.einsum('bnaos,bnaos-&gt;bnao', diff, diff))\n\n    # Taking the min distance for each belief\n    belief_min_dists = xp.min(dist,axis=0)\n\n    # Taking the max distanced successors\n    b_star, a_star, o_star = xp.unravel_index(xp.argsort(belief_min_dists, axis=None)[::-1][:to_generate], successor_beliefs.shape[:-1])\n\n    # Selecting successor beliefs\n    new_belief_array = successor_beliefs[b_star[:,None], a_star[:,None], o_star[:,None], model.states[None,:]]\n\n    return BeliefSet(model, new_belief_array)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_SSEA_Agent.train","title":"<code>train(expansions, update_passes=1, max_belief_growth=10, initial_belief=None, initial_value_function=None, prune_level=1, prune_interval=10, limit_value_function_size=-1, gamma=0.99, eps=1e-06, use_gpu=False, history_tracking_level=1, overwrite_training=False, print_progress=True, print_stats=True)</code>","text":"<p>Main loop of the Point-Based Value Iteration algorithm. It consists in 2 steps, Backup and Expand. 1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function 2. Backup: Updates the alpha vectors based on the current belief set</p> <p>Stochastic Search with Exploratory Action Point-Based Value Iteration: - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)</p> <p>Parameters:</p> Name Type Description Default <code>expansions</code> <code>int</code> <p>How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)</p> required <code>update_passes</code> <code>int</code> <p>How many times the backup function has to be run every time the belief set is expanded.</p> <code>1</code> <code>max_belief_growth</code> <code>int</code> <p>How many beliefs can be added at every expansion step to the belief set.</p> <code>10</code> <code>initial_belief</code> <code>BeliefSet or Belief</code> <p>An initial list of beliefs to start with.</p> <code>None</code> <code>initial_value_function</code> <code>ValueFunction</code> <p>An initial value function to start the solving process with.</p> <code>None</code> <code>prune_level</code> <code>int</code> <p>Parameter to prune the value function further before the expand function.</p> <code>1</code> <code>prune_interval</code> <code>int</code> <p>How often to prune the value function. It is counted in number of backup iterations.</p> <code>10</code> <code>limit_value_function_size</code> <code>int</code> <p>When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function If set to -1, the value function can grow without bounds.</p> <code>-1</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU with cupy array to accelerate solving.</p> <code>False</code> <code>gamma</code> <code>float</code> <p>The discount factor to value immediate rewards more than long term rewards. The learning rate is 1/gamma.</p> <code>0.99</code> <code>eps</code> <code>float</code> <p>The smallest allowed changed for the value function. Bellow the amound of change, the value function is considered converged and the value iteration process will end early.</p> <code>1e-6</code> <code>history_tracking_level</code> <code>int</code> <p>How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)</p> <code>1</code> <code>overwrite_training</code> <code>bool</code> <p>Whether to force the overwriting of the training if a value function already exists for this agent.</p> <code>False</code> <code>print_progress</code> <code>bool</code> <p>Whether or not to print out the progress of the value iteration process.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether or not to print out statistics at the end of the training run.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>solver_history</code> <code>SolverHistory</code> <p>The history of the solving process with some plotting options.</p> Source code in <code>olfactory_navigation/agents/pbvi_ssea_agent.py</code> <pre><code>def train(self,\n          expansions: int,\n          update_passes: int = 1,\n          max_belief_growth: int = 10,\n          initial_belief: BeliefSet | Belief | None = None,\n          initial_value_function: ValueFunction | None = None,\n          prune_level: int = 1,\n          prune_interval: int = 10,\n          limit_value_function_size: int = -1,\n          gamma: float = 0.99,\n          eps: float = 1e-6,\n          use_gpu: bool = False,\n          history_tracking_level: int = 1,\n          overwrite_training: bool = False,\n          print_progress: bool = True,\n          print_stats: bool = True\n          ) -&gt; TrainingHistory:\n    '''\n    Main loop of the Point-Based Value Iteration algorithm.\n    It consists in 2 steps, Backup and Expand.\n    1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n    2. Backup: Updates the alpha vectors based on the current belief set\n\n    Stochastic Search with Exploratory Action Point-Based Value Iteration:\n    - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)\n\n    Parameters\n    ----------\n    expansions : int\n        How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n    update_passes : int, default=1\n        How many times the backup function has to be run every time the belief set is expanded.\n    max_belief_growth : int, default=10\n        How many beliefs can be added at every expansion step to the belief set.\n    initial_belief : BeliefSet or Belief, optional\n        An initial list of beliefs to start with.\n    initial_value_function : ValueFunction, optional\n        An initial value function to start the solving process with.\n    prune_level : int, default=1\n        Parameter to prune the value function further before the expand function.\n    prune_interval : int, default=10\n        How often to prune the value function. It is counted in number of backup iterations.\n    limit_value_function_size : int, default=-1\n        When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n        If set to -1, the value function can grow without bounds.\n    use_gpu : bool, default=False\n        Whether to use the GPU with cupy array to accelerate solving.\n    gamma : float, default=0.99\n        The discount factor to value immediate rewards more than long term rewards.\n        The learning rate is 1/gamma.\n    eps : float, default=1e-6\n        The smallest allowed changed for the value function.\n        Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n    history_tracking_level : int, default=1\n        How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n    overwrite_training : bool, default=False\n        Whether to force the overwriting of the training if a value function already exists for this agent.\n    print_progress : bool, default=True\n        Whether or not to print out the progress of the value iteration process.\n    print_stats : bool, default=True\n        Whether or not to print out statistics at the end of the training run.\n\n    Returns\n    -------\n    solver_history : SolverHistory\n        The history of the solving process with some plotting options.\n    '''\n    return super().train(expansions = expansions,\n                         full_backup = True,\n                         update_passes = update_passes,\n                         max_belief_growth = max_belief_growth,\n                         initial_belief = initial_belief,\n                         initial_value_function = initial_value_function,\n                         prune_level = prune_level,\n                         prune_interval = prune_interval,\n                         limit_value_function_size = limit_value_function_size,\n                         gamma = gamma,\n                         eps = eps,\n                         use_gpu = use_gpu,\n                         history_tracking_level = history_tracking_level,\n                         overwrite_training = overwrite_training,\n                         print_progress = print_progress,\n                         print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_SSGA_Agent","title":"<code>PBVI_SSGA_Agent</code>","text":"<p>               Bases: <code>PBVI_Agent</code></p> <p>A flavor of the PBVI Agent. The expand function consists in choosing actions in an epsilon greedy fashion and generating random observations and generating belief points based on that.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment to train the agent with.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.</p> <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <code>model</code> <code>Model</code> <p>A POMDP model to use to represent the olfactory environment. If not provided, the environment_converter parameter will be used.</p> <code>None</code> <code>environment_converter</code> <code>Callable</code> <p>A function to convert the olfactory environment instance to a POMDP Model instance. By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model. This parameter will be ignored if the model parameter is provided.</p> <code>exact_converter</code> <code>converter_parameters</code> <code>dict</code> <p>A set of additional parameters to be passed down to the environment converter.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>model</code> <code>Model</code> <p>The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.</p> <code>saved_at</code> <code>str</code> <p>The place on disk where the agent has been saved (None if not saved yet).</p> <code>on_gpu</code> <code>bool</code> <p>Whether the agent has been sent to the gpu or not.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>trained_at</code> <code>str</code> <p>A string timestamp of when the agent has been trained (None if not trained yet).</p> <code>value_function</code> <code>ValueFunction</code> <p>The value function used for the agent to make decisions.</p> <code>belief</code> <code>BeliefSet</code> <p>Used only during simulations. Part of the Agent's status. Where the agent believes he is over the state space. It is a list of n belief points based on how many simulations are running at once.</p> <code>action_played</code> <code>list[int]</code> <p>Used only during simulations. Part of the Agent's status. Records what action was last played by the agent. A list of n actions played based on how many simulations are running at once.</p> Source code in <code>olfactory_navigation/agents/pbvi_ssga_agent.py</code> <pre><code>class PBVI_SSGA_Agent(PBVI_Agent):\n    '''\n    A flavor of the PBVI Agent. The expand function consists in choosing actions in an epsilon greedy fashion and generating random observations and generating belief points based on that.\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment to train the agent with.\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.\n    seed : int, default=12131415\n        For reproducible randomness.\n    model : Model, optional\n        A POMDP model to use to represent the olfactory environment.\n        If not provided, the environment_converter parameter will be used.\n    environment_converter : Callable, default=exact_converter\n        A function to convert the olfactory environment instance to a POMDP Model instance.\n        By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model.\n        This parameter will be ignored if the model parameter is provided.\n    converter_parameters : dict, optional\n        A set of additional parameters to be passed down to the environment converter.\n\n    Attributes\n    ---------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    model : pomdp.Model\n        The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.\n    saved_at : str\n        The place on disk where the agent has been saved (None if not saved yet).\n    on_gpu : bool\n        Whether the agent has been sent to the gpu or not.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    trained_at : str\n        A string timestamp of when the agent has been trained (None if not trained yet).\n    value_function : ValueFunction\n        The value function used for the agent to make decisions.\n    belief : BeliefSet\n        Used only during simulations.\n        Part of the Agent's status. Where the agent believes he is over the state space.\n        It is a list of n belief points based on how many simulations are running at once.\n    action_played : list[int]\n        Used only during simulations.\n        Part of the Agent's status. Records what action was last played by the agent.\n        A list of n actions played based on how many simulations are running at once.\n    '''\n    def expand(self,\n               belief_set: BeliefSet,\n               value_function: ValueFunction,\n               max_generation: int,\n               epsilon: float = 0.99\n               ) -&gt; BeliefSet:\n        '''\n        Stochastic Simulation with Greedy Action.\n        Simulates running a single-step forward from the beliefs in the \"belief_set\".\n        The step forward is taking assuming we are in a random state s (weighted by the belief),\n        then taking the best action a based on the belief with probability 'epsilon'.\n        These lead to a new state s_p and a observation o.\n        From this action a and observation o we can update our belief.\n\n        Parameters\n        ----------\n        belief_set : BeliefSet\n            List of beliefs to expand on.\n        value_function : ValueFunction\n            The current value function. (NOT USED)\n        max_generation : int, default=10\n            The max amount of beliefs that can be added to the belief set at once.\n        epsilon : float, default=0.99\n            The epsilon parameter that determines whether to choose an action greedily or randomly.\n\n        Returns\n        -------\n        belief_set_new : BeliefSet\n            Union of the belief_set and the expansions of the beliefs in the belief_set.\n        '''\n        # GPU support\n        xp = np if not self.on_gpu else cp\n        model = self.model\n\n        old_shape = belief_set.belief_array.shape\n        to_generate = min(max_generation, old_shape[0])\n\n        new_belief_array = xp.empty((to_generate, old_shape[1]))\n\n        # Random previous beliefs\n        rand_ind = self.rnd_state.choice(np.arange(old_shape[0]), to_generate, replace=False)\n\n        for i, belief_vector in enumerate(belief_set.belief_array[rand_ind]):\n            b = Belief(model, belief_vector)\n            s = b.random_state()\n\n            if self.rnd_state.random() &lt; epsilon:\n                a = self.rnd_state.choice(model.actions)\n            else:\n                best_alpha_index = xp.argmax(xp.dot(value_function.alpha_vector_array, b.values))\n                a = value_function.actions[best_alpha_index]\n\n            s_p = model.transition(s, a)\n            o = model.observe(s_p, a)\n            b_new = b.update(a, o)\n\n            new_belief_array[i] = b_new.values\n\n        return BeliefSet(model, new_belief_array)\n\n\n    def train(self,\n              expansions: int,\n              update_passes: int = 1,\n              max_belief_growth: int = 10,\n              initial_belief: BeliefSet | Belief | None = None,\n              initial_value_function: ValueFunction | None = None,\n              prune_level: int = 1,\n              prune_interval: int = 10,\n              limit_value_function_size: int = -1,\n              gamma: float = 0.99,\n              eps: float = 1e-6,\n              use_gpu: bool = False,\n              history_tracking_level: int = 1,\n              overwrite_training: bool = False,\n              print_progress: bool = True,\n              print_stats: bool = True,\n              epsilon: float = 0.99\n              ) -&gt; TrainingHistory:\n        '''\n        Main loop of the Point-Based Value Iteration algorithm.\n        It consists in 2 steps, Backup and Expand.\n        1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n        2. Backup: Updates the alpha vectors based on the current belief set\n\n        Stochastic Search with Greedy Action Point-Based Value Iteration:\n        - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)\n\n        Parameters\n        ----------\n        expansions : int\n            How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n        update_passes : int, default=1\n            How many times the backup function has to be run every time the belief set is expanded.\n        max_belief_growth : int, default=10\n            How many beliefs can be added at every expansion step to the belief set.\n        initial_belief : BeliefSet or Belief, optional\n            An initial list of beliefs to start with.\n        initial_value_function : ValueFunction, optional\n            An initial value function to start the solving process with.\n        prune_level : int, default=1\n            Parameter to prune the value function further before the expand function.\n        prune_interval : int, default=10\n            How often to prune the value function. It is counted in number of backup iterations.\n        limit_value_function_size : int, default=-1\n            When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n            If set to -1, the value function can grow without bounds.\n        use_gpu : bool, default=False\n            Whether to use the GPU with cupy array to accelerate solving.\n        gamma : float, default=0.99\n            The discount factor to value immediate rewards more than long term rewards.\n            The learning rate is 1/gamma.\n        eps : float, default=1e-6\n            The smallest allowed changed for the value function.\n            Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n        history_tracking_level : int, default=1\n            How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n        overwrite_training : bool, default=False\n            Whether to force the overwriting of the training if a value function already exists for this agent.\n        print_progress : bool, default=True\n            Whether or not to print out the progress of the value iteration process.\n        print_stats : bool, default=True\n            Whether or not to print out statistics at the end of the training run.\n        epsilon : float, default=0.99\n            Expand function parameter. threshold to how often to choose the action greedily to how often randomly.\n\n        Returns\n        -------\n        solver_history : SolverHistory\n            The history of the solving process with some plotting options.\n        '''\n        return super().train(expansions = expansions,\n                             full_backup = True,\n                             update_passes = update_passes,\n                             max_belief_growth = max_belief_growth,\n                             initial_belief = initial_belief,\n                             initial_value_function = initial_value_function,\n                             prune_level = prune_level,\n                             prune_interval = prune_interval,\n                             limit_value_function_size = limit_value_function_size,\n                             gamma = gamma,\n                             eps = eps,\n                             use_gpu = use_gpu,\n                             history_tracking_level = history_tracking_level,\n                             overwrite_training = overwrite_training,\n                             print_progress = print_progress,\n                             print_stats = print_stats,\n                             epsilon = epsilon)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_SSGA_Agent.expand","title":"<code>expand(belief_set, value_function, max_generation, epsilon=0.99)</code>","text":"<p>Stochastic Simulation with Greedy Action. Simulates running a single-step forward from the beliefs in the \"belief_set\". The step forward is taking assuming we are in a random state s (weighted by the belief), then taking the best action a based on the belief with probability 'epsilon'. These lead to a new state s_p and a observation o. From this action a and observation o we can update our belief.</p> <p>Parameters:</p> Name Type Description Default <code>belief_set</code> <code>BeliefSet</code> <p>List of beliefs to expand on.</p> required <code>value_function</code> <code>ValueFunction</code> <p>The current value function. (NOT USED)</p> required <code>max_generation</code> <code>int</code> <p>The max amount of beliefs that can be added to the belief set at once.</p> <code>10</code> <code>epsilon</code> <code>float</code> <p>The epsilon parameter that determines whether to choose an action greedily or randomly.</p> <code>0.99</code> <p>Returns:</p> Name Type Description <code>belief_set_new</code> <code>BeliefSet</code> <p>Union of the belief_set and the expansions of the beliefs in the belief_set.</p> Source code in <code>olfactory_navigation/agents/pbvi_ssga_agent.py</code> <pre><code>def expand(self,\n           belief_set: BeliefSet,\n           value_function: ValueFunction,\n           max_generation: int,\n           epsilon: float = 0.99\n           ) -&gt; BeliefSet:\n    '''\n    Stochastic Simulation with Greedy Action.\n    Simulates running a single-step forward from the beliefs in the \"belief_set\".\n    The step forward is taking assuming we are in a random state s (weighted by the belief),\n    then taking the best action a based on the belief with probability 'epsilon'.\n    These lead to a new state s_p and a observation o.\n    From this action a and observation o we can update our belief.\n\n    Parameters\n    ----------\n    belief_set : BeliefSet\n        List of beliefs to expand on.\n    value_function : ValueFunction\n        The current value function. (NOT USED)\n    max_generation : int, default=10\n        The max amount of beliefs that can be added to the belief set at once.\n    epsilon : float, default=0.99\n        The epsilon parameter that determines whether to choose an action greedily or randomly.\n\n    Returns\n    -------\n    belief_set_new : BeliefSet\n        Union of the belief_set and the expansions of the beliefs in the belief_set.\n    '''\n    # GPU support\n    xp = np if not self.on_gpu else cp\n    model = self.model\n\n    old_shape = belief_set.belief_array.shape\n    to_generate = min(max_generation, old_shape[0])\n\n    new_belief_array = xp.empty((to_generate, old_shape[1]))\n\n    # Random previous beliefs\n    rand_ind = self.rnd_state.choice(np.arange(old_shape[0]), to_generate, replace=False)\n\n    for i, belief_vector in enumerate(belief_set.belief_array[rand_ind]):\n        b = Belief(model, belief_vector)\n        s = b.random_state()\n\n        if self.rnd_state.random() &lt; epsilon:\n            a = self.rnd_state.choice(model.actions)\n        else:\n            best_alpha_index = xp.argmax(xp.dot(value_function.alpha_vector_array, b.values))\n            a = value_function.actions[best_alpha_index]\n\n        s_p = model.transition(s, a)\n        o = model.observe(s_p, a)\n        b_new = b.update(a, o)\n\n        new_belief_array[i] = b_new.values\n\n    return BeliefSet(model, new_belief_array)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_SSGA_Agent.train","title":"<code>train(expansions, update_passes=1, max_belief_growth=10, initial_belief=None, initial_value_function=None, prune_level=1, prune_interval=10, limit_value_function_size=-1, gamma=0.99, eps=1e-06, use_gpu=False, history_tracking_level=1, overwrite_training=False, print_progress=True, print_stats=True, epsilon=0.99)</code>","text":"<p>Main loop of the Point-Based Value Iteration algorithm. It consists in 2 steps, Backup and Expand. 1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function 2. Backup: Updates the alpha vectors based on the current belief set</p> <p>Stochastic Search with Greedy Action Point-Based Value Iteration: - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)</p> <p>Parameters:</p> Name Type Description Default <code>expansions</code> <code>int</code> <p>How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)</p> required <code>update_passes</code> <code>int</code> <p>How many times the backup function has to be run every time the belief set is expanded.</p> <code>1</code> <code>max_belief_growth</code> <code>int</code> <p>How many beliefs can be added at every expansion step to the belief set.</p> <code>10</code> <code>initial_belief</code> <code>BeliefSet or Belief</code> <p>An initial list of beliefs to start with.</p> <code>None</code> <code>initial_value_function</code> <code>ValueFunction</code> <p>An initial value function to start the solving process with.</p> <code>None</code> <code>prune_level</code> <code>int</code> <p>Parameter to prune the value function further before the expand function.</p> <code>1</code> <code>prune_interval</code> <code>int</code> <p>How often to prune the value function. It is counted in number of backup iterations.</p> <code>10</code> <code>limit_value_function_size</code> <code>int</code> <p>When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function If set to -1, the value function can grow without bounds.</p> <code>-1</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU with cupy array to accelerate solving.</p> <code>False</code> <code>gamma</code> <code>float</code> <p>The discount factor to value immediate rewards more than long term rewards. The learning rate is 1/gamma.</p> <code>0.99</code> <code>eps</code> <code>float</code> <p>The smallest allowed changed for the value function. Bellow the amound of change, the value function is considered converged and the value iteration process will end early.</p> <code>1e-6</code> <code>history_tracking_level</code> <code>int</code> <p>How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)</p> <code>1</code> <code>overwrite_training</code> <code>bool</code> <p>Whether to force the overwriting of the training if a value function already exists for this agent.</p> <code>False</code> <code>print_progress</code> <code>bool</code> <p>Whether or not to print out the progress of the value iteration process.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether or not to print out statistics at the end of the training run.</p> <code>True</code> <code>epsilon</code> <code>float</code> <p>Expand function parameter. threshold to how often to choose the action greedily to how often randomly.</p> <code>0.99</code> <p>Returns:</p> Name Type Description <code>solver_history</code> <code>SolverHistory</code> <p>The history of the solving process with some plotting options.</p> Source code in <code>olfactory_navigation/agents/pbvi_ssga_agent.py</code> <pre><code>def train(self,\n          expansions: int,\n          update_passes: int = 1,\n          max_belief_growth: int = 10,\n          initial_belief: BeliefSet | Belief | None = None,\n          initial_value_function: ValueFunction | None = None,\n          prune_level: int = 1,\n          prune_interval: int = 10,\n          limit_value_function_size: int = -1,\n          gamma: float = 0.99,\n          eps: float = 1e-6,\n          use_gpu: bool = False,\n          history_tracking_level: int = 1,\n          overwrite_training: bool = False,\n          print_progress: bool = True,\n          print_stats: bool = True,\n          epsilon: float = 0.99\n          ) -&gt; TrainingHistory:\n    '''\n    Main loop of the Point-Based Value Iteration algorithm.\n    It consists in 2 steps, Backup and Expand.\n    1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n    2. Backup: Updates the alpha vectors based on the current belief set\n\n    Stochastic Search with Greedy Action Point-Based Value Iteration:\n    - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)\n\n    Parameters\n    ----------\n    expansions : int\n        How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n    update_passes : int, default=1\n        How many times the backup function has to be run every time the belief set is expanded.\n    max_belief_growth : int, default=10\n        How many beliefs can be added at every expansion step to the belief set.\n    initial_belief : BeliefSet or Belief, optional\n        An initial list of beliefs to start with.\n    initial_value_function : ValueFunction, optional\n        An initial value function to start the solving process with.\n    prune_level : int, default=1\n        Parameter to prune the value function further before the expand function.\n    prune_interval : int, default=10\n        How often to prune the value function. It is counted in number of backup iterations.\n    limit_value_function_size : int, default=-1\n        When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n        If set to -1, the value function can grow without bounds.\n    use_gpu : bool, default=False\n        Whether to use the GPU with cupy array to accelerate solving.\n    gamma : float, default=0.99\n        The discount factor to value immediate rewards more than long term rewards.\n        The learning rate is 1/gamma.\n    eps : float, default=1e-6\n        The smallest allowed changed for the value function.\n        Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n    history_tracking_level : int, default=1\n        How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n    overwrite_training : bool, default=False\n        Whether to force the overwriting of the training if a value function already exists for this agent.\n    print_progress : bool, default=True\n        Whether or not to print out the progress of the value iteration process.\n    print_stats : bool, default=True\n        Whether or not to print out statistics at the end of the training run.\n    epsilon : float, default=0.99\n        Expand function parameter. threshold to how often to choose the action greedily to how often randomly.\n\n    Returns\n    -------\n    solver_history : SolverHistory\n        The history of the solving process with some plotting options.\n    '''\n    return super().train(expansions = expansions,\n                         full_backup = True,\n                         update_passes = update_passes,\n                         max_belief_growth = max_belief_growth,\n                         initial_belief = initial_belief,\n                         initial_value_function = initial_value_function,\n                         prune_level = prune_level,\n                         prune_interval = prune_interval,\n                         limit_value_function_size = limit_value_function_size,\n                         gamma = gamma,\n                         eps = eps,\n                         use_gpu = use_gpu,\n                         history_tracking_level = history_tracking_level,\n                         overwrite_training = overwrite_training,\n                         print_progress = print_progress,\n                         print_stats = print_stats,\n                         epsilon = epsilon)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_SSRA_Agent","title":"<code>PBVI_SSRA_Agent</code>","text":"<p>               Bases: <code>PBVI_Agent</code></p> <p>A flavor of the PBVI Agent. The expand function consists in choosing random actions and observations and generating belief points based on that.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment to train the agent with.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.</p> <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <code>model</code> <code>Model</code> <p>A POMDP model to use to represent the olfactory environment. If not provided, the environment_converter parameter will be used.</p> <code>None</code> <code>environment_converter</code> <code>Callable</code> <p>A function to convert the olfactory environment instance to a POMDP Model instance. By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model. This parameter will be ignored if the model parameter is provided.</p> <code>exact_converter</code> <code>converter_parameters</code> <code>dict</code> <p>A set of additional parameters to be passed down to the environment converter.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>model</code> <code>Model</code> <p>The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.</p> <code>saved_at</code> <code>str</code> <p>The place on disk where the agent has been saved (None if not saved yet).</p> <code>on_gpu</code> <code>bool</code> <p>Whether the agent has been sent to the gpu or not.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>trained_at</code> <code>str</code> <p>A string timestamp of when the agent has been trained (None if not trained yet).</p> <code>value_function</code> <code>ValueFunction</code> <p>The value function used for the agent to make decisions.</p> <code>belief</code> <code>BeliefSet</code> <p>Used only during simulations. Part of the Agent's status. Where the agent believes he is over the state space. It is a list of n belief points based on how many simulations are running at once.</p> <code>action_played</code> <code>list[int]</code> <p>Used only during simulations. Part of the Agent's status. Records what action was last played by the agent. A list of n actions played based on how many simulations are running at once.</p> Source code in <code>olfactory_navigation/agents/pbvi_ssra_agent.py</code> <pre><code>class PBVI_SSRA_Agent(PBVI_Agent):\n    '''\n    A flavor of the PBVI Agent. The expand function consists in choosing random actions and observations and generating belief points based on that.\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment to train the agent with.\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.\n    seed : int, default=12131415\n        For reproducible randomness.\n    model : Model, optional\n        A POMDP model to use to represent the olfactory environment.\n        If not provided, the environment_converter parameter will be used.\n    environment_converter : Callable, default=exact_converter\n        A function to convert the olfactory environment instance to a POMDP Model instance.\n        By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model.\n        This parameter will be ignored if the model parameter is provided.\n    converter_parameters : dict, optional\n        A set of additional parameters to be passed down to the environment converter.\n\n    Attributes\n    ---------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    model : pomdp.Model\n        The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.\n    saved_at : str\n        The place on disk where the agent has been saved (None if not saved yet).\n    on_gpu : bool\n        Whether the agent has been sent to the gpu or not.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    trained_at : str\n        A string timestamp of when the agent has been trained (None if not trained yet).\n    value_function : ValueFunction\n        The value function used for the agent to make decisions.\n    belief : BeliefSet\n        Used only during simulations.\n        Part of the Agent's status. Where the agent believes he is over the state space.\n        It is a list of n belief points based on how many simulations are running at once.\n    action_played : list[int]\n        Used only during simulations.\n        Part of the Agent's status. Records what action was last played by the agent.\n        A list of n actions played based on how many simulations are running at once.\n    '''\n    def expand(self,\n               belief_set: BeliefSet,\n               value_function: ValueFunction,\n               max_generation: int\n               ) -&gt; BeliefSet:\n        '''\n        Stochastic Simulation with Random Action.\n        Simulates running a single-step forward from the beliefs in the \"belief_set\".\n        The step forward is taking assuming we are in a random state (weighted by the belief) and taking a random action leading to a state s_p and a observation o.\n        From this action a and observation o we can update our belief.\n\n        Parameters\n        ----------\n        belief_set : BeliefSet\n            List of beliefs to expand on.\n        value_function : ValueFunction\n            The current value function. (NOT USED)\n        max_generation : int, default=10\n            The max amount of beliefs that can be added to the belief set at once.\n\n        Returns\n        -------\n        belief_set_new : BeliefSet\n            Union of the belief_set and the expansions of the beliefs in the belief_set.\n        '''\n        # GPU support\n        xp = np if not self.on_gpu else cp\n        model = self.model\n\n        old_shape = belief_set.belief_array.shape\n        to_generate = min(max_generation, old_shape[0])\n\n        new_belief_array = xp.empty((to_generate, old_shape[1]))\n\n        # Random previous beliefs\n        rand_ind = self.rnd_state.choice(np.arange(old_shape[0]), to_generate, replace=False)\n\n        for i, belief_vector in enumerate(belief_set.belief_array[rand_ind]):\n            b = Belief(model, belief_vector)\n            s = b.random_state()\n            a = self.rnd_state.choice(model.actions)\n            s_p = model.transition(s, a)\n            o = model.observe(s_p, a)\n            b_new = b.update(a, o)\n\n            new_belief_array[i] = b_new.values\n\n        return BeliefSet(model, new_belief_array)\n\n\n    def train(self,\n              expansions: int,\n              update_passes: int = 1,\n              max_belief_growth: int = 10,\n              initial_belief: BeliefSet | Belief | None = None,\n              initial_value_function: ValueFunction | None = None,\n              prune_level: int = 1,\n              prune_interval: int = 10,\n              limit_value_function_size: int = -1,\n              gamma: float = 0.99,\n              eps: float = 1e-6,\n              use_gpu: bool = False,\n              history_tracking_level: int = 1,\n              overwrite_training: bool = False,\n              print_progress: bool = True,\n              print_stats: bool = True\n              ) -&gt; TrainingHistory:\n        '''\n        Main loop of the Point-Based Value Iteration algorithm.\n        It consists in 2 steps, Backup and Expand.\n        1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n        2. Backup: Updates the alpha vectors based on the current belief set\n\n        Stochastic Search with Random Action Point-Based Value Iteration:\n        - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)\n\n        Parameters\n        ----------\n        expansions : int\n            How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n        update_passes : int, default=1\n            How many times the backup function has to be run every time the belief set is expanded.\n        max_belief_growth : int, default=10\n            How many beliefs can be added at every expansion step to the belief set.\n        initial_belief : BeliefSet or Belief, optional\n            An initial list of beliefs to start with.\n        initial_value_function : ValueFunction, optional\n            An initial value function to start the solving process with.\n        prune_level : int, default=1\n            Parameter to prune the value function further before the expand function.\n        prune_interval : int, default=10\n            How often to prune the value function. It is counted in number of backup iterations.\n        limit_value_function_size : int, default=-1\n            When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n            If set to -1, the value function can grow without bounds.\n        use_gpu : bool, default=False\n            Whether to use the GPU with cupy array to accelerate solving.\n        gamma : float, default=0.99\n            The discount factor to value immediate rewards more than long term rewards.\n            The learning rate is 1/gamma.\n        eps : float, default=1e-6\n            The smallest allowed changed for the value function.\n            Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n        history_tracking_level : int, default=1\n            How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n        overwrite_training : bool, default=False\n            Whether to force the overwriting of the training if a value function already exists for this agent.\n        print_progress : bool, default=True\n            Whether or not to print out the progress of the value iteration process.\n        print_stats : bool, default=True\n            Whether or not to print out statistics at the end of the training run.\n\n        Returns\n        -------\n        solver_history : SolverHistory\n            The history of the solving process with some plotting options.\n        '''\n        return super().train(expansions = expansions,\n                             full_backup = True,\n                             update_passes = update_passes,\n                             max_belief_growth = max_belief_growth,\n                             initial_belief = initial_belief,\n                             initial_value_function = initial_value_function,\n                             prune_level = prune_level,\n                             prune_interval = prune_interval,\n                             limit_value_function_size = limit_value_function_size,\n                             gamma = gamma,\n                             eps = eps,\n                             use_gpu = use_gpu,\n                             history_tracking_level = history_tracking_level,\n                             overwrite_training = overwrite_training,\n                             print_progress = print_progress,\n                             print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_SSRA_Agent.expand","title":"<code>expand(belief_set, value_function, max_generation)</code>","text":"<p>Stochastic Simulation with Random Action. Simulates running a single-step forward from the beliefs in the \"belief_set\". The step forward is taking assuming we are in a random state (weighted by the belief) and taking a random action leading to a state s_p and a observation o. From this action a and observation o we can update our belief.</p> <p>Parameters:</p> Name Type Description Default <code>belief_set</code> <code>BeliefSet</code> <p>List of beliefs to expand on.</p> required <code>value_function</code> <code>ValueFunction</code> <p>The current value function. (NOT USED)</p> required <code>max_generation</code> <code>int</code> <p>The max amount of beliefs that can be added to the belief set at once.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>belief_set_new</code> <code>BeliefSet</code> <p>Union of the belief_set and the expansions of the beliefs in the belief_set.</p> Source code in <code>olfactory_navigation/agents/pbvi_ssra_agent.py</code> <pre><code>def expand(self,\n           belief_set: BeliefSet,\n           value_function: ValueFunction,\n           max_generation: int\n           ) -&gt; BeliefSet:\n    '''\n    Stochastic Simulation with Random Action.\n    Simulates running a single-step forward from the beliefs in the \"belief_set\".\n    The step forward is taking assuming we are in a random state (weighted by the belief) and taking a random action leading to a state s_p and a observation o.\n    From this action a and observation o we can update our belief.\n\n    Parameters\n    ----------\n    belief_set : BeliefSet\n        List of beliefs to expand on.\n    value_function : ValueFunction\n        The current value function. (NOT USED)\n    max_generation : int, default=10\n        The max amount of beliefs that can be added to the belief set at once.\n\n    Returns\n    -------\n    belief_set_new : BeliefSet\n        Union of the belief_set and the expansions of the beliefs in the belief_set.\n    '''\n    # GPU support\n    xp = np if not self.on_gpu else cp\n    model = self.model\n\n    old_shape = belief_set.belief_array.shape\n    to_generate = min(max_generation, old_shape[0])\n\n    new_belief_array = xp.empty((to_generate, old_shape[1]))\n\n    # Random previous beliefs\n    rand_ind = self.rnd_state.choice(np.arange(old_shape[0]), to_generate, replace=False)\n\n    for i, belief_vector in enumerate(belief_set.belief_array[rand_ind]):\n        b = Belief(model, belief_vector)\n        s = b.random_state()\n        a = self.rnd_state.choice(model.actions)\n        s_p = model.transition(s, a)\n        o = model.observe(s_p, a)\n        b_new = b.update(a, o)\n\n        new_belief_array[i] = b_new.values\n\n    return BeliefSet(model, new_belief_array)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.PBVI_SSRA_Agent.train","title":"<code>train(expansions, update_passes=1, max_belief_growth=10, initial_belief=None, initial_value_function=None, prune_level=1, prune_interval=10, limit_value_function_size=-1, gamma=0.99, eps=1e-06, use_gpu=False, history_tracking_level=1, overwrite_training=False, print_progress=True, print_stats=True)</code>","text":"<p>Main loop of the Point-Based Value Iteration algorithm. It consists in 2 steps, Backup and Expand. 1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function 2. Backup: Updates the alpha vectors based on the current belief set</p> <p>Stochastic Search with Random Action Point-Based Value Iteration: - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)</p> <p>Parameters:</p> Name Type Description Default <code>expansions</code> <code>int</code> <p>How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)</p> required <code>update_passes</code> <code>int</code> <p>How many times the backup function has to be run every time the belief set is expanded.</p> <code>1</code> <code>max_belief_growth</code> <code>int</code> <p>How many beliefs can be added at every expansion step to the belief set.</p> <code>10</code> <code>initial_belief</code> <code>BeliefSet or Belief</code> <p>An initial list of beliefs to start with.</p> <code>None</code> <code>initial_value_function</code> <code>ValueFunction</code> <p>An initial value function to start the solving process with.</p> <code>None</code> <code>prune_level</code> <code>int</code> <p>Parameter to prune the value function further before the expand function.</p> <code>1</code> <code>prune_interval</code> <code>int</code> <p>How often to prune the value function. It is counted in number of backup iterations.</p> <code>10</code> <code>limit_value_function_size</code> <code>int</code> <p>When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function If set to -1, the value function can grow without bounds.</p> <code>-1</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU with cupy array to accelerate solving.</p> <code>False</code> <code>gamma</code> <code>float</code> <p>The discount factor to value immediate rewards more than long term rewards. The learning rate is 1/gamma.</p> <code>0.99</code> <code>eps</code> <code>float</code> <p>The smallest allowed changed for the value function. Bellow the amound of change, the value function is considered converged and the value iteration process will end early.</p> <code>1e-6</code> <code>history_tracking_level</code> <code>int</code> <p>How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)</p> <code>1</code> <code>overwrite_training</code> <code>bool</code> <p>Whether to force the overwriting of the training if a value function already exists for this agent.</p> <code>False</code> <code>print_progress</code> <code>bool</code> <p>Whether or not to print out the progress of the value iteration process.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether or not to print out statistics at the end of the training run.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>solver_history</code> <code>SolverHistory</code> <p>The history of the solving process with some plotting options.</p> Source code in <code>olfactory_navigation/agents/pbvi_ssra_agent.py</code> <pre><code>def train(self,\n          expansions: int,\n          update_passes: int = 1,\n          max_belief_growth: int = 10,\n          initial_belief: BeliefSet | Belief | None = None,\n          initial_value_function: ValueFunction | None = None,\n          prune_level: int = 1,\n          prune_interval: int = 10,\n          limit_value_function_size: int = -1,\n          gamma: float = 0.99,\n          eps: float = 1e-6,\n          use_gpu: bool = False,\n          history_tracking_level: int = 1,\n          overwrite_training: bool = False,\n          print_progress: bool = True,\n          print_stats: bool = True\n          ) -&gt; TrainingHistory:\n    '''\n    Main loop of the Point-Based Value Iteration algorithm.\n    It consists in 2 steps, Backup and Expand.\n    1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n    2. Backup: Updates the alpha vectors based on the current belief set\n\n    Stochastic Search with Random Action Point-Based Value Iteration:\n    - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)\n\n    Parameters\n    ----------\n    expansions : int\n        How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n    update_passes : int, default=1\n        How many times the backup function has to be run every time the belief set is expanded.\n    max_belief_growth : int, default=10\n        How many beliefs can be added at every expansion step to the belief set.\n    initial_belief : BeliefSet or Belief, optional\n        An initial list of beliefs to start with.\n    initial_value_function : ValueFunction, optional\n        An initial value function to start the solving process with.\n    prune_level : int, default=1\n        Parameter to prune the value function further before the expand function.\n    prune_interval : int, default=10\n        How often to prune the value function. It is counted in number of backup iterations.\n    limit_value_function_size : int, default=-1\n        When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n        If set to -1, the value function can grow without bounds.\n    use_gpu : bool, default=False\n        Whether to use the GPU with cupy array to accelerate solving.\n    gamma : float, default=0.99\n        The discount factor to value immediate rewards more than long term rewards.\n        The learning rate is 1/gamma.\n    eps : float, default=1e-6\n        The smallest allowed changed for the value function.\n        Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n    history_tracking_level : int, default=1\n        How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n    overwrite_training : bool, default=False\n        Whether to force the overwriting of the training if a value function already exists for this agent.\n    print_progress : bool, default=True\n        Whether or not to print out the progress of the value iteration process.\n    print_stats : bool, default=True\n        Whether or not to print out statistics at the end of the training run.\n\n    Returns\n    -------\n    solver_history : SolverHistory\n        The history of the solving process with some plotting options.\n    '''\n    return super().train(expansions = expansions,\n                         full_backup = True,\n                         update_passes = update_passes,\n                         max_belief_growth = max_belief_growth,\n                         initial_belief = initial_belief,\n                         initial_value_function = initial_value_function,\n                         prune_level = prune_level,\n                         prune_interval = prune_interval,\n                         limit_value_function_size = limit_value_function_size,\n                         gamma = gamma,\n                         eps = eps,\n                         use_gpu = use_gpu,\n                         history_tracking_level = history_tracking_level,\n                         overwrite_training = overwrite_training,\n                         print_progress = print_progress,\n                         print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.Perseus_Agent","title":"<code>Perseus_Agent</code>","text":"<p>               Bases: <code>PBVI_Agent</code></p> <p>A flavor of the PBVI Agent.</p>"},{"location":"reference/agents/#olfactory_navigation.agents.Perseus_Agent--todo-do-document-of-perseus-agent","title":"TODO: Do document of Perseus agent","text":""},{"location":"reference/agents/#olfactory_navigation.agents.Perseus_Agent--todo-fix-perseus-expand","title":"TODO: FIX Perseus expand","text":"<p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment to train the agent with.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.</p> <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <code>model</code> <code>Model</code> <p>A POMDP model to use to represent the olfactory environment. If not provided, the environment_converter parameter will be used.</p> <code>None</code> <code>environment_converter</code> <code>Callable</code> <p>A function to convert the olfactory environment instance to a POMDP Model instance. By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model. This parameter will be ignored if the model parameter is provided.</p> <code>exact_converter</code> <code>converter_parameters</code> <code>dict</code> <p>A set of additional parameters to be passed down to the environment converter.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>model</code> <code>Model</code> <p>The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.</p> <code>saved_at</code> <code>str</code> <p>The place on disk where the agent has been saved (None if not saved yet).</p> <code>on_gpu</code> <code>bool</code> <p>Whether the agent has been sent to the gpu or not.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>trained_at</code> <code>str</code> <p>A string timestamp of when the agent has been trained (None if not trained yet).</p> <code>value_function</code> <code>ValueFunction</code> <p>The value function used for the agent to make decisions.</p> <code>belief</code> <code>BeliefSet</code> <p>Used only during simulations. Part of the Agent's status. Where the agent believes he is over the state space. It is a list of n belief points based on how many simulations are running at once.</p> <code>action_played</code> <code>list[int]</code> <p>Used only during simulations. Part of the Agent's status. Records what action was last played by the agent. A list of n actions played based on how many simulations are running at once.</p> Source code in <code>olfactory_navigation/agents/perseus_agent.py</code> <pre><code>class Perseus_Agent(PBVI_Agent):\n    '''\n    A flavor of the PBVI Agent.\n\n    # TODO: Do document of Perseus agent\n    # TODO: FIX Perseus expand\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment to train the agent with.\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.\n    seed : int, default=12131415\n        For reproducible randomness.\n    model : Model, optional\n        A POMDP model to use to represent the olfactory environment.\n        If not provided, the environment_converter parameter will be used.\n    environment_converter : Callable, default=exact_converter\n        A function to convert the olfactory environment instance to a POMDP Model instance.\n        By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model.\n        This parameter will be ignored if the model parameter is provided.\n    converter_parameters : dict, optional\n        A set of additional parameters to be passed down to the environment converter.\n\n    Attributes\n    ---------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    model : pomdp.Model\n        The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.\n    saved_at : str\n        The place on disk where the agent has been saved (None if not saved yet).\n    on_gpu : bool\n        Whether the agent has been sent to the gpu or not.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    trained_at : str\n        A string timestamp of when the agent has been trained (None if not trained yet).\n    value_function : ValueFunction\n        The value function used for the agent to make decisions.\n    belief : BeliefSet\n        Used only during simulations.\n        Part of the Agent's status. Where the agent believes he is over the state space.\n        It is a list of n belief points based on how many simulations are running at once.\n    action_played : list[int]\n        Used only during simulations.\n        Part of the Agent's status. Records what action was last played by the agent.\n        A list of n actions played based on how many simulations are running at once.\n    '''\n    def expand(self,\n               belief_set: BeliefSet,\n               value_function: ValueFunction,\n               max_generation: int\n               ) -&gt; BeliefSet:\n        '''\n        # TODO\n\n        Parameters\n        ----------\n        belief_set : BeliefSet\n            List of beliefs to expand on.\n        value_function : ValueFunction\n            The current value function. (NOT USED)\n        max_generation : int, default=10\n            The max amount of beliefs that can be added to the belief set at once.\n\n        Returns\n        -------\n        belief_set : BeliefSet\n            A new sequence of beliefs.\n        '''\n        # GPU support\n        xp = np if not self.on_gpu else cp\n        model = self.model\n\n        b = belief_set.belief_list[0]\n        belief_sequence = []\n\n        for i in range(max_generation):\n            # Choose random action\n            a = int(self.rnd_state.choice(model.actions, size=1)[0])\n\n            # Choose random observation based on prob: P(o|b,a)\n            obs_prob = xp.einsum('sor,s-&gt;o', model.reachable_transitional_observation_table[:,a,:,:], b.values)\n            o = int(self.rnd_state.choice(model.observations, size=1, p=obs_prob)[0])\n\n            # Update belief\n            bao = b.update(a,o)\n\n            # Finalization\n            belief_sequence.append(bao)\n            b = bao\n\n        return BeliefSet(model, belief_sequence)\n\n\n    def train(self,\n              expansions: int,\n              update_passes: int = 1,\n              max_belief_growth: int = 10,\n              initial_belief: BeliefSet | Belief | None = None,\n              initial_value_function: ValueFunction | None = None,\n              prune_level: int = 1,\n              prune_interval: int = 10,\n              limit_value_function_size: int = -1,\n              gamma: float = 0.99,\n              eps: float = 1e-6,\n              use_gpu: bool = False,\n              history_tracking_level: int = 1,\n              overwrite_training: bool = False,\n              print_progress: bool = True,\n              print_stats: bool = True\n              ) -&gt; TrainingHistory:\n        '''\n        Main loop of the Point-Based Value Iteration algorithm.\n        It consists in 2 steps, Backup and Expand.\n        1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n        2. Backup: Updates the alpha vectors based on the current belief set\n\n        Heuristic Search Value Iteration:\n        - By default it performs the backup only on set of beliefs generated by the expand function. (so it full_backup=False)\n\n        Parameters\n        ----------\n        expansions : int\n            How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n        update_passes : int, default=1\n            How many times the backup function has to be run every time the belief set is expanded.\n        max_belief_growth : int, default=10\n            How many beliefs can be added at every expansion step to the belief set.\n        initial_belief : BeliefSet or Belief, optional\n            An initial list of beliefs to start with.\n        initial_value_function : ValueFunction, optional\n            An initial value function to start the solving process with.\n        prune_level : int, default=1\n            Parameter to prune the value function further before the expand function.\n        prune_interval : int, default=10\n            How often to prune the value function. It is counted in number of backup iterations.\n        limit_value_function_size : int, default=-1\n            When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n            If set to -1, the value function can grow without bounds.\n        use_gpu : bool, default=False\n            Whether to use the GPU with cupy array to accelerate solving.\n        gamma : float, default=0.99\n            The discount factor to value immediate rewards more than long term rewards.\n            The learning rate is 1/gamma.\n        eps : float, default=1e-6\n            The smallest allowed changed for the value function.\n            Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n        history_tracking_level : int, default=1\n            How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n        overwrite_training : bool, default=False\n            Whether to force the overwriting of the training if a value function already exists for this agent.\n        print_progress : bool, default=True\n            Whether or not to print out the progress of the value iteration process.\n        print_stats : bool, default=True\n            Whether or not to print out statistics at the end of the training run.\n\n        Returns\n        -------\n        solver_history : SolverHistory\n            The history of the solving process with some plotting options.\n        '''\n        return super().train(expansions = expansions,\n                             full_backup = False,\n                             update_passes = update_passes,\n                             max_belief_growth = max_belief_growth,\n                             initial_belief = initial_belief,\n                             initial_value_function = initial_value_function,\n                             prune_level = prune_level,\n                             prune_interval = prune_interval,\n                             limit_value_function_size = limit_value_function_size,\n                             gamma = gamma,\n                             eps = eps,\n                             use_gpu = use_gpu,\n                             history_tracking_level = history_tracking_level,\n                             overwrite_training = overwrite_training,\n                             print_progress = print_progress,\n                             print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.Perseus_Agent.expand","title":"<code>expand(belief_set, value_function, max_generation)</code>","text":""},{"location":"reference/agents/#olfactory_navigation.agents.Perseus_Agent.expand--todo","title":"TODO","text":"<p>Parameters:</p> Name Type Description Default <code>belief_set</code> <code>BeliefSet</code> <p>List of beliefs to expand on.</p> required <code>value_function</code> <code>ValueFunction</code> <p>The current value function. (NOT USED)</p> required <code>max_generation</code> <code>int</code> <p>The max amount of beliefs that can be added to the belief set at once.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>belief_set</code> <code>BeliefSet</code> <p>A new sequence of beliefs.</p> Source code in <code>olfactory_navigation/agents/perseus_agent.py</code> <pre><code>def expand(self,\n           belief_set: BeliefSet,\n           value_function: ValueFunction,\n           max_generation: int\n           ) -&gt; BeliefSet:\n    '''\n    # TODO\n\n    Parameters\n    ----------\n    belief_set : BeliefSet\n        List of beliefs to expand on.\n    value_function : ValueFunction\n        The current value function. (NOT USED)\n    max_generation : int, default=10\n        The max amount of beliefs that can be added to the belief set at once.\n\n    Returns\n    -------\n    belief_set : BeliefSet\n        A new sequence of beliefs.\n    '''\n    # GPU support\n    xp = np if not self.on_gpu else cp\n    model = self.model\n\n    b = belief_set.belief_list[0]\n    belief_sequence = []\n\n    for i in range(max_generation):\n        # Choose random action\n        a = int(self.rnd_state.choice(model.actions, size=1)[0])\n\n        # Choose random observation based on prob: P(o|b,a)\n        obs_prob = xp.einsum('sor,s-&gt;o', model.reachable_transitional_observation_table[:,a,:,:], b.values)\n        o = int(self.rnd_state.choice(model.observations, size=1, p=obs_prob)[0])\n\n        # Update belief\n        bao = b.update(a,o)\n\n        # Finalization\n        belief_sequence.append(bao)\n        b = bao\n\n    return BeliefSet(model, belief_sequence)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.Perseus_Agent.train","title":"<code>train(expansions, update_passes=1, max_belief_growth=10, initial_belief=None, initial_value_function=None, prune_level=1, prune_interval=10, limit_value_function_size=-1, gamma=0.99, eps=1e-06, use_gpu=False, history_tracking_level=1, overwrite_training=False, print_progress=True, print_stats=True)</code>","text":"<p>Main loop of the Point-Based Value Iteration algorithm. It consists in 2 steps, Backup and Expand. 1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function 2. Backup: Updates the alpha vectors based on the current belief set</p> <p>Heuristic Search Value Iteration: - By default it performs the backup only on set of beliefs generated by the expand function. (so it full_backup=False)</p> <p>Parameters:</p> Name Type Description Default <code>expansions</code> <code>int</code> <p>How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)</p> required <code>update_passes</code> <code>int</code> <p>How many times the backup function has to be run every time the belief set is expanded.</p> <code>1</code> <code>max_belief_growth</code> <code>int</code> <p>How many beliefs can be added at every expansion step to the belief set.</p> <code>10</code> <code>initial_belief</code> <code>BeliefSet or Belief</code> <p>An initial list of beliefs to start with.</p> <code>None</code> <code>initial_value_function</code> <code>ValueFunction</code> <p>An initial value function to start the solving process with.</p> <code>None</code> <code>prune_level</code> <code>int</code> <p>Parameter to prune the value function further before the expand function.</p> <code>1</code> <code>prune_interval</code> <code>int</code> <p>How often to prune the value function. It is counted in number of backup iterations.</p> <code>10</code> <code>limit_value_function_size</code> <code>int</code> <p>When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function If set to -1, the value function can grow without bounds.</p> <code>-1</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU with cupy array to accelerate solving.</p> <code>False</code> <code>gamma</code> <code>float</code> <p>The discount factor to value immediate rewards more than long term rewards. The learning rate is 1/gamma.</p> <code>0.99</code> <code>eps</code> <code>float</code> <p>The smallest allowed changed for the value function. Bellow the amound of change, the value function is considered converged and the value iteration process will end early.</p> <code>1e-6</code> <code>history_tracking_level</code> <code>int</code> <p>How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)</p> <code>1</code> <code>overwrite_training</code> <code>bool</code> <p>Whether to force the overwriting of the training if a value function already exists for this agent.</p> <code>False</code> <code>print_progress</code> <code>bool</code> <p>Whether or not to print out the progress of the value iteration process.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether or not to print out statistics at the end of the training run.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>solver_history</code> <code>SolverHistory</code> <p>The history of the solving process with some plotting options.</p> Source code in <code>olfactory_navigation/agents/perseus_agent.py</code> <pre><code>def train(self,\n          expansions: int,\n          update_passes: int = 1,\n          max_belief_growth: int = 10,\n          initial_belief: BeliefSet | Belief | None = None,\n          initial_value_function: ValueFunction | None = None,\n          prune_level: int = 1,\n          prune_interval: int = 10,\n          limit_value_function_size: int = -1,\n          gamma: float = 0.99,\n          eps: float = 1e-6,\n          use_gpu: bool = False,\n          history_tracking_level: int = 1,\n          overwrite_training: bool = False,\n          print_progress: bool = True,\n          print_stats: bool = True\n          ) -&gt; TrainingHistory:\n    '''\n    Main loop of the Point-Based Value Iteration algorithm.\n    It consists in 2 steps, Backup and Expand.\n    1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n    2. Backup: Updates the alpha vectors based on the current belief set\n\n    Heuristic Search Value Iteration:\n    - By default it performs the backup only on set of beliefs generated by the expand function. (so it full_backup=False)\n\n    Parameters\n    ----------\n    expansions : int\n        How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n    update_passes : int, default=1\n        How many times the backup function has to be run every time the belief set is expanded.\n    max_belief_growth : int, default=10\n        How many beliefs can be added at every expansion step to the belief set.\n    initial_belief : BeliefSet or Belief, optional\n        An initial list of beliefs to start with.\n    initial_value_function : ValueFunction, optional\n        An initial value function to start the solving process with.\n    prune_level : int, default=1\n        Parameter to prune the value function further before the expand function.\n    prune_interval : int, default=10\n        How often to prune the value function. It is counted in number of backup iterations.\n    limit_value_function_size : int, default=-1\n        When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n        If set to -1, the value function can grow without bounds.\n    use_gpu : bool, default=False\n        Whether to use the GPU with cupy array to accelerate solving.\n    gamma : float, default=0.99\n        The discount factor to value immediate rewards more than long term rewards.\n        The learning rate is 1/gamma.\n    eps : float, default=1e-6\n        The smallest allowed changed for the value function.\n        Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n    history_tracking_level : int, default=1\n        How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n    overwrite_training : bool, default=False\n        Whether to force the overwriting of the training if a value function already exists for this agent.\n    print_progress : bool, default=True\n        Whether or not to print out the progress of the value iteration process.\n    print_stats : bool, default=True\n        Whether or not to print out statistics at the end of the training run.\n\n    Returns\n    -------\n    solver_history : SolverHistory\n        The history of the solving process with some plotting options.\n    '''\n    return super().train(expansions = expansions,\n                         full_backup = False,\n                         update_passes = update_passes,\n                         max_belief_growth = max_belief_growth,\n                         initial_belief = initial_belief,\n                         initial_value_function = initial_value_function,\n                         prune_level = prune_level,\n                         prune_interval = prune_interval,\n                         limit_value_function_size = limit_value_function_size,\n                         gamma = gamma,\n                         eps = eps,\n                         use_gpu = use_gpu,\n                         history_tracking_level = history_tracking_level,\n                         overwrite_training = overwrite_training,\n                         print_progress = print_progress,\n                         print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.QMDP_Agent","title":"<code>QMDP_Agent</code>","text":"<p>               Bases: <code>PBVI_Agent</code></p> <p>An agent that relies on Model-Based Reinforcement Learning. It is a simplified version of the PBVI_Agent. It runs the a Value Iteration solver, assuming full observability. The value function that comes out from this is therefore used to make choices.</p> <p>As stated, during simulations, the agent will choose actions based on an argmax of what action has the highest matrix product of the value function with the belief vector.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment to train the agent with.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.</p> <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <code>model</code> <code>Model</code> <p>A POMDP model to use to represent the olfactory environment. If not provided, the environment_converter parameter will be used.</p> <code>None</code> <code>environment_converter</code> <code>Callable</code> <p>A function to convert the olfactory environment instance to a POMDP Model instance. By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model. This parameter will be ignored if the model parameter is provided.</p> <code>exact_converter</code> <code>converter_parameters</code> <code>dict</code> <p>A set of additional parameters to be passed down to the environment converter.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>model</code> <code>Model</code> <p>The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.</p> <code>saved_at</code> <code>str</code> <p>The place on disk where the agent has been saved (None if not saved yet).</p> <code>on_gpu</code> <code>bool</code> <p>Whether the agent has been sent to the gpu or not.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>trained_at</code> <code>str</code> <p>A string timestamp of when the agent has been trained (None if not trained yet).</p> <code>value_function</code> <code>ValueFunction</code> <p>The value function used for the agent to make decisions.</p> <code>belief</code> <code>BeliefSet</code> <p>Used only during simulations. Part of the Agent's status. Where the agent believes he is over the state space. It is a list of n belief points based on how many simulations are running at once.</p> <code>action_played</code> <code>list[int]</code> <p>Used only during simulations. Part of the Agent's status. Records what action was last played by the agent. A list of n actions played based on how many simulations are running at once.</p> Source code in <code>olfactory_navigation/agents/qmdp_agent.py</code> <pre><code>class QMDP_Agent(PBVI_Agent):\n    '''\n    An agent that relies on Model-Based Reinforcement Learning. It is a simplified version of the PBVI_Agent.\n    It runs the a Value Iteration solver, assuming full observability. The value function that comes out from this is therefore used to make choices.\n\n    As stated, during simulations, the agent will choose actions based on an argmax of what action has the highest matrix product of the value function with the belief vector.\n\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment to train the agent with.\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.\n    seed : int, default=12131415\n        For reproducible randomness.\n    model : Model, optional\n        A POMDP model to use to represent the olfactory environment.\n        If not provided, the environment_converter parameter will be used.\n    environment_converter : Callable, default=exact_converter\n        A function to convert the olfactory environment instance to a POMDP Model instance.\n        By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model.\n        This parameter will be ignored if the model parameter is provided.\n    converter_parameters : dict, optional\n        A set of additional parameters to be passed down to the environment converter.\n\n    Attributes\n    ---------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    model : pomdp.Model\n        The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.\n    saved_at : str\n        The place on disk where the agent has been saved (None if not saved yet).\n    on_gpu : bool\n        Whether the agent has been sent to the gpu or not.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    trained_at : str\n        A string timestamp of when the agent has been trained (None if not trained yet).\n    value_function : ValueFunction\n        The value function used for the agent to make decisions.\n    belief : BeliefSet\n        Used only during simulations.\n        Part of the Agent's status. Where the agent believes he is over the state space.\n        It is a list of n belief points based on how many simulations are running at once.\n    action_played : list[int]\n        Used only during simulations.\n        Part of the Agent's status. Records what action was last played by the agent.\n        A list of n actions played based on how many simulations are running at once.\n    '''\n    def train(self,\n              expansions: int,\n              initial_value_function: ValueFunction | None = None,\n              gamma: float = 0.99,\n              eps: float = 1e-6,\n              use_gpu: bool = False,\n              history_tracking_level: int = 1,\n              overwrite_training: bool = False,\n              print_progress: bool = True,\n              print_stats: bool = True\n              ) -&gt; TrainingHistory:\n        '''\n        Simplified version of the training. It consists in running the Value Iteration process.\n\n        Parameters\n        ----------\n        expansions : int\n            How many iterations to run the Value Iteration process for.\n        initial_value_function : ValueFunction, optional\n            An initial value function to start the solving process with.\n        use_gpu : bool, default=False\n            Whether to use the GPU with cupy array to accelerate solving.\n        gamma : float, default=0.99\n            The discount factor to value immediate rewards more than long term rewards.\n            The learning rate is 1/gamma.\n        eps : float, default=1e-6\n            The smallest allowed changed for the value function.\n            Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n        history_tracking_level : int, default=1\n            How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n        overwrite_training : bool, default=False\n            Whether to force the overwriting of the training if a value function already exists for this agent.\n        print_progress : bool, default=True\n            Whether or not to print out the progress of the value iteration process.\n        print_stats : bool, default=True\n            Whether or not to print out statistics at the end of the training run.\n\n        Returns\n        -------\n        solver_history : SolverHistory\n            The history of the solving process with some plotting options.\n        '''\n        # Handeling the case where the agent is already trained\n        if (self.value_function is not None):\n            if overwrite_training:\n                self.trained_at = None\n                self.name = '-'.join(self.name.split('-')[:-1])\n                self.value_function = None\n            else:\n                initial_value_function = self.value_function\n\n        model = self.model if not use_gpu else self.model.gpu_model\n\n        # Value Iteration solving\n        value_function, hist = vi_solver.solve(model = model,\n                                               horizon = expansions,\n                                               initial_value_function = initial_value_function,\n                                               gamma = gamma,\n                                               eps = eps,\n                                               use_gpu = use_gpu,\n                                               history_tracking_level = history_tracking_level,\n                                               print_progress = print_progress)\n\n        # Record when it was trained\n        self.trained_at = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        self.name += f'-trained_{self.trained_at}'\n\n        self.value_function = value_function.to_cpu() if not self.on_gpu else value_function.to_gpu()\n\n        # Print stats if requested\n        if print_stats:\n            print(hist.summary)\n\n        return hist\n</code></pre>"},{"location":"reference/agents/#olfactory_navigation.agents.QMDP_Agent.train","title":"<code>train(expansions, initial_value_function=None, gamma=0.99, eps=1e-06, use_gpu=False, history_tracking_level=1, overwrite_training=False, print_progress=True, print_stats=True)</code>","text":"<p>Simplified version of the training. It consists in running the Value Iteration process.</p> <p>Parameters:</p> Name Type Description Default <code>expansions</code> <code>int</code> <p>How many iterations to run the Value Iteration process for.</p> required <code>initial_value_function</code> <code>ValueFunction</code> <p>An initial value function to start the solving process with.</p> <code>None</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU with cupy array to accelerate solving.</p> <code>False</code> <code>gamma</code> <code>float</code> <p>The discount factor to value immediate rewards more than long term rewards. The learning rate is 1/gamma.</p> <code>0.99</code> <code>eps</code> <code>float</code> <p>The smallest allowed changed for the value function. Bellow the amound of change, the value function is considered converged and the value iteration process will end early.</p> <code>1e-6</code> <code>history_tracking_level</code> <code>int</code> <p>How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)</p> <code>1</code> <code>overwrite_training</code> <code>bool</code> <p>Whether to force the overwriting of the training if a value function already exists for this agent.</p> <code>False</code> <code>print_progress</code> <code>bool</code> <p>Whether or not to print out the progress of the value iteration process.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether or not to print out statistics at the end of the training run.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>solver_history</code> <code>SolverHistory</code> <p>The history of the solving process with some plotting options.</p> Source code in <code>olfactory_navigation/agents/qmdp_agent.py</code> <pre><code>def train(self,\n          expansions: int,\n          initial_value_function: ValueFunction | None = None,\n          gamma: float = 0.99,\n          eps: float = 1e-6,\n          use_gpu: bool = False,\n          history_tracking_level: int = 1,\n          overwrite_training: bool = False,\n          print_progress: bool = True,\n          print_stats: bool = True\n          ) -&gt; TrainingHistory:\n    '''\n    Simplified version of the training. It consists in running the Value Iteration process.\n\n    Parameters\n    ----------\n    expansions : int\n        How many iterations to run the Value Iteration process for.\n    initial_value_function : ValueFunction, optional\n        An initial value function to start the solving process with.\n    use_gpu : bool, default=False\n        Whether to use the GPU with cupy array to accelerate solving.\n    gamma : float, default=0.99\n        The discount factor to value immediate rewards more than long term rewards.\n        The learning rate is 1/gamma.\n    eps : float, default=1e-6\n        The smallest allowed changed for the value function.\n        Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n    history_tracking_level : int, default=1\n        How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n    overwrite_training : bool, default=False\n        Whether to force the overwriting of the training if a value function already exists for this agent.\n    print_progress : bool, default=True\n        Whether or not to print out the progress of the value iteration process.\n    print_stats : bool, default=True\n        Whether or not to print out statistics at the end of the training run.\n\n    Returns\n    -------\n    solver_history : SolverHistory\n        The history of the solving process with some plotting options.\n    '''\n    # Handeling the case where the agent is already trained\n    if (self.value_function is not None):\n        if overwrite_training:\n            self.trained_at = None\n            self.name = '-'.join(self.name.split('-')[:-1])\n            self.value_function = None\n        else:\n            initial_value_function = self.value_function\n\n    model = self.model if not use_gpu else self.model.gpu_model\n\n    # Value Iteration solving\n    value_function, hist = vi_solver.solve(model = model,\n                                           horizon = expansions,\n                                           initial_value_function = initial_value_function,\n                                           gamma = gamma,\n                                           eps = eps,\n                                           use_gpu = use_gpu,\n                                           history_tracking_level = history_tracking_level,\n                                           print_progress = print_progress)\n\n    # Record when it was trained\n    self.trained_at = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    self.name += f'-trained_{self.trained_at}'\n\n    self.value_function = value_function.to_cpu() if not self.on_gpu else value_function.to_gpu()\n\n    # Print stats if requested\n    if print_stats:\n        print(hist.summary)\n\n    return hist\n</code></pre>"},{"location":"reference/agents/fsvi_agent/","title":"fsvi_agent","text":""},{"location":"reference/agents/fsvi_agent/#olfactory_navigation.agents.fsvi_agent.FSVI_Agent","title":"<code>FSVI_Agent</code>","text":"<p>               Bases: <code>PBVI_Agent</code></p> <p>A particular flavor of the Point-Based Value Iteration based agent. The general concept relies on Model-Based reinforcement learning as described in: Pineau, J., Gordon, G., &amp; Thrun, S. (2003, August). Point-based value iteration: An anytime algorithm for POMDPs The Forward Search Value Iteration algorithm is described in: Shani, G., Brafman, R. I., &amp; Shimony, S. E. (2007, January). Forward Search Value Iteration for POMDPs</p> <p>The training consist in two steps:</p> <ul> <li> <p>Expand: Where belief points are explored based on the some strategy (to be defined by subclasses).</p> </li> <li> <p>Backup: Using the generated belief points, the value function is updated.</p> </li> </ul> <p>The belief points are probability distributions over the state space and are therefore vectors of |S| elements.</p> <p>Actions are chosen based on a value function. A value function is a set of alpha vectors of dimentionality |S|. Each alpha vector is associated to a single action but multiple alpha vectors can be associated to the same action. To choose an action at a given belief point, a dot product is taken between each alpha vector and the belief point and the action associated with the highest result is chosen.</p> <p>Forward Search exploration concept: It relies of the solution of the Fully-Observable (MDP) problem to guide the exploration of belief points. It makes an agent start randomly in the environment and makes him take steps following the MDP solution while generating belief points along the way. Each time the expand function is called it starts generated a new set of belief points and the update function uses only the latest generated belief points to make update the value function.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment to train the agent with.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.</p> <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <code>model</code> <code>Model</code> <p>A POMDP model to use to represent the olfactory environment. If not provided, the environment_converter parameter will be used.</p> <code>None</code> <code>environment_converter</code> <code>Callable</code> <p>A function to convert the olfactory environment instance to a POMDP Model instance. By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model. This parameter will be ignored if the model parameter is provided.</p> <code>exact_converter</code> <code>converter_parameters</code> <code>dict</code> <p>A set of additional parameters to be passed down to the environment converter.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>model</code> <code>Model</code> <p>The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.</p> <code>saved_at</code> <code>str</code> <p>The place on disk where the agent has been saved (None if not saved yet).</p> <code>on_gpu</code> <code>bool</code> <p>Whether the agent has been sent to the gpu or not.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>trained_at</code> <code>str</code> <p>A string timestamp of when the agent has been trained (None if not trained yet).</p> <code>value_function</code> <code>ValueFunction</code> <p>The value function used for the agent to make decisions.</p> <code>belief</code> <code>BeliefSet</code> <p>Used only during simulations. Part of the Agent's status. Where the agent believes he is over the state space. It is a list of n belief points based on how many simulations are running at once.</p> <code>action_played</code> <code>list[int]</code> <p>Used only during simulations. Part of the Agent's status. Records what action was last played by the agent. A list of n actions played based on how many simulations are running at once.</p> <code>mdp_policy</code> <code>ValueFunction</code> <p>The solution to the fully version of the problem.</p> Source code in <code>olfactory_navigation/agents/fsvi_agent.py</code> <pre><code>class FSVI_Agent(PBVI_Agent):\n    '''\n    A particular flavor of the Point-Based Value Iteration based agent.\n    The general concept relies on Model-Based reinforcement learning as described in: Pineau, J., Gordon, G., &amp; Thrun, S. (2003, August). Point-based value iteration: An anytime algorithm for POMDPs\n    The Forward Search Value Iteration algorithm is described in: Shani, G., Brafman, R. I., &amp; Shimony, S. E. (2007, January). Forward Search Value Iteration for POMDPs\n\n    The training consist in two steps:\n\n    - Expand: Where belief points are explored based on the some strategy (to be defined by subclasses).\n\n    - Backup: Using the generated belief points, the value function is updated.\n\n    The belief points are probability distributions over the state space and are therefore vectors of |S| elements.\n\n    Actions are chosen based on a value function. A value function is a set of alpha vectors of dimentionality |S|.\n    Each alpha vector is associated to a single action but multiple alpha vectors can be associated to the same action.\n    To choose an action at a given belief point, a dot product is taken between each alpha vector and the belief point and the action associated with the highest result is chosen.\n\n    Forward Search exploration concept:\n    It relies of the solution of the Fully-Observable (MDP) problem to guide the exploration of belief points.\n    It makes an agent start randomly in the environment and makes him take steps following the MDP solution while generating belief points along the way.\n    Each time the expand function is called it starts generated a new set of belief points and the update function uses only the latest generated belief points to make update the value function.\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment to train the agent with.\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.\n    seed : int, default=12131415\n        For reproducible randomness.\n    model : Model, optional\n        A POMDP model to use to represent the olfactory environment.\n        If not provided, the environment_converter parameter will be used.\n    environment_converter : Callable, default=exact_converter\n        A function to convert the olfactory environment instance to a POMDP Model instance.\n        By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model.\n        This parameter will be ignored if the model parameter is provided.\n    converter_parameters : dict, optional\n        A set of additional parameters to be passed down to the environment converter.\n\n    Attributes\n    ---------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    model : pomdp.Model\n        The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.\n    saved_at : str\n        The place on disk where the agent has been saved (None if not saved yet).\n    on_gpu : bool\n        Whether the agent has been sent to the gpu or not.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    trained_at : str\n        A string timestamp of when the agent has been trained (None if not trained yet).\n    value_function : ValueFunction\n        The value function used for the agent to make decisions.\n    belief : BeliefSet\n        Used only during simulations.\n        Part of the Agent's status. Where the agent believes he is over the state space.\n        It is a list of n belief points based on how many simulations are running at once.\n    action_played : list[int]\n        Used only during simulations.\n        Part of the Agent's status. Records what action was last played by the agent.\n        A list of n actions played based on how many simulations are running at once.\n    mdp_policy : ValueFunction\n        The solution to the fully version of the problem.\n    '''\n    # FSVI special attribute\n    mdp_policy = None\n\n    def expand(self,\n               belief_set: BeliefSet,\n               value_function: ValueFunction,\n               max_generation: int,\n               mdp_policy: ValueFunction\n               ) -&gt; BeliefSet:\n        '''\n        Function implementing the exploration process using the MDP policy in order to generate a sequence of Beliefs following the the Forward Search Value Iteration principles.\n        It is a loop is started by a initial state 's' and using the MDP policy, chooses the best action to take.\n        Following this, a random next state 's_p' is being sampled from the transition probabilities and a random observation 'o' based on the observation probabilities.\n        Then the given belief is updated using the chosen action and the observation received and the updated belief is added to the sequence.\n        Once the state is a goal state, the loop is done and the belief sequence is returned.\n\n        Parameters\n        ----------\n        belief_set : BeliefSet\n            A belief set containing a single belief to start the sequence with.\n            A random state will be chosen based on the probability distribution of the belief.\n        value_function : ValueFunction\n            The current value function. (NOT USED)\n        max_generation : int\n            How many beliefs to be generated at most.\n        mdp_policy : ValueFunction\n            The mdp policy used to choose the action from with the given state 's'.\n\n        Returns\n        -------\n        belief_set : BeliefSet\n            A new sequence of beliefs.\n        '''\n        # GPU support\n        xp = np if not self.on_gpu else cp\n        model = self.model\n\n        # Getting initial belief\n        b0 = belief_set.belief_list[0]\n        belief_list = [b0]\n\n        # Choose a random starting state\n        s = b0.random_state()\n\n        # Setting the working belief\n        b = b0\n\n        for _ in range(max_generation - 1): #-1 due to a one belief already being present in the set\n            # Choose action based on mdp value function\n            a_star = xp.argmax(mdp_policy.alpha_vector_array[:,s])\n\n            # Pick a random next state (weighted by transition probabilities)\n            s_p = model.transition(s, a_star)\n\n            # Pick a random observation weighted by observation probabilities in state s_p and after having done action a_star\n            o = model.observe(s_p, a_star)\n\n            # Generate a new belief based on a_star and o\n            b_p = b.update(a_star, o)\n\n            # Record new belief\n            belief_list.append(b_p)\n\n            # Updating s and b\n            s = s_p\n            b = b_p\n\n            # Reset and belief if end state is reached\n            if s in model.end_states:\n                s = b0.random_state()\n                b = b0\n\n        return BeliefSet(model, belief_list)\n\n\n    def train(self,\n              expansions: int,\n              update_passes: int = 1,\n              max_belief_growth: int = 10,\n              initial_belief: BeliefSet | Belief | None = None,\n              initial_value_function: ValueFunction | None = None,\n              mdp_policy: ValueFunction | None = None,\n              prune_level: int = 1,\n              prune_interval: int = 10,\n              limit_value_function_size: int = -1,\n              gamma: float = 0.99,\n              eps: float = 1e-6,\n              use_gpu: bool = False,\n              history_tracking_level: int = 1,\n              overwrite_training: bool = False,\n              print_progress: bool = True,\n              print_stats: bool = True\n              ) -&gt; TrainingHistory:\n        '''\n        Main loop of the Point-Based Value Iteration algorithm.\n        It consists in 2 steps, Backup and Expand.\n        1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n        2. Backup: Updates the alpha vectors based on the current belief set\n\n        Foward Search Value Iteration:\n        - By default it performs the backup only on set of beliefs generated by the expand function. (so it full_backup=False)\n\n        Parameters\n        ----------\n        expansions : int\n            How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n        update_passes : int, default=1\n            How many times the backup function has to be run every time the belief set is expanded.\n        max_belief_growth : int, default=10\n            How many beliefs can be added at every expansion step to the belief set.\n        initial_belief : BeliefSet or Belief, optional\n            An initial list of beliefs to start with.\n        initial_value_function : ValueFunction, optional\n            An initial value function to start the solving process with.\n        mdp_policy : ValueFunction, optional\n            The MDP solution to guide the expand process.\n            If it is not provided, the Value Iteration for the MDP version of the problem will be run. (using the same gamma and eps as set here; horizon=1000)\n        prune_level : int, default=1\n            Parameter to prune the value function further before the expand function.\n        prune_interval : int, default=10\n            How often to prune the value function. It is counted in number of backup iterations.\n        limit_value_function_size : int, default=-1\n            When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n            If set to -1, the value function can grow without bounds.\n        use_gpu : bool, default=False\n            Whether to use the GPU with cupy array to accelerate solving.\n        gamma : float, default=0.99\n            The discount factor to value immediate rewards more than long term rewards.\n            The learning rate is 1/gamma.\n        eps : float, default=1e-6\n            The smallest allowed changed for the value function.\n            Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n        history_tracking_level : int, default=1\n            How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n        overwrite_training : bool, default=False\n            Whether to force the overwriting of the training if a value function already exists for this agent.\n        print_progress : bool, default=True\n            Whether or not to print out the progress of the value iteration process.\n        print_stats : bool, default=True\n            Whether or not to print out statistics at the end of the training run.\n\n        Returns\n        -------\n        solver_history : SolverHistory\n            The history of the solving process with some plotting options.\n        '''\n        if mdp_policy is not None:\n            self.mdp_policy = mdp_policy\n        elif (self.mdp_policy is None) or overwrite_training:\n            log('MDP_policy, not provided. Solving MDP with Value Iteration...')\n            self.mdp_policy, hist = vi_solver.solve(model = self.model,\n                                                    horizon = 1000,\n                                                    initial_value_function = initial_value_function,\n                                                    gamma = gamma,\n                                                    eps = eps,\n                                                    use_gpu = use_gpu,\n                                                    history_tracking_level = 1,\n                                                    print_progress = print_progress)\n\n            if print_stats:\n                print(hist.summary)\n\n        return super().train(expansions = expansions,\n                             full_backup = False,\n                             update_passes = update_passes,\n                             max_belief_growth = max_belief_growth,\n                             initial_belief = initial_belief,\n                             initial_value_function = initial_value_function,\n                             prune_level = prune_level,\n                             prune_interval = prune_interval,\n                             limit_value_function_size = limit_value_function_size,\n                             gamma = gamma,\n                             eps = eps,\n                             use_gpu = use_gpu,\n                             history_tracking_level = history_tracking_level,\n                             overwrite_training = overwrite_training,\n                             print_progress = print_progress,\n                             print_stats = print_stats,\n                             mdp_policy = self.mdp_policy)\n</code></pre>"},{"location":"reference/agents/fsvi_agent/#olfactory_navigation.agents.fsvi_agent.FSVI_Agent.expand","title":"<code>expand(belief_set, value_function, max_generation, mdp_policy)</code>","text":"<p>Function implementing the exploration process using the MDP policy in order to generate a sequence of Beliefs following the the Forward Search Value Iteration principles. It is a loop is started by a initial state 's' and using the MDP policy, chooses the best action to take. Following this, a random next state 's_p' is being sampled from the transition probabilities and a random observation 'o' based on the observation probabilities. Then the given belief is updated using the chosen action and the observation received and the updated belief is added to the sequence. Once the state is a goal state, the loop is done and the belief sequence is returned.</p> <p>Parameters:</p> Name Type Description Default <code>belief_set</code> <code>BeliefSet</code> <p>A belief set containing a single belief to start the sequence with. A random state will be chosen based on the probability distribution of the belief.</p> required <code>value_function</code> <code>ValueFunction</code> <p>The current value function. (NOT USED)</p> required <code>max_generation</code> <code>int</code> <p>How many beliefs to be generated at most.</p> required <code>mdp_policy</code> <code>ValueFunction</code> <p>The mdp policy used to choose the action from with the given state 's'.</p> required <p>Returns:</p> Name Type Description <code>belief_set</code> <code>BeliefSet</code> <p>A new sequence of beliefs.</p> Source code in <code>olfactory_navigation/agents/fsvi_agent.py</code> <pre><code>def expand(self,\n           belief_set: BeliefSet,\n           value_function: ValueFunction,\n           max_generation: int,\n           mdp_policy: ValueFunction\n           ) -&gt; BeliefSet:\n    '''\n    Function implementing the exploration process using the MDP policy in order to generate a sequence of Beliefs following the the Forward Search Value Iteration principles.\n    It is a loop is started by a initial state 's' and using the MDP policy, chooses the best action to take.\n    Following this, a random next state 's_p' is being sampled from the transition probabilities and a random observation 'o' based on the observation probabilities.\n    Then the given belief is updated using the chosen action and the observation received and the updated belief is added to the sequence.\n    Once the state is a goal state, the loop is done and the belief sequence is returned.\n\n    Parameters\n    ----------\n    belief_set : BeliefSet\n        A belief set containing a single belief to start the sequence with.\n        A random state will be chosen based on the probability distribution of the belief.\n    value_function : ValueFunction\n        The current value function. (NOT USED)\n    max_generation : int\n        How many beliefs to be generated at most.\n    mdp_policy : ValueFunction\n        The mdp policy used to choose the action from with the given state 's'.\n\n    Returns\n    -------\n    belief_set : BeliefSet\n        A new sequence of beliefs.\n    '''\n    # GPU support\n    xp = np if not self.on_gpu else cp\n    model = self.model\n\n    # Getting initial belief\n    b0 = belief_set.belief_list[0]\n    belief_list = [b0]\n\n    # Choose a random starting state\n    s = b0.random_state()\n\n    # Setting the working belief\n    b = b0\n\n    for _ in range(max_generation - 1): #-1 due to a one belief already being present in the set\n        # Choose action based on mdp value function\n        a_star = xp.argmax(mdp_policy.alpha_vector_array[:,s])\n\n        # Pick a random next state (weighted by transition probabilities)\n        s_p = model.transition(s, a_star)\n\n        # Pick a random observation weighted by observation probabilities in state s_p and after having done action a_star\n        o = model.observe(s_p, a_star)\n\n        # Generate a new belief based on a_star and o\n        b_p = b.update(a_star, o)\n\n        # Record new belief\n        belief_list.append(b_p)\n\n        # Updating s and b\n        s = s_p\n        b = b_p\n\n        # Reset and belief if end state is reached\n        if s in model.end_states:\n            s = b0.random_state()\n            b = b0\n\n    return BeliefSet(model, belief_list)\n</code></pre>"},{"location":"reference/agents/fsvi_agent/#olfactory_navigation.agents.fsvi_agent.FSVI_Agent.train","title":"<code>train(expansions, update_passes=1, max_belief_growth=10, initial_belief=None, initial_value_function=None, mdp_policy=None, prune_level=1, prune_interval=10, limit_value_function_size=-1, gamma=0.99, eps=1e-06, use_gpu=False, history_tracking_level=1, overwrite_training=False, print_progress=True, print_stats=True)</code>","text":"<p>Main loop of the Point-Based Value Iteration algorithm. It consists in 2 steps, Backup and Expand. 1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function 2. Backup: Updates the alpha vectors based on the current belief set</p> <p>Foward Search Value Iteration: - By default it performs the backup only on set of beliefs generated by the expand function. (so it full_backup=False)</p> <p>Parameters:</p> Name Type Description Default <code>expansions</code> <code>int</code> <p>How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)</p> required <code>update_passes</code> <code>int</code> <p>How many times the backup function has to be run every time the belief set is expanded.</p> <code>1</code> <code>max_belief_growth</code> <code>int</code> <p>How many beliefs can be added at every expansion step to the belief set.</p> <code>10</code> <code>initial_belief</code> <code>BeliefSet or Belief</code> <p>An initial list of beliefs to start with.</p> <code>None</code> <code>initial_value_function</code> <code>ValueFunction</code> <p>An initial value function to start the solving process with.</p> <code>None</code> <code>mdp_policy</code> <code>ValueFunction</code> <p>The MDP solution to guide the expand process. If it is not provided, the Value Iteration for the MDP version of the problem will be run. (using the same gamma and eps as set here; horizon=1000)</p> <code>None</code> <code>prune_level</code> <code>int</code> <p>Parameter to prune the value function further before the expand function.</p> <code>1</code> <code>prune_interval</code> <code>int</code> <p>How often to prune the value function. It is counted in number of backup iterations.</p> <code>10</code> <code>limit_value_function_size</code> <code>int</code> <p>When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function If set to -1, the value function can grow without bounds.</p> <code>-1</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU with cupy array to accelerate solving.</p> <code>False</code> <code>gamma</code> <code>float</code> <p>The discount factor to value immediate rewards more than long term rewards. The learning rate is 1/gamma.</p> <code>0.99</code> <code>eps</code> <code>float</code> <p>The smallest allowed changed for the value function. Bellow the amound of change, the value function is considered converged and the value iteration process will end early.</p> <code>1e-6</code> <code>history_tracking_level</code> <code>int</code> <p>How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)</p> <code>1</code> <code>overwrite_training</code> <code>bool</code> <p>Whether to force the overwriting of the training if a value function already exists for this agent.</p> <code>False</code> <code>print_progress</code> <code>bool</code> <p>Whether or not to print out the progress of the value iteration process.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether or not to print out statistics at the end of the training run.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>solver_history</code> <code>SolverHistory</code> <p>The history of the solving process with some plotting options.</p> Source code in <code>olfactory_navigation/agents/fsvi_agent.py</code> <pre><code>def train(self,\n          expansions: int,\n          update_passes: int = 1,\n          max_belief_growth: int = 10,\n          initial_belief: BeliefSet | Belief | None = None,\n          initial_value_function: ValueFunction | None = None,\n          mdp_policy: ValueFunction | None = None,\n          prune_level: int = 1,\n          prune_interval: int = 10,\n          limit_value_function_size: int = -1,\n          gamma: float = 0.99,\n          eps: float = 1e-6,\n          use_gpu: bool = False,\n          history_tracking_level: int = 1,\n          overwrite_training: bool = False,\n          print_progress: bool = True,\n          print_stats: bool = True\n          ) -&gt; TrainingHistory:\n    '''\n    Main loop of the Point-Based Value Iteration algorithm.\n    It consists in 2 steps, Backup and Expand.\n    1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n    2. Backup: Updates the alpha vectors based on the current belief set\n\n    Foward Search Value Iteration:\n    - By default it performs the backup only on set of beliefs generated by the expand function. (so it full_backup=False)\n\n    Parameters\n    ----------\n    expansions : int\n        How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n    update_passes : int, default=1\n        How many times the backup function has to be run every time the belief set is expanded.\n    max_belief_growth : int, default=10\n        How many beliefs can be added at every expansion step to the belief set.\n    initial_belief : BeliefSet or Belief, optional\n        An initial list of beliefs to start with.\n    initial_value_function : ValueFunction, optional\n        An initial value function to start the solving process with.\n    mdp_policy : ValueFunction, optional\n        The MDP solution to guide the expand process.\n        If it is not provided, the Value Iteration for the MDP version of the problem will be run. (using the same gamma and eps as set here; horizon=1000)\n    prune_level : int, default=1\n        Parameter to prune the value function further before the expand function.\n    prune_interval : int, default=10\n        How often to prune the value function. It is counted in number of backup iterations.\n    limit_value_function_size : int, default=-1\n        When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n        If set to -1, the value function can grow without bounds.\n    use_gpu : bool, default=False\n        Whether to use the GPU with cupy array to accelerate solving.\n    gamma : float, default=0.99\n        The discount factor to value immediate rewards more than long term rewards.\n        The learning rate is 1/gamma.\n    eps : float, default=1e-6\n        The smallest allowed changed for the value function.\n        Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n    history_tracking_level : int, default=1\n        How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n    overwrite_training : bool, default=False\n        Whether to force the overwriting of the training if a value function already exists for this agent.\n    print_progress : bool, default=True\n        Whether or not to print out the progress of the value iteration process.\n    print_stats : bool, default=True\n        Whether or not to print out statistics at the end of the training run.\n\n    Returns\n    -------\n    solver_history : SolverHistory\n        The history of the solving process with some plotting options.\n    '''\n    if mdp_policy is not None:\n        self.mdp_policy = mdp_policy\n    elif (self.mdp_policy is None) or overwrite_training:\n        log('MDP_policy, not provided. Solving MDP with Value Iteration...')\n        self.mdp_policy, hist = vi_solver.solve(model = self.model,\n                                                horizon = 1000,\n                                                initial_value_function = initial_value_function,\n                                                gamma = gamma,\n                                                eps = eps,\n                                                use_gpu = use_gpu,\n                                                history_tracking_level = 1,\n                                                print_progress = print_progress)\n\n        if print_stats:\n            print(hist.summary)\n\n    return super().train(expansions = expansions,\n                         full_backup = False,\n                         update_passes = update_passes,\n                         max_belief_growth = max_belief_growth,\n                         initial_belief = initial_belief,\n                         initial_value_function = initial_value_function,\n                         prune_level = prune_level,\n                         prune_interval = prune_interval,\n                         limit_value_function_size = limit_value_function_size,\n                         gamma = gamma,\n                         eps = eps,\n                         use_gpu = use_gpu,\n                         history_tracking_level = history_tracking_level,\n                         overwrite_training = overwrite_training,\n                         print_progress = print_progress,\n                         print_stats = print_stats,\n                         mdp_policy = self.mdp_policy)\n</code></pre>"},{"location":"reference/agents/hsvi_agent/","title":"hsvi_agent","text":""},{"location":"reference/agents/hsvi_agent/#olfactory_navigation.agents.hsvi_agent.HSVI_Agent","title":"<code>HSVI_Agent</code>","text":"<p>               Bases: <code>PBVI_Agent</code></p> <p>A flavor of the PBVI Agent.</p>"},{"location":"reference/agents/hsvi_agent/#olfactory_navigation.agents.hsvi_agent.HSVI_Agent--todo-do-document-of-hsvi-agent","title":"TODO: Do document of HSVI agent","text":""},{"location":"reference/agents/hsvi_agent/#olfactory_navigation.agents.hsvi_agent.HSVI_Agent--todo-fix-hsvi-expand","title":"TODO: FIX HSVI expand","text":"<p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment to train the agent with.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.</p> <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <code>model</code> <code>Model</code> <p>A POMDP model to use to represent the olfactory environment. If not provided, the environment_converter parameter will be used.</p> <code>None</code> <code>environment_converter</code> <code>Callable</code> <p>A function to convert the olfactory environment instance to a POMDP Model instance. By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model. This parameter will be ignored if the model parameter is provided.</p> <code>exact_converter</code> <code>converter_parameters</code> <code>dict</code> <p>A set of additional parameters to be passed down to the environment converter.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>model</code> <code>Model</code> <p>The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.</p> <code>saved_at</code> <code>str</code> <p>The place on disk where the agent has been saved (None if not saved yet).</p> <code>on_gpu</code> <code>bool</code> <p>Whether the agent has been sent to the gpu or not.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>trained_at</code> <code>str</code> <p>A string timestamp of when the agent has been trained (None if not trained yet).</p> <code>value_function</code> <code>ValueFunction</code> <p>The value function used for the agent to make decisions.</p> <code>belief</code> <code>BeliefSet</code> <p>Used only during simulations. Part of the Agent's status. Where the agent believes he is over the state space. It is a list of n belief points based on how many simulations are running at once.</p> <code>action_played</code> <code>list[int]</code> <p>Used only during simulations. Part of the Agent's status. Records what action was last played by the agent. A list of n actions played based on how many simulations are running at once.</p> Source code in <code>olfactory_navigation/agents/hsvi_agent.py</code> <pre><code>class HSVI_Agent(PBVI_Agent):\n    '''\n    A flavor of the PBVI Agent.\n\n    # TODO: Do document of HSVI agent\n    # TODO: FIX HSVI expand\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment to train the agent with.\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.\n    seed : int, default=12131415\n        For reproducible randomness.\n    model : Model, optional\n        A POMDP model to use to represent the olfactory environment.\n        If not provided, the environment_converter parameter will be used.\n    environment_converter : Callable, default=exact_converter\n        A function to convert the olfactory environment instance to a POMDP Model instance.\n        By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model.\n        This parameter will be ignored if the model parameter is provided.\n    converter_parameters : dict, optional\n        A set of additional parameters to be passed down to the environment converter.\n\n    Attributes\n    ---------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    model : pomdp.Model\n        The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.\n    saved_at : str\n        The place on disk where the agent has been saved (None if not saved yet).\n    on_gpu : bool\n        Whether the agent has been sent to the gpu or not.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    trained_at : str\n        A string timestamp of when the agent has been trained (None if not trained yet).\n    value_function : ValueFunction\n        The value function used for the agent to make decisions.\n    belief : BeliefSet\n        Used only during simulations.\n        Part of the Agent's status. Where the agent believes he is over the state space.\n        It is a list of n belief points based on how many simulations are running at once.\n    action_played : list[int]\n        Used only during simulations.\n        Part of the Agent's status. Records what action was last played by the agent.\n        A list of n actions played based on how many simulations are running at once.\n    '''\n    def expand(self,\n               belief_set: BeliefSet,\n               value_function: ValueFunction,\n               max_generation: int\n               ) -&gt; BeliefSet:\n        '''\n        The expand function of the  Heuristic Search Value Iteration (HSVI) technique.\n        It is a redursive function attempting to minimize the bound between the upper and lower estimations of the value function.\n\n        It is developped by Smith T. and Simmons R. and described in the paper \"Heuristic Search Value Iteration for POMDPs\".\n\n        Parameters\n        ----------\n        belief_set : BeliefSet\n            List of beliefs to expand on.\n        value_function : ValueFunction\n            The current value function. Used to compute the value at belief points.\n        max_generation : int, default=10\n            The max amount of beliefs that can be added to the belief set at once.\n\n        Returns\n        -------\n        belief_set : BeliefSet\n            A new sequence of beliefs.\n        '''\n        # GPU support\n        xp = np if not self.on_gpu else cp\n        model = self.model\n\n        if conv_term is None:\n            conv_term = self.eps\n\n        # Update convergence term\n        conv_term /= self.gamma\n\n        # Find best a based on upper bound v\n        max_qv = -xp.inf\n        best_a = -1\n        for a in model.actions:\n            b_probs = xp.einsum('sor,s-&gt;o', model.reachable_transitional_observation_table[:,a,:,:], b.values)\n\n            b_prob_val = 0\n            for o in model.observations:\n                b_prob_val += (b_probs[o] * upper_bound_belief_value_map.evaluate(b.update(a,o)))\n\n            qva = float(xp.dot(model.expected_rewards_table[:,a], b.values) + (self.gamma * b_prob_val))\n\n            # qva = upper_bound_belief_value_map.qva(b, a, gamma=self.gamma)\n            if qva &gt; max_qv:\n                max_qv = qva\n                best_a = a\n\n        # Choose o that max gap between bounds\n        b_probs = xp.einsum('sor,s-&gt;o', model.reachable_transitional_observation_table[:,best_a,:,:], b.values)\n\n        max_o_val = -xp.inf\n        best_v_diff = -xp.inf\n        next_b = b\n\n        for o in model.observations:\n            bao = b.update(best_a, o)\n\n            upper_v_bao = upper_bound_belief_value_map.evaluate(bao)\n            lower_v_bao = xp.max(xp.dot(value_function.alpha_vector_array, bao.values))\n\n            v_diff = (upper_v_bao - lower_v_bao)\n\n            o_val = b_probs[o] * v_diff\n\n            if o_val &gt; max_o_val:\n                max_o_val = o_val\n                best_v_diff = v_diff\n                next_b = bao\n\n        # if bounds_split &lt; conv_term or max_generation &lt;= 0:\n        if best_v_diff &lt; conv_term or max_generation &lt;= 1:\n            return BeliefSet(model, [next_b])\n\n        # Add the belief point and associated value to the belief-value mapping\n        upper_bound_belief_value_map.add(b, max_qv)\n\n        # Go one step deeper in the recursion\n        b_set = self.expand_hsvi(model=model,\n                                 b=next_b,\n                                 value_function=value_function,\n                                 upper_bound_belief_value_map=upper_bound_belief_value_map,\n                                 conv_term=conv_term,\n                                 max_generation=max_generation-1)\n\n        # Append the nex belief of this iteration to the deeper beliefs\n        new_belief_list = b_set.belief_list\n        new_belief_list.append(next_b)\n\n        return BeliefSet(model, new_belief_list)\n\n\n    def train(self,\n              expansions: int,\n              update_passes: int = 1,\n              max_belief_growth: int = 10,\n              initial_belief: BeliefSet | Belief | None = None,\n              initial_value_function: ValueFunction | None = None,\n              prune_level: int = 1,\n              prune_interval: int = 10,\n              limit_value_function_size: int = -1,\n              gamma: float = 0.99,\n              eps: float = 1e-6,\n              use_gpu: bool = False,\n              history_tracking_level: int = 1,\n              overwrite_training: bool = False,\n              print_progress: bool = True,\n              print_stats: bool = True\n              ) -&gt; TrainingHistory:\n        '''\n        Main loop of the Point-Based Value Iteration algorithm.\n        It consists in 2 steps, Backup and Expand.\n        1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n        2. Backup: Updates the alpha vectors based on the current belief set\n\n        Heuristic Search Value Iteration:\n        - By default it performs the backup only on set of beliefs generated by the expand function. (so it full_backup=False)\n\n        Parameters\n        ----------\n        expansions : int\n            How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n        update_passes : int, default=1\n            How many times the backup function has to be run every time the belief set is expanded.\n        max_belief_growth : int, default=10\n            How many beliefs can be added at every expansion step to the belief set.\n        initial_belief : BeliefSet or Belief, optional\n            An initial list of beliefs to start with.\n        initial_value_function : ValueFunction, optional\n            An initial value function to start the solving process with.\n        prune_level : int, default=1\n            Parameter to prune the value function further before the expand function.\n        prune_interval : int, default=10\n            How often to prune the value function. It is counted in number of backup iterations.\n        limit_value_function_size : int, default=-1\n            When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n            If set to -1, the value function can grow without bounds.\n        use_gpu : bool, default=False\n            Whether to use the GPU with cupy array to accelerate solving.\n        gamma : float, default=0.99\n            The discount factor to value immediate rewards more than long term rewards.\n            The learning rate is 1/gamma.\n        eps : float, default=1e-6\n            The smallest allowed changed for the value function.\n            Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n        history_tracking_level : int, default=1\n            How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n        overwrite_training : bool, default=False\n            Whether to force the overwriting of the training if a value function already exists for this agent.\n        print_progress : bool, default=True\n            Whether or not to print out the progress of the value iteration process.\n        print_stats : bool, default=True\n            Whether or not to print out statistics at the end of the training run.\n\n        Returns\n        -------\n        solver_history : SolverHistory\n            The history of the solving process with some plotting options.\n        '''\n        return super().train(expansions = expansions,\n                             full_backup = False,\n                             update_passes = update_passes,\n                             max_belief_growth = max_belief_growth,\n                             initial_belief = initial_belief,\n                             initial_value_function = initial_value_function,\n                             prune_level = prune_level,\n                             prune_interval = prune_interval,\n                             limit_value_function_size = limit_value_function_size,\n                             gamma = gamma,\n                             eps = eps,\n                             use_gpu = use_gpu,\n                             history_tracking_level = history_tracking_level,\n                             overwrite_training = overwrite_training,\n                             print_progress = print_progress,\n                             print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/hsvi_agent/#olfactory_navigation.agents.hsvi_agent.HSVI_Agent.expand","title":"<code>expand(belief_set, value_function, max_generation)</code>","text":"<p>The expand function of the  Heuristic Search Value Iteration (HSVI) technique. It is a redursive function attempting to minimize the bound between the upper and lower estimations of the value function.</p> <p>It is developped by Smith T. and Simmons R. and described in the paper \"Heuristic Search Value Iteration for POMDPs\".</p> <p>Parameters:</p> Name Type Description Default <code>belief_set</code> <code>BeliefSet</code> <p>List of beliefs to expand on.</p> required <code>value_function</code> <code>ValueFunction</code> <p>The current value function. Used to compute the value at belief points.</p> required <code>max_generation</code> <code>int</code> <p>The max amount of beliefs that can be added to the belief set at once.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>belief_set</code> <code>BeliefSet</code> <p>A new sequence of beliefs.</p> Source code in <code>olfactory_navigation/agents/hsvi_agent.py</code> <pre><code>def expand(self,\n           belief_set: BeliefSet,\n           value_function: ValueFunction,\n           max_generation: int\n           ) -&gt; BeliefSet:\n    '''\n    The expand function of the  Heuristic Search Value Iteration (HSVI) technique.\n    It is a redursive function attempting to minimize the bound between the upper and lower estimations of the value function.\n\n    It is developped by Smith T. and Simmons R. and described in the paper \"Heuristic Search Value Iteration for POMDPs\".\n\n    Parameters\n    ----------\n    belief_set : BeliefSet\n        List of beliefs to expand on.\n    value_function : ValueFunction\n        The current value function. Used to compute the value at belief points.\n    max_generation : int, default=10\n        The max amount of beliefs that can be added to the belief set at once.\n\n    Returns\n    -------\n    belief_set : BeliefSet\n        A new sequence of beliefs.\n    '''\n    # GPU support\n    xp = np if not self.on_gpu else cp\n    model = self.model\n\n    if conv_term is None:\n        conv_term = self.eps\n\n    # Update convergence term\n    conv_term /= self.gamma\n\n    # Find best a based on upper bound v\n    max_qv = -xp.inf\n    best_a = -1\n    for a in model.actions:\n        b_probs = xp.einsum('sor,s-&gt;o', model.reachable_transitional_observation_table[:,a,:,:], b.values)\n\n        b_prob_val = 0\n        for o in model.observations:\n            b_prob_val += (b_probs[o] * upper_bound_belief_value_map.evaluate(b.update(a,o)))\n\n        qva = float(xp.dot(model.expected_rewards_table[:,a], b.values) + (self.gamma * b_prob_val))\n\n        # qva = upper_bound_belief_value_map.qva(b, a, gamma=self.gamma)\n        if qva &gt; max_qv:\n            max_qv = qva\n            best_a = a\n\n    # Choose o that max gap between bounds\n    b_probs = xp.einsum('sor,s-&gt;o', model.reachable_transitional_observation_table[:,best_a,:,:], b.values)\n\n    max_o_val = -xp.inf\n    best_v_diff = -xp.inf\n    next_b = b\n\n    for o in model.observations:\n        bao = b.update(best_a, o)\n\n        upper_v_bao = upper_bound_belief_value_map.evaluate(bao)\n        lower_v_bao = xp.max(xp.dot(value_function.alpha_vector_array, bao.values))\n\n        v_diff = (upper_v_bao - lower_v_bao)\n\n        o_val = b_probs[o] * v_diff\n\n        if o_val &gt; max_o_val:\n            max_o_val = o_val\n            best_v_diff = v_diff\n            next_b = bao\n\n    # if bounds_split &lt; conv_term or max_generation &lt;= 0:\n    if best_v_diff &lt; conv_term or max_generation &lt;= 1:\n        return BeliefSet(model, [next_b])\n\n    # Add the belief point and associated value to the belief-value mapping\n    upper_bound_belief_value_map.add(b, max_qv)\n\n    # Go one step deeper in the recursion\n    b_set = self.expand_hsvi(model=model,\n                             b=next_b,\n                             value_function=value_function,\n                             upper_bound_belief_value_map=upper_bound_belief_value_map,\n                             conv_term=conv_term,\n                             max_generation=max_generation-1)\n\n    # Append the nex belief of this iteration to the deeper beliefs\n    new_belief_list = b_set.belief_list\n    new_belief_list.append(next_b)\n\n    return BeliefSet(model, new_belief_list)\n</code></pre>"},{"location":"reference/agents/hsvi_agent/#olfactory_navigation.agents.hsvi_agent.HSVI_Agent.train","title":"<code>train(expansions, update_passes=1, max_belief_growth=10, initial_belief=None, initial_value_function=None, prune_level=1, prune_interval=10, limit_value_function_size=-1, gamma=0.99, eps=1e-06, use_gpu=False, history_tracking_level=1, overwrite_training=False, print_progress=True, print_stats=True)</code>","text":"<p>Main loop of the Point-Based Value Iteration algorithm. It consists in 2 steps, Backup and Expand. 1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function 2. Backup: Updates the alpha vectors based on the current belief set</p> <p>Heuristic Search Value Iteration: - By default it performs the backup only on set of beliefs generated by the expand function. (so it full_backup=False)</p> <p>Parameters:</p> Name Type Description Default <code>expansions</code> <code>int</code> <p>How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)</p> required <code>update_passes</code> <code>int</code> <p>How many times the backup function has to be run every time the belief set is expanded.</p> <code>1</code> <code>max_belief_growth</code> <code>int</code> <p>How many beliefs can be added at every expansion step to the belief set.</p> <code>10</code> <code>initial_belief</code> <code>BeliefSet or Belief</code> <p>An initial list of beliefs to start with.</p> <code>None</code> <code>initial_value_function</code> <code>ValueFunction</code> <p>An initial value function to start the solving process with.</p> <code>None</code> <code>prune_level</code> <code>int</code> <p>Parameter to prune the value function further before the expand function.</p> <code>1</code> <code>prune_interval</code> <code>int</code> <p>How often to prune the value function. It is counted in number of backup iterations.</p> <code>10</code> <code>limit_value_function_size</code> <code>int</code> <p>When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function If set to -1, the value function can grow without bounds.</p> <code>-1</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU with cupy array to accelerate solving.</p> <code>False</code> <code>gamma</code> <code>float</code> <p>The discount factor to value immediate rewards more than long term rewards. The learning rate is 1/gamma.</p> <code>0.99</code> <code>eps</code> <code>float</code> <p>The smallest allowed changed for the value function. Bellow the amound of change, the value function is considered converged and the value iteration process will end early.</p> <code>1e-6</code> <code>history_tracking_level</code> <code>int</code> <p>How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)</p> <code>1</code> <code>overwrite_training</code> <code>bool</code> <p>Whether to force the overwriting of the training if a value function already exists for this agent.</p> <code>False</code> <code>print_progress</code> <code>bool</code> <p>Whether or not to print out the progress of the value iteration process.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether or not to print out statistics at the end of the training run.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>solver_history</code> <code>SolverHistory</code> <p>The history of the solving process with some plotting options.</p> Source code in <code>olfactory_navigation/agents/hsvi_agent.py</code> <pre><code>def train(self,\n          expansions: int,\n          update_passes: int = 1,\n          max_belief_growth: int = 10,\n          initial_belief: BeliefSet | Belief | None = None,\n          initial_value_function: ValueFunction | None = None,\n          prune_level: int = 1,\n          prune_interval: int = 10,\n          limit_value_function_size: int = -1,\n          gamma: float = 0.99,\n          eps: float = 1e-6,\n          use_gpu: bool = False,\n          history_tracking_level: int = 1,\n          overwrite_training: bool = False,\n          print_progress: bool = True,\n          print_stats: bool = True\n          ) -&gt; TrainingHistory:\n    '''\n    Main loop of the Point-Based Value Iteration algorithm.\n    It consists in 2 steps, Backup and Expand.\n    1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n    2. Backup: Updates the alpha vectors based on the current belief set\n\n    Heuristic Search Value Iteration:\n    - By default it performs the backup only on set of beliefs generated by the expand function. (so it full_backup=False)\n\n    Parameters\n    ----------\n    expansions : int\n        How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n    update_passes : int, default=1\n        How many times the backup function has to be run every time the belief set is expanded.\n    max_belief_growth : int, default=10\n        How many beliefs can be added at every expansion step to the belief set.\n    initial_belief : BeliefSet or Belief, optional\n        An initial list of beliefs to start with.\n    initial_value_function : ValueFunction, optional\n        An initial value function to start the solving process with.\n    prune_level : int, default=1\n        Parameter to prune the value function further before the expand function.\n    prune_interval : int, default=10\n        How often to prune the value function. It is counted in number of backup iterations.\n    limit_value_function_size : int, default=-1\n        When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n        If set to -1, the value function can grow without bounds.\n    use_gpu : bool, default=False\n        Whether to use the GPU with cupy array to accelerate solving.\n    gamma : float, default=0.99\n        The discount factor to value immediate rewards more than long term rewards.\n        The learning rate is 1/gamma.\n    eps : float, default=1e-6\n        The smallest allowed changed for the value function.\n        Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n    history_tracking_level : int, default=1\n        How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n    overwrite_training : bool, default=False\n        Whether to force the overwriting of the training if a value function already exists for this agent.\n    print_progress : bool, default=True\n        Whether or not to print out the progress of the value iteration process.\n    print_stats : bool, default=True\n        Whether or not to print out statistics at the end of the training run.\n\n    Returns\n    -------\n    solver_history : SolverHistory\n        The history of the solving process with some plotting options.\n    '''\n    return super().train(expansions = expansions,\n                         full_backup = False,\n                         update_passes = update_passes,\n                         max_belief_growth = max_belief_growth,\n                         initial_belief = initial_belief,\n                         initial_value_function = initial_value_function,\n                         prune_level = prune_level,\n                         prune_interval = prune_interval,\n                         limit_value_function_size = limit_value_function_size,\n                         gamma = gamma,\n                         eps = eps,\n                         use_gpu = use_gpu,\n                         history_tracking_level = history_tracking_level,\n                         overwrite_training = overwrite_training,\n                         print_progress = print_progress,\n                         print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/infotaxis_agent/","title":"infotaxis_agent","text":""},{"location":"reference/agents/infotaxis_agent/#olfactory_navigation.agents.infotaxis_agent.Infotaxis_Agent","title":"<code>Infotaxis_Agent</code>","text":"<p>               Bases: <code>Agent</code></p> <p>An agent following the Infotaxis principle. It is a Model-Based approach that aims to make steps towards where the agent has the greatest likelihood to minimize the entropy of the belief. The belief is (as for the PBVI agent) a probability distribution over the state space of how much the agent is to be confident in each state. The technique was developped and described in the following article: Vergassola, M., Villermaux, E., &amp; Shraiman, B. I. (2007). 'Infotaxis' as a strategy for searching without gradients.</p> <p>It does not need to be trained to the train(), save() and load() function are not implemented.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment to train the agent with.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.</p> <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <code>model</code> <code>Model</code> <p>A POMDP model to use to represent the olfactory environment. If not provided, the environment_converter parameter will be used.</p> <code>None</code> <code>environment_converter</code> <code>Callable</code> <p>A function to convert the olfactory environment instance to a POMDP Model instance. By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model. This parameter will be ignored if the model parameter is provided.</p> <code>exact_converter</code> <code>converter_parameters</code> <code>dict</code> <p>A set of additional parameters to be passed down to the environment converter.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>model</code> <code>Model</code> <p>The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.</p> <code>saved_at</code> <code>str</code> <p>The place on disk where the agent has been saved (None if not saved yet).</p> <code>on_gpu</code> <code>bool</code> <p>Whether the agent has been sent to the gpu or not.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>belief</code> <code>BeliefSet</code> <p>Used only during simulations. Part of the Agent's status. Where the agent believes he is over the state space. It is a list of n belief points based on how many simulations are running at once.</p> <code>action_played</code> <code>list[int]</code> <p>Used only during simulations. Part of the Agent's status. Records what action was last played by the agent. A list of n actions played based on how many simulations are running at once.</p> Source code in <code>olfactory_navigation/agents/infotaxis_agent.py</code> <pre><code>class Infotaxis_Agent(Agent):\n    '''\n    An agent following the Infotaxis principle.\n    It is a Model-Based approach that aims to make steps towards where the agent has the greatest likelihood to minimize the entropy of the belief.\n    The belief is (as for the PBVI agent) a probability distribution over the state space of how much the agent is to be confident in each state.\n    The technique was developped and described in the following article: Vergassola, M., Villermaux, E., &amp; Shraiman, B. I. (2007). 'Infotaxis' as a strategy for searching without gradients.\n\n    It does not need to be trained to the train(), save() and load() function are not implemented.\n\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment to train the agent with.\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.\n    seed : int, default=12131415\n        For reproducible randomness.\n    model : Model, optional\n        A POMDP model to use to represent the olfactory environment.\n        If not provided, the environment_converter parameter will be used.\n    environment_converter : Callable, default=exact_converter\n        A function to convert the olfactory environment instance to a POMDP Model instance.\n        By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model.\n        This parameter will be ignored if the model parameter is provided.\n    converter_parameters : dict, optional\n        A set of additional parameters to be passed down to the environment converter.\n\n    Attributes\n    ---------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    model : pomdp.Model\n        The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.\n    saved_at : str\n        The place on disk where the agent has been saved (None if not saved yet).\n    on_gpu : bool\n        Whether the agent has been sent to the gpu or not.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    belief : BeliefSet\n        Used only during simulations.\n        Part of the Agent's status. Where the agent believes he is over the state space.\n        It is a list of n belief points based on how many simulations are running at once.\n    action_played : list[int]\n        Used only during simulations.\n        Part of the Agent's status. Records what action was last played by the agent.\n        A list of n actions played based on how many simulations are running at once.\n    '''\n    def __init__(self,\n                 environment: Environment,\n                 thresholds: float | list[float] | dict[str, float] | dict[str, list[float]] = 3e-6,\n                 space_aware: bool = False,\n                 spacial_subdivisions: np.ndarray | None = None,\n                 actions: dict[str, np.ndarray] | np.ndarray | None = None,\n                 name: str | None=None,\n                 seed: int = 12131415,\n                 model: Model | None = None,\n                 environment_converter: Callable | None = None,\n                 **converter_parameters\n                 ) -&gt; None:\n        super().__init__(\n            environment = environment,\n            thresholds = thresholds,\n            space_aware = space_aware,\n            spacial_subdivisions = spacial_subdivisions,\n            actions = actions,\n            name = name,\n            seed = seed\n        )\n\n        # Converting the olfactory environment to a POMDP Model\n        if model is not None:\n            loaded_model = model\n        elif callable(environment_converter):\n            loaded_model = environment_converter(agent=self, **converter_parameters)\n        else:\n            # Using the exact converter\n            loaded_model = exact_converter(agent=self)\n        self.model:Model = loaded_model\n\n        # Status variables\n        self.belief = None\n        self.action_played = None\n\n\n    def to_gpu(self) -&gt; Agent:\n        '''\n        Function to send the numpy arrays of the agent to the gpu.\n        It returns a new instance of the Agent class with the arrays on the gpu.\n\n        Returns\n        -------\n        gpu_agent\n        '''\n        # Check whether the agent is already on the gpu or not\n        if self.on_gpu:\n            return self\n\n        # Warn and overwrite alternate_version in case it already exists\n        if self._alternate_version is not None:\n            print('[warning] A GPU instance already existed and is being recreated.')\n            self._alternate_version = None\n\n        assert gpu_support, \"GPU support is not enabled, Cupy might need to be installed...\"\n\n        # Generating a new instance\n        cls = self.__class__\n        gpu_agent = cls.__new__(cls)\n\n        # Copying arguments to gpu\n        for arg, val in self.__dict__.items():\n            if isinstance(val, np.ndarray):\n                setattr(gpu_agent, arg, cp.array(val))\n            elif arg == 'rnd_state':\n                setattr(gpu_agent, arg, cp.random.RandomState(self.seed))\n            elif isinstance(val, Model):\n                setattr(gpu_agent, arg, val.gpu_model)\n            elif isinstance(val, BeliefSet) or isinstance(val, Belief):\n                setattr(gpu_agent, arg, val.to_gpu())\n            else:\n                setattr(gpu_agent, arg, val)\n\n        # Self reference instances\n        self._alternate_version = gpu_agent\n        gpu_agent._alternate_version = self\n\n        gpu_agent.on_gpu = True\n        return gpu_agent\n\n\n    def initialize_state(self,\n                         n: int = 1,\n                         belief: BeliefSet | None = None\n                         ) -&gt; None:\n        '''\n        To use an agent within a simulation, the agent's state needs to be initialized.\n        The initialization consists of setting the agent's initial belief.\n        Multiple agents can be used at once for simulations, for this reason, the belief parameter is a BeliefSet by default.\n\n        Parameters\n        ----------\n        n : int, default=1\n            How many agents are to be used during the simulation.\n        belief : BeliefSet, optional\n            An optional set of beliefs to initialize the simulations with.\n        '''\n        if belief is None:\n            self.belief = BeliefSet(self.model, [Belief(self.model) for _ in range(n)])\n        else:\n            assert len(belief) == n, f\"The amount of beliefs provided ({len(belief)}) to initialize the state need to match the amount of stimulations to initialize (n={n}).\"\n\n            if self.on_gpu and not belief.is_on_gpu:\n                self.belief = belief.to_gpu()\n            elif not self.on_gpu and belief.is_on_gpu:\n                self.belief = belief.to_cpu()\n            else:\n                self.belief = belief\n\n\n    def choose_action(self) -&gt; np.ndarray:\n        '''\n        Function to let the agent or set of agents choose an action based on their current belief.\n        Following the Infotaxis principle, it will choose an action that will minimize the sum of next entropies.\n\n        Returns\n        -------\n        movement_vector : np.ndarray\n            A single or a list of actions chosen by the agent(s) based on their belief.\n        '''\n        xp = np if not self.on_gpu else cp\n\n        n = len(self.belief)\n\n        best_entropy = xp.ones(n) * -1\n        best_action = xp.ones(n, dtype=int) * -1\n\n        current_entropy = self.belief.entropies\n\n        for a in self.model.actions:\n            total_entropy = xp.zeros(n)\n\n            for o in self.model.observations:\n                b_ao = self.belief.update(actions=xp.ones(n, dtype=int)*a,\n                                           observations=xp.ones(n, dtype=int)*o,\n                                           throw_error=False)\n\n                # Computing entropy\n                with warnings.catch_warnings():\n                    warnings.simplefilter('ignore')\n                    b_ao_entropy = b_ao.entropies\n\n                b_prob = xp.dot(self.belief.belief_array, xp.sum(self.model.reachable_transitional_observation_table[:,a,o,:], axis=1))\n\n                total_entropy += (b_prob * (current_entropy - b_ao_entropy))\n\n            # Checking if action is superior to previous best\n            superiority_mask = best_entropy &lt; total_entropy\n            best_action[superiority_mask] = a\n            best_entropy[superiority_mask] = total_entropy[superiority_mask]\n\n        # Recording the action played\n        self.action_played = best_action\n\n        # Converting action indexes to movement vectors\n        movemement_vector = self.action_set[best_action,:]\n\n        return movemement_vector\n\n\n    def update_state(self,\n                     action: np.ndarray,\n                     observation: np.ndarray,\n                     source_reached: np.ndarray\n                     ) -&gt; None | np.ndarray:\n        '''\n        Function to update the internal state(s) of the agent(s) based on the previous action(s) taken and the observation(s) received.\n\n        Parameters\n        ----------\n        action : np.ndarray\n            A 2D array of n movement vectors. If the environment is layered, the 1st component should be the layer.\n        observation : np.ndarray\n            The observation(s) the agent(s) made.\n        source_reached : np.ndarray\n            A boolean array of whether the agent(s) have reached the source or not.\n\n        Returns\n        -------\n        update_successfull : np.ndarray, optional\n            If nothing is returned, it means all the agent's state updates have been successfull.\n            Else, a boolean np.ndarray of size n can be returned confirming for each agent whether the update has been successful or not.\n        '''\n        assert self.belief is not None, \"Agent was not initialized yet, run the initialize_state function first\"\n\n\n        # Discretizing observations\n        observation_ids = self.discretize_observations(observation=observation, action=action, source_reached=source_reached)\n\n        # Update the set of belief\n        self.belief = self.belief.update(actions=self.action_played, observations=observation_ids)\n\n        # Check for failed updates\n        update_successful = (self.belief.belief_array.sum(axis=1) != 0.0)\n\n        return update_successful\n\n\n    def kill(self,\n             simulations_to_kill: np.ndarray\n             ) -&gt; None:\n        '''\n        Function to kill any simulations that have not reached the source but can't continue further\n\n        Parameters\n        ----------\n        simulations_to_kill : np.ndarray\n            A boolean array of the simulations to kill.\n        '''\n        if all(simulations_to_kill):\n            self.belief = None\n        else:\n            self.belief = BeliefSet(self.belief.model, self.belief.belief_array[~simulations_to_kill])\n</code></pre>"},{"location":"reference/agents/infotaxis_agent/#olfactory_navigation.agents.infotaxis_agent.Infotaxis_Agent.choose_action","title":"<code>choose_action()</code>","text":"<p>Function to let the agent or set of agents choose an action based on their current belief. Following the Infotaxis principle, it will choose an action that will minimize the sum of next entropies.</p> <p>Returns:</p> Name Type Description <code>movement_vector</code> <code>ndarray</code> <p>A single or a list of actions chosen by the agent(s) based on their belief.</p> Source code in <code>olfactory_navigation/agents/infotaxis_agent.py</code> <pre><code>def choose_action(self) -&gt; np.ndarray:\n    '''\n    Function to let the agent or set of agents choose an action based on their current belief.\n    Following the Infotaxis principle, it will choose an action that will minimize the sum of next entropies.\n\n    Returns\n    -------\n    movement_vector : np.ndarray\n        A single or a list of actions chosen by the agent(s) based on their belief.\n    '''\n    xp = np if not self.on_gpu else cp\n\n    n = len(self.belief)\n\n    best_entropy = xp.ones(n) * -1\n    best_action = xp.ones(n, dtype=int) * -1\n\n    current_entropy = self.belief.entropies\n\n    for a in self.model.actions:\n        total_entropy = xp.zeros(n)\n\n        for o in self.model.observations:\n            b_ao = self.belief.update(actions=xp.ones(n, dtype=int)*a,\n                                       observations=xp.ones(n, dtype=int)*o,\n                                       throw_error=False)\n\n            # Computing entropy\n            with warnings.catch_warnings():\n                warnings.simplefilter('ignore')\n                b_ao_entropy = b_ao.entropies\n\n            b_prob = xp.dot(self.belief.belief_array, xp.sum(self.model.reachable_transitional_observation_table[:,a,o,:], axis=1))\n\n            total_entropy += (b_prob * (current_entropy - b_ao_entropy))\n\n        # Checking if action is superior to previous best\n        superiority_mask = best_entropy &lt; total_entropy\n        best_action[superiority_mask] = a\n        best_entropy[superiority_mask] = total_entropy[superiority_mask]\n\n    # Recording the action played\n    self.action_played = best_action\n\n    # Converting action indexes to movement vectors\n    movemement_vector = self.action_set[best_action,:]\n\n    return movemement_vector\n</code></pre>"},{"location":"reference/agents/infotaxis_agent/#olfactory_navigation.agents.infotaxis_agent.Infotaxis_Agent.initialize_state","title":"<code>initialize_state(n=1, belief=None)</code>","text":"<p>To use an agent within a simulation, the agent's state needs to be initialized. The initialization consists of setting the agent's initial belief. Multiple agents can be used at once for simulations, for this reason, the belief parameter is a BeliefSet by default.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>How many agents are to be used during the simulation.</p> <code>1</code> <code>belief</code> <code>BeliefSet</code> <p>An optional set of beliefs to initialize the simulations with.</p> <code>None</code> Source code in <code>olfactory_navigation/agents/infotaxis_agent.py</code> <pre><code>def initialize_state(self,\n                     n: int = 1,\n                     belief: BeliefSet | None = None\n                     ) -&gt; None:\n    '''\n    To use an agent within a simulation, the agent's state needs to be initialized.\n    The initialization consists of setting the agent's initial belief.\n    Multiple agents can be used at once for simulations, for this reason, the belief parameter is a BeliefSet by default.\n\n    Parameters\n    ----------\n    n : int, default=1\n        How many agents are to be used during the simulation.\n    belief : BeliefSet, optional\n        An optional set of beliefs to initialize the simulations with.\n    '''\n    if belief is None:\n        self.belief = BeliefSet(self.model, [Belief(self.model) for _ in range(n)])\n    else:\n        assert len(belief) == n, f\"The amount of beliefs provided ({len(belief)}) to initialize the state need to match the amount of stimulations to initialize (n={n}).\"\n\n        if self.on_gpu and not belief.is_on_gpu:\n            self.belief = belief.to_gpu()\n        elif not self.on_gpu and belief.is_on_gpu:\n            self.belief = belief.to_cpu()\n        else:\n            self.belief = belief\n</code></pre>"},{"location":"reference/agents/infotaxis_agent/#olfactory_navigation.agents.infotaxis_agent.Infotaxis_Agent.kill","title":"<code>kill(simulations_to_kill)</code>","text":"<p>Function to kill any simulations that have not reached the source but can't continue further</p> <p>Parameters:</p> Name Type Description Default <code>simulations_to_kill</code> <code>ndarray</code> <p>A boolean array of the simulations to kill.</p> required Source code in <code>olfactory_navigation/agents/infotaxis_agent.py</code> <pre><code>def kill(self,\n         simulations_to_kill: np.ndarray\n         ) -&gt; None:\n    '''\n    Function to kill any simulations that have not reached the source but can't continue further\n\n    Parameters\n    ----------\n    simulations_to_kill : np.ndarray\n        A boolean array of the simulations to kill.\n    '''\n    if all(simulations_to_kill):\n        self.belief = None\n    else:\n        self.belief = BeliefSet(self.belief.model, self.belief.belief_array[~simulations_to_kill])\n</code></pre>"},{"location":"reference/agents/infotaxis_agent/#olfactory_navigation.agents.infotaxis_agent.Infotaxis_Agent.to_gpu","title":"<code>to_gpu()</code>","text":"<p>Function to send the numpy arrays of the agent to the gpu. It returns a new instance of the Agent class with the arrays on the gpu.</p> <p>Returns:</p> Type Description <code>gpu_agent</code> Source code in <code>olfactory_navigation/agents/infotaxis_agent.py</code> <pre><code>def to_gpu(self) -&gt; Agent:\n    '''\n    Function to send the numpy arrays of the agent to the gpu.\n    It returns a new instance of the Agent class with the arrays on the gpu.\n\n    Returns\n    -------\n    gpu_agent\n    '''\n    # Check whether the agent is already on the gpu or not\n    if self.on_gpu:\n        return self\n\n    # Warn and overwrite alternate_version in case it already exists\n    if self._alternate_version is not None:\n        print('[warning] A GPU instance already existed and is being recreated.')\n        self._alternate_version = None\n\n    assert gpu_support, \"GPU support is not enabled, Cupy might need to be installed...\"\n\n    # Generating a new instance\n    cls = self.__class__\n    gpu_agent = cls.__new__(cls)\n\n    # Copying arguments to gpu\n    for arg, val in self.__dict__.items():\n        if isinstance(val, np.ndarray):\n            setattr(gpu_agent, arg, cp.array(val))\n        elif arg == 'rnd_state':\n            setattr(gpu_agent, arg, cp.random.RandomState(self.seed))\n        elif isinstance(val, Model):\n            setattr(gpu_agent, arg, val.gpu_model)\n        elif isinstance(val, BeliefSet) or isinstance(val, Belief):\n            setattr(gpu_agent, arg, val.to_gpu())\n        else:\n            setattr(gpu_agent, arg, val)\n\n    # Self reference instances\n    self._alternate_version = gpu_agent\n    gpu_agent._alternate_version = self\n\n    gpu_agent.on_gpu = True\n    return gpu_agent\n</code></pre>"},{"location":"reference/agents/infotaxis_agent/#olfactory_navigation.agents.infotaxis_agent.Infotaxis_Agent.update_state","title":"<code>update_state(action, observation, source_reached)</code>","text":"<p>Function to update the internal state(s) of the agent(s) based on the previous action(s) taken and the observation(s) received.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>ndarray</code> <p>A 2D array of n movement vectors. If the environment is layered, the 1st component should be the layer.</p> required <code>observation</code> <code>ndarray</code> <p>The observation(s) the agent(s) made.</p> required <code>source_reached</code> <code>ndarray</code> <p>A boolean array of whether the agent(s) have reached the source or not.</p> required <p>Returns:</p> Name Type Description <code>update_successfull</code> <code>(ndarray, optional)</code> <p>If nothing is returned, it means all the agent's state updates have been successfull. Else, a boolean np.ndarray of size n can be returned confirming for each agent whether the update has been successful or not.</p> Source code in <code>olfactory_navigation/agents/infotaxis_agent.py</code> <pre><code>def update_state(self,\n                 action: np.ndarray,\n                 observation: np.ndarray,\n                 source_reached: np.ndarray\n                 ) -&gt; None | np.ndarray:\n    '''\n    Function to update the internal state(s) of the agent(s) based on the previous action(s) taken and the observation(s) received.\n\n    Parameters\n    ----------\n    action : np.ndarray\n        A 2D array of n movement vectors. If the environment is layered, the 1st component should be the layer.\n    observation : np.ndarray\n        The observation(s) the agent(s) made.\n    source_reached : np.ndarray\n        A boolean array of whether the agent(s) have reached the source or not.\n\n    Returns\n    -------\n    update_successfull : np.ndarray, optional\n        If nothing is returned, it means all the agent's state updates have been successfull.\n        Else, a boolean np.ndarray of size n can be returned confirming for each agent whether the update has been successful or not.\n    '''\n    assert self.belief is not None, \"Agent was not initialized yet, run the initialize_state function first\"\n\n\n    # Discretizing observations\n    observation_ids = self.discretize_observations(observation=observation, action=action, source_reached=source_reached)\n\n    # Update the set of belief\n    self.belief = self.belief.update(actions=self.action_played, observations=observation_ids)\n\n    # Check for failed updates\n    update_successful = (self.belief.belief_array.sum(axis=1) != 0.0)\n\n    return update_successful\n</code></pre>"},{"location":"reference/agents/pbvi_agent/","title":"pbvi_agent","text":""},{"location":"reference/agents/pbvi_agent/#olfactory_navigation.agents.pbvi_agent.PBVI_Agent","title":"<code>PBVI_Agent</code>","text":"<p>               Bases: <code>Agent</code></p> <p>A generic Point-Based Value Iteration based agent. It relies on Model-Based reinforcement learning as described in: Pineau J. et al, Point-based value iteration: An anytime algorithm for POMDPs The training consist in two steps:</p> <ul> <li> <p>Expand: Where belief points are explored based on the some strategy (to be defined by subclasses).</p> </li> <li> <p>Backup: Using the generated belief points, the value function is updated.</p> </li> </ul> <p>The belief points are probability distributions over the state space and are therefore vectors of |S| elements.</p> <p>Actions are chosen based on a value function. A value function is a set of alpha vectors of dimentionality |S|. Each alpha vector is associated to a single action but multiple alpha vectors can be associated to the same action. To choose an action at a given belief point, a dot product is taken between each alpha vector and the belief point and the action associated with the highest result is chosen.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment to train the agent with.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.</p> <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <code>model</code> <code>Model</code> <p>A POMDP model to use to represent the olfactory environment. If not provided, the environment_converter parameter will be used.</p> <code>None</code> <code>environment_converter</code> <code>Callable</code> <p>A function to convert the olfactory environment instance to a POMDP Model instance. By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model. This parameter will be ignored if the model parameter is provided.</p> <code>exact_converter</code> <code>converter_parameters</code> <code>dict</code> <p>A set of additional parameters to be passed down to the environment converter.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>model</code> <code>Model</code> <p>The environment converted to a POMDP model using the \"from_environment\" constructor of the Model class.</p> <code>saved_at</code> <code>str</code> <p>The place on disk where the agent has been saved (None if not saved yet).</p> <code>on_gpu</code> <code>bool</code> <p>Whether the agent has been sent to the gpu or not.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>trained_at</code> <code>str</code> <p>A string timestamp of when the agent has been trained (None if not trained yet).</p> <code>value_function</code> <code>ValueFunction</code> <p>The value function used for the agent to make decisions.</p> <code>belief</code> <code>BeliefSet</code> <p>Used only during simulations. Part of the Agent's status. Where the agent believes he is over the state space. It is a list of n belief points based on how many simulations are running at once.</p> <code>action_played</code> <code>list[int]</code> <p>Used only during simulations. Part of the Agent's status. Records what action was last played by the agent. A list of n actions played based on how many simulations are running at once.</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>class PBVI_Agent(Agent):\n    '''\n    A generic Point-Based Value Iteration based agent. It relies on Model-Based reinforcement learning as described in: Pineau J. et al, Point-based value iteration: An anytime algorithm for POMDPs\n    The training consist in two steps:\n\n    - Expand: Where belief points are explored based on the some strategy (to be defined by subclasses).\n\n    - Backup: Using the generated belief points, the value function is updated.\n\n    The belief points are probability distributions over the state space and are therefore vectors of |S| elements.\n\n    Actions are chosen based on a value function. A value function is a set of alpha vectors of dimentionality |S|.\n    Each alpha vector is associated to a single action but multiple alpha vectors can be associated to the same action.\n    To choose an action at a given belief point, a dot product is taken between each alpha vector and the belief point and the action associated with the highest result is chosen.\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment to train the agent with.\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.\n    seed : int, default=12131415\n        For reproducible randomness.\n    model : Model, optional\n        A POMDP model to use to represent the olfactory environment.\n        If not provided, the environment_converter parameter will be used.\n    environment_converter : Callable, default=exact_converter\n        A function to convert the olfactory environment instance to a POMDP Model instance.\n        By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model.\n        This parameter will be ignored if the model parameter is provided.\n    converter_parameters : dict, optional\n        A set of additional parameters to be passed down to the environment converter.\n\n    Attributes\n    ---------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    model : Model\n        The environment converted to a POMDP model using the \"from_environment\" constructor of the Model class.\n    saved_at : str\n        The place on disk where the agent has been saved (None if not saved yet).\n    on_gpu : bool\n        Whether the agent has been sent to the gpu or not.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    trained_at : str\n        A string timestamp of when the agent has been trained (None if not trained yet).\n    value_function : ValueFunction\n        The value function used for the agent to make decisions.\n    belief : BeliefSet\n        Used only during simulations.\n        Part of the Agent's status. Where the agent believes he is over the state space.\n        It is a list of n belief points based on how many simulations are running at once.\n    action_played : list[int]\n        Used only during simulations.\n        Part of the Agent's status. Records what action was last played by the agent.\n        A list of n actions played based on how many simulations are running at once.\n    '''\n    def __init__(self,\n                 environment: Environment,\n                 thresholds: float | list[float] | dict[str, float] | dict[str, list[float]] = 3e-6,\n                 space_aware: bool = False,\n                 spacial_subdivisions: np.ndarray | None = None,\n                 actions: dict[str, np.ndarray] | np.ndarray | None = None,\n                 name: str | None = None,\n                 seed: int = 12131415,\n                 model: Model | None = None,\n                 environment_converter: Callable | None = None,\n                 **converter_parameters\n                 ) -&gt; None:\n        super().__init__(\n            environment = environment,\n            thresholds = thresholds,\n            space_aware = space_aware,\n            spacial_subdivisions = spacial_subdivisions,\n            actions = actions,\n            name = name,\n            seed = seed\n        )\n\n        # Converting the olfactory environment to a POMDP Model\n        if model is not None:\n            loaded_model = model\n        elif callable(environment_converter):\n            loaded_model = environment_converter(agent=self, **converter_parameters)\n        else:\n            # Using the exact converter\n            loaded_model = exact_converter(agent=self)\n        self.model:Model = loaded_model\n\n        # Trainable variables\n        self.trained_at = None\n        self.value_function = None\n\n        # Status variables\n        self.belief = None\n        self.action_played = None\n\n\n    def to_gpu(self) -&gt; 'PBVI_Agent':\n        '''\n        Function to send the numpy arrays of the agent to the gpu.\n        It returns a new instance of the Agent class with the arrays on the gpu.\n\n        Returns\n        -------\n        gpu_agent : Agent\n            A copy of the agent with the arrays on the GPU.\n        '''\n        # Check whether the agent is already on the gpu or not\n        if self.on_gpu:\n            return self\n\n        # Warn and overwrite alternate_version in case it already exists\n        if self._alternate_version is not None:\n            print('[warning] A GPU instance already existed and is being recreated.')\n            self._alternate_version = None\n\n        assert gpu_support, \"GPU support is not enabled, Cupy might need to be installed...\"\n\n        # Generating a new instance\n        cls = self.__class__\n        gpu_agent = cls.__new__(cls)\n\n        # Copying arguments to gpu\n        for arg, val in self.__dict__.items():\n            if isinstance(val, np.ndarray):\n                setattr(gpu_agent, arg, cp.array(val))\n            elif arg == 'rnd_state':\n                setattr(gpu_agent, arg, cp.random.RandomState(self.seed))\n            elif isinstance(val, Model):\n                setattr(gpu_agent, arg, val.gpu_model)\n            elif isinstance(val, ValueFunction):\n                setattr(gpu_agent, arg, val.to_gpu())\n            elif isinstance(val, BeliefSet) or isinstance(val, Belief):\n                setattr(gpu_agent, arg, val.to_gpu())\n            else:\n                setattr(gpu_agent, arg, val)\n\n        # Self reference instances\n        self._alternate_version = gpu_agent\n        gpu_agent._alternate_version = self\n\n        gpu_agent.on_gpu = True\n        return gpu_agent\n\n\n    def to_cpu(self) -&gt; 'PBVI_Agent':\n        '''\n        Function to send the numpy arrays of the agent to the cpu.\n        It returns a new instance of the Agent class with the arrays on the cpu.\n\n        Returns\n        -------\n        cpu_agent : Agent\n            A new environment instance where the arrays are on the cpu memory.\n        '''\n        # Check whether the agent is already on the cpu or not\n        if not self.on_gpu:\n            return self\n\n        if self._alternate_version is not None:\n            print('[warning] A CPU instance already existed and is being recreated.')\n            self._alternate_version = None\n\n        # Generating a new instance\n        cls = self.__class__\n        cpu_agent = cls.__new__(cls)\n\n        # Copying arguments to gpu\n        for arg, val in self.__dict__.items():\n            if isinstance(val, cp.ndarray):\n                setattr(cpu_agent, arg, cp.asnumpy(val))\n            elif arg == 'rnd_state':\n                setattr(cpu_agent, arg, np.random.RandomState(self.seed))\n            elif isinstance(val, Model):\n                setattr(cpu_agent, arg, val.cpu_model)\n            elif isinstance(val, ValueFunction):\n                setattr(cpu_agent, arg, val.to_cpu())\n            elif isinstance(val, BeliefSet) or isinstance(val, Belief):\n                setattr(cpu_agent, arg, val.to_cpu())\n            else:\n                setattr(cpu_agent, arg, val)\n\n        # Self reference instances\n        self._alternate_version = cpu_agent\n        cpu_agent._alternate_version = self\n\n        cpu_agent.on_gpu = True\n        return cpu_agent\n\n\n    def save(self,\n             folder: str | None = None,\n             force: bool = False,\n             save_environment: bool = False\n             ) -&gt; None:\n        '''\n        The save function for PBVI Agents consists in recording the value function after the training.\n        It saves the agent in a folder with the name of the agent (class name + training timestamp).\n        In this folder, there will be the metadata of the agent (all the attributes) in a json format and the value function.\n\n        Optionally, the environment can be saved too to be able to load it alongside the agent for future reuse.\n        If the agent has already been saved, the saving will not happen unless the force parameter is toggled.\n\n        Parameters\n        ----------\n        folder : str, optional\n            The folder under which to save the agent (a subfolder will be created under this folder).\n            The agent will therefore be saved at &lt;folder&gt;/Agent-&lt;agent_name&gt; .\n            By default the current folder is used.\n        force : bool, default=False\n            Whether to overwrite an already saved agent with the same name at the same path.\n        save_environment : bool, default=False\n            Whether to save the environment data along with the agent.\n        '''\n        assert self.trained_at is not None, \"The agent is not trained, there is nothing to save.\"\n\n        # GPU support\n        if self.on_gpu:\n            self.cpu_version.save(folder=folder, force=force, save_environment=save_environment)\n            return\n\n        # Adding env name to folder path\n        if folder is None:\n            folder = f'./Agent-{self.name}'\n        else:\n            folder += '/Agent-' + self.name\n\n        # Checking the folder exists or creates it\n        if not os.path.exists(folder):\n            os.mkdir(folder)\n        elif len(os.listdir(folder)):\n            if force:\n                shutil.rmtree(folder)\n                os.mkdir(folder)\n            else:\n                raise Exception(f'{folder} is not empty. If you want to overwrite the saved model, enable \"force\".')\n\n        # If requested save environment\n        if save_environment:\n            self.environment.save(folder=folder)\n\n        # TODO: Add MODEL to save function\n        # Generating the metadata arguments dictionary\n        arguments = {}\n        arguments['name'] = self.name\n        arguments['class'] = self.class_name\n        if len(self.thresholds.shape) == 2:\n            arguments['thresholds'] = {layer_lab: layer_thresholds for layer_lab, layer_thresholds in zip(self.environment.layer_labels, self.thresholds.tolist())}\n        else:\n            arguments['thresholds'] = self.thresholds.tolist()\n        arguments['environment_name'] = self.environment.name\n        arguments['environment_saved_at'] = self.environment.saved_at\n        arguments['space_aware'] = self.space_aware\n        arguments['spacial_subdivisions'] = self.spacial_subdivisions.tolist()\n        arguments['action_labels'] = self.action_labels\n        arguments['action_set'] = self.action_set.tolist()\n        arguments['trained_at'] = self.trained_at\n        arguments['seed'] = self.seed\n\n        # Output the arguments to a METADATA file\n        with open(folder + '/METADATA.json', 'w') as json_file:\n            json.dump(arguments, json_file, indent=4)\n\n        # Save value function\n        self.value_function.save(folder=folder, file_name='Value_Function.npy')\n\n        # Finalization\n        self.saved_at = os.path.abspath(folder).replace('\\\\', '/')\n        print(f'Agent saved to: {folder}')\n\n\n    @classmethod\n    def load(cls,\n             folder: str\n             ) -&gt; 'PBVI_Agent':\n        '''\n        Function to load a PBVI agent from a given folder it has been saved to.\n        It will load the environment the agent has been trained on along with it.\n\n        If it is a subclass of the PBVI_Agent, an instance of that specific subclass will be returned.\n\n        Parameters\n        ----------\n        folder : str\n            The agent folder.\n\n        Returns\n        -------\n        instance : PBVI_Agent\n            The loaded instance of the PBVI Agent.\n        '''\n        # Load arguments\n        arguments = None\n        with open(folder + '/METADATA.json', 'r') as json_file:\n            arguments = json.load(json_file)\n\n        # Load environment\n        environment = Environment.load(arguments['environment_saved_at'])\n\n        # Load specific class\n        if arguments['class'] != 'PBVI_Agent':\n            from olfactory_navigation import agents\n            cls = {name:obj for name, obj in inspect.getmembers(agents)}[arguments['class']]\n\n        # Build instance\n        instance = cls(\n            environment = environment,\n            thresholds = arguments['thresholds'],\n            space_aware = arguments['space_aware'],\n            spacial_subdivisions = np.array(arguments['spacial_subdivisions']),\n            actions = {a_label: a_vector for a_label, a_vector in zip(arguments['action_labels'], arguments['action_set'])},\n            name = arguments['name'],\n            seed = arguments['seed']\n        )\n\n        # Load and set the value function on the instance\n        instance.value_function = ValueFunction.load(\n            file=folder + '/Value_Function.npy',\n            model=instance.model\n        )\n        instance.trained_at = arguments['trained_at']\n        instance.saved_at = folder\n\n        return instance\n\n\n    def train(self,\n              expansions: int,\n              full_backup: bool = True,\n              update_passes: int = 1,\n              max_belief_growth: int = 10,\n              initial_belief: BeliefSet | Belief | None = None,\n              initial_value_function: ValueFunction | None = None,\n              prune_level: int = 1,\n              prune_interval: int = 10,\n              limit_value_function_size: int = -1,\n              gamma: float = 0.99,\n              eps: float = 1e-6,\n              use_gpu: bool = False,\n              history_tracking_level: int = 1,\n              overwrite_training: bool = False,\n              print_progress: bool = True,\n              print_stats: bool = True,\n              **expand_arguments\n              ) -&gt; TrainingHistory:\n        '''\n        Main loop of the Point-Based Value Iteration algorithm.\n        It consists in 2 steps, Backup and Expand.\n        1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n        2. Backup: Updates the alpha vectors based on the current belief set\n\n        Parameters\n        ----------\n        expansions : int\n            How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n        full_backup : bool, default=True\n            Whether to force the backup function has to be run on the full set beliefs uncovered since the beginning or only on the new points.\n        update_passes : int, default=1\n            How many times the backup function has to be run every time the belief set is expanded.\n        max_belief_growth : int, default=10\n            How many beliefs can be added at every expansion step to the belief set.\n        initial_belief : BeliefSet or Belief, optional\n            An initial list of beliefs to start with.\n        initial_value_function : ValueFunction, optional\n            An initial value function to start the solving process with.\n        prune_level : int, default=1\n            Parameter to prune the value function further before the expand function.\n        prune_interval : int, default=10\n            How often to prune the value function. It is counted in number of backup iterations.\n        limit_value_function_size : int, default=-1\n            When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n            If set to -1, the value function can grow without bounds.\n        use_gpu : bool, default=False\n            Whether to use the GPU with cupy array to accelerate solving.\n        gamma : float, default=0.99\n            The discount factor to value immediate rewards more than long term rewards.\n            The learning rate is 1/gamma.\n        eps : float, default=1e-6\n            The smallest allowed changed for the value function.\n            Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n        history_tracking_level : int, default=1\n            How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n        overwrite_training : bool, default=False\n            Whether to force the overwriting of the training if a value function already exists for this agent.\n        print_progress : bool, default=True\n            Whether or not to print out the progress of the value iteration process.\n        print_stats : bool, default=True\n            Whether or not to print out statistics at the end of the training run.\n        expand_arguments : kwargs\n            An arbitrary amount of parameters that will be passed on to the expand function.\n\n        Returns\n        -------\n        solver_history : SolverHistory\n            The history of the solving process with some plotting options.\n        '''\n        # GPU support\n        if use_gpu and not self.on_gpu:\n            gpu_agent = self.to_gpu()\n            solver_history = super(self.__class__, gpu_agent).train(\n                expansions=expansions,\n                full_backup=full_backup,\n                update_passes=update_passes,\n                max_belief_growth=max_belief_growth,\n                initial_belief=initial_belief,\n                initial_value_function=initial_value_function,\n                prune_level=prune_level,\n                prune_interval=prune_interval,\n                limit_value_function_size=limit_value_function_size,\n                gamma=gamma,\n                eps=eps,\n                use_gpu=use_gpu,\n                history_tracking_level=history_tracking_level,\n                overwrite_training=overwrite_training,\n                print_progress=print_progress,\n                print_stats=print_stats,\n                **expand_arguments\n            )\n\n            # Setting parameters of CPU agent after the training\n            self.value_function = gpu_agent.value_function.to_cpu()\n            self.trained_at = gpu_agent.trained_at\n            self.name = gpu_agent.name\n\n            return solver_history\n\n        xp = np if not self.on_gpu else cp\n\n        # Getting model\n        model = self.model\n\n        # Initial belief\n        if initial_belief is None:\n            belief_set = BeliefSet(model, [Belief(model)])\n        elif isinstance(initial_belief, BeliefSet):\n            belief_set = initial_belief.to_gpu() if self.on_gpu else initial_belief\n        else:\n            initial_belief = Belief(model, xp.array(initial_belief.values))\n            belief_set = BeliefSet(model, [initial_belief])\n\n        # Handeling the case where the agent is already trained\n        if (self.value_function is not None):\n            if overwrite_training:\n                print('[warning] The value function is being overwritten')\n                self.trained_at = None\n                self.name = '-'.join(self.name.split('-')[:-1])\n                self.value_function = None\n            else:\n                initial_value_function = self.value_function\n\n        # Initial value function\n        if initial_value_function is None:\n            value_function = ValueFunction(model, model.expected_rewards_table.T, model.actions)\n        else:\n            value_function = initial_value_function.to_gpu() if self.on_gpu else initial_value_function\n\n        # Convergence check boundary\n        max_allowed_change = eps * (gamma / (1-gamma))\n\n        # History tracking\n        training_history = TrainingHistory(tracking_level=history_tracking_level,\n                                           model=model,\n                                           gamma=gamma,\n                                           eps=eps,\n                                           expand_append=full_backup,\n                                           initial_value_function=value_function,\n                                           initial_belief_set=belief_set)\n\n        # Loop\n        iteration = 0\n        expand_value_function = value_function\n        old_value_function = value_function\n\n        try:\n            iterator = trange(expansions, desc='Expansions') if print_progress else range(expansions)\n            iterator_postfix = {}\n            for expansion_i in iterator:\n\n                # 1: Expand belief set\n                start_ts = datetime.now()\n\n                new_belief_set = self.expand(belief_set=belief_set,\n                                             value_function=value_function,\n                                             max_generation=max_belief_growth,\n                                             **expand_arguments)\n\n                # Add new beliefs points to the total belief_set\n                belief_set = belief_set.union(new_belief_set)\n\n                expand_time = (datetime.now() - start_ts).total_seconds()\n                training_history.add_expand_step(expansion_time=expand_time, belief_set=belief_set)\n\n                # 2: Backup, update value function (alpha vector set)\n                for _ in range(update_passes) if (not print_progress or update_passes &lt;= 1) else trange(update_passes, desc=f'Backups {expansion_i}'):\n                    start_ts = datetime.now()\n\n                    # Backup step\n                    value_function = self.backup(belief_set if full_backup else new_belief_set,\n                                                 value_function,\n                                                 gamma=gamma,\n                                                 append=(not full_backup),\n                                                 belief_dominance_prune=False)\n                    backup_time = (datetime.now() - start_ts).total_seconds()\n\n                    # Additional pruning\n                    if (iteration % prune_interval) == 0 and iteration &gt; 0:\n                        start_ts = datetime.now()\n                        vf_len = len(value_function)\n\n                        value_function.prune(prune_level)\n\n                        prune_time = (datetime.now() - start_ts).total_seconds()\n                        alpha_vectors_pruned = len(value_function) - vf_len\n                        training_history.add_prune_step(prune_time, alpha_vectors_pruned)\n\n                    # Check if value function size is above threshold\n                    if limit_value_function_size &gt;= 0 and len(value_function) &gt; limit_value_function_size:\n                        # Compute matrix multiplications between avs and beliefs\n                        alpha_value_per_belief = xp.matmul(value_function.alpha_vector_array, belief_set.belief_array.T)\n\n                        # Select the useful alpha vectors\n                        best_alpha_vector_per_belief = xp.argmax(alpha_value_per_belief, axis=0)\n                        useful_alpha_vectors = xp.unique(best_alpha_vector_per_belief)\n\n                        # Select a random selection of vectors to delete\n                        unuseful_alpha_vectors = xp.delete(xp.arange(len(value_function)), useful_alpha_vectors)\n                        random_vectors_to_delete = self.rnd_state.choice(unuseful_alpha_vectors,\n                                                                         size=max_belief_growth,\n                                                                         p=(xp.arange(len(unuseful_alpha_vectors))[::-1] / xp.sum(xp.arange(len(unuseful_alpha_vectors)))))\n                                                                         # replace=False,\n                                                                         # p=1/len(unuseful_alpha_vectors))\n\n                        value_function = ValueFunction(model=model,\n                                                       alpha_vectors=xp.delete(value_function.alpha_vector_array, random_vectors_to_delete, axis=0),\n                                                       action_list=xp.delete(value_function.actions, random_vectors_to_delete))\n\n                        iterator_postfix['|useful|'] = useful_alpha_vectors.shape[0]\n\n                    # Compute the change between value functions\n                    max_change = self.compute_change(value_function, old_value_function, belief_set)\n\n                    # History tracking\n                    training_history.add_backup_step(backup_time, max_change, value_function)\n\n                    # Convergence check\n                    if max_change &lt; max_allowed_change:\n                        break\n\n                    old_value_function = value_function\n\n                    # Update iteration counter\n                    iteration += 1\n\n                # Compute change with old expansion value function\n                expand_max_change = self.compute_change(expand_value_function, value_function, belief_set)\n\n                if expand_max_change &lt; max_allowed_change:\n                    if print_progress:\n                        print('Converged!')\n                    break\n\n                expand_value_function = value_function\n\n                iterator_postfix['|V|'] = len(value_function)\n                iterator_postfix['|B|'] = len(belief_set)\n\n                if print_progress:\n                    iterator.set_postfix(iterator_postfix)\n\n        except MemoryError as e:\n            print(f'Memory full: {e}')\n            print('Returning value function and history as is...\\n')\n\n        # Final pruning\n        start_ts = datetime.now()\n        vf_len = len(value_function)\n\n        value_function.prune(prune_level)\n\n        # History tracking\n        prune_time = (datetime.now() - start_ts).total_seconds()\n        alpha_vectors_pruned = len(value_function) - vf_len\n        training_history.add_prune_step(prune_time, alpha_vectors_pruned)\n\n        # Record when it was trained\n        self.trained_at = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        self.name += f'-trained_{self.trained_at}'\n\n        # Saving value function\n        self.value_function = value_function\n\n        # Print stats if requested\n        if print_stats:\n            print(training_history.summary)\n\n        return training_history\n\n\n    def compute_change(self,\n                       value_function: ValueFunction,\n                       new_value_function: ValueFunction,\n                       belief_set: BeliefSet\n                       ) -&gt; float:\n        '''\n        Function to compute whether the change between two value functions can be considered as having converged based on the eps parameter of the Solver.\n        It check for each belief, the maximum value and take the max change between believe's value functions.\n        If this max change is lower than eps * (gamma / (1 - gamma)).\n\n        Parameters\n        ----------\n        value_function : ValueFunction\n            The first value function to compare.\n        new_value_function : ValueFunction\n            The second value function to compare.\n        belief_set : BeliefSet\n            The set of believes to check the values on to compute the max change on.\n\n        Returns\n        -------\n        max_change : float\n            The maximum change between value functions at belief points.\n        '''\n        # Get numpy corresponding to the arrays\n        xp = np if not gpu_support else cp.get_array_module(value_function.alpha_vector_array)\n\n        # Computing Delta for each beliefs\n        max_val_per_belief = xp.max(xp.matmul(belief_set.belief_array, value_function.alpha_vector_array.T), axis=1)\n        new_max_val_per_belief = xp.max(xp.matmul(belief_set.belief_array, new_value_function.alpha_vector_array.T), axis=1)\n        max_change = xp.max(xp.abs(new_max_val_per_belief - max_val_per_belief))\n\n        return max_change\n\n\n    def expand(self,\n               belief_set: BeliefSet,\n               value_function: ValueFunction,\n               max_generation: int,\n               **kwargs\n               ) -&gt; BeliefSet:\n        '''\n        Abstract function!\n        This function should be implemented in subclasses.\n        The expand function consists in the exploration of the belief set.\n        It takes as input a belief set and generates at most 'max_generation' beliefs from it.\n\n        The current value function is also passed as an argument as it is used in some PBVI techniques to guide the belief exploration.\n\n        Parameters\n        ----------\n        belief_set : BeliefSet\n            The belief or set of beliefs to be used as a starting point for the exploration.\n        value_function : ValueFunction\n            The current value function. To be used to guide the exploration process.\n        max_generation : int\n            How many beliefs to be generated at most.\n        kwargs\n            Special parameters for the particular flavors of the PBVI Agent.\n\n        Returns\n        -------\n        new_belief_set : BeliefSet\n            A new (or expanded) set of beliefs.\n        '''\n        raise NotImplementedError('PBVI class is abstract so expand function is not implemented, make an PBVI_agent subclass to implement the method')\n\n\n    def backup(self,\n               belief_set: BeliefSet,\n               value_function: ValueFunction,\n               gamma: float = 0.99,\n               append: bool = False,\n               belief_dominance_prune: bool = True\n               ) -&gt; ValueFunction:\n        '''\n        This function has purpose to update the set of alpha vectors. It does so in 3 steps:\n        1. It creates projections from each alpha vector for each possible action and each possible observation\n        2. It collapses this set of generated alpha vectors by taking the weighted sum of the alpha vectors weighted by the observation probability and this for each action and for each belief.\n        3. Then it further collapses the set to take the best alpha vector and action per belief\n        In the end we have a set of alpha vectors as large as the amount of beliefs.\n\n        The alpha vectors are also pruned to avoid duplicates and remove dominated ones.\n\n        Parameters\n        ----------\n        belief_set : BeliefSet\n            The belief set to use to generate the new alpha vectors with.\n        value_function : ValueFunction\n            The alpha vectors to generate the new set from.\n        gamma : float, default=0.99\n            The discount factor to value immediate rewards more than long term rewards.\n            The learning rate is 1/gamma.\n        append : bool, default=False\n            Whether to append the new alpha vectors generated to the old alpha vectors before pruning.\n        belief_dominance_prune : bool, default=True\n            Whether, before returning the new value function, checks what alpha vectors have a supperior value, if so it adds it.\n\n        Returns\n        -------\n        new_alpha_set : ValueFunction\n            A list of updated alpha vectors.\n        '''\n        xp = np if not self.on_gpu else cp\n        model = self.model\n\n        # Step 1\n        vector_array = value_function.alpha_vector_array\n        vectors_array_reachable_states = vector_array[xp.arange(vector_array.shape[0])[:,None,None,None], model.reachable_states[None,:,:,:]]\n\n        gamma_a_o_t = gamma * xp.einsum('saor,vsar-&gt;aovs', model.reachable_transitional_observation_table, vectors_array_reachable_states)\n\n        # Step 2\n        belief_array = belief_set.belief_array # bs\n        best_alpha_ind = xp.argmax(xp.tensordot(belief_array, gamma_a_o_t, (1,3)), axis=3) # argmax(bs,aovs-&gt;baov) -&gt; bao\n\n        best_alphas_per_o = gamma_a_o_t[model.actions[None,:,None,None], model.observations[None,None,:,None], best_alpha_ind[:,:,:,None], model.states[None,None,None,:]] # baos\n\n        alpha_a = model.expected_rewards_table.T + xp.sum(best_alphas_per_o, axis=2) # as + bas\n\n        # Step 3\n        best_actions = xp.argmax(xp.einsum('bas,bs-&gt;ba', alpha_a, belief_array), axis=1)\n        alpha_vectors = xp.take_along_axis(alpha_a, best_actions[:,None,None],axis=1)[:,0,:]\n\n        # Belief domination\n        if belief_dominance_prune:\n            best_value_per_belief = xp.sum((belief_array * alpha_vectors), axis=1)\n            old_best_value_per_belief = xp.max(xp.matmul(belief_array, vector_array.T), axis=1)\n            dominating_vectors = best_value_per_belief &gt; old_best_value_per_belief\n\n            best_actions = best_actions[dominating_vectors]\n            alpha_vectors = alpha_vectors[dominating_vectors]\n\n        # Creation of value function\n        new_value_function = ValueFunction(model, alpha_vectors, best_actions)\n\n        # Union with previous value function\n        if append:\n            new_value_function.extend(value_function)\n\n        return new_value_function\n\n\n    def modify_environment(self,\n                           new_environment: Environment\n                           ) -&gt; 'Agent':\n        '''\n        Function to modify the environment of the agent.\n        If the agent is already trained, the trained element should also be adapted to fit this new environment.\n\n        Parameters\n        ----------\n        new_environment : Environment\n            A modified environment.\n\n        Returns\n        -------\n        modified_agent : PBVI_Agent\n            A new pbvi agent with a modified environment\n        '''\n        # TODO: Fix this to account for other init parameters\n        # GPU support\n        if self.on_gpu:\n            return self.to_cpu().modify_environment(new_environment=new_environment)\n\n        # Creating a new agent instance\n        modified_agent = self.__class__(environment = new_environment,\n                                        thresholds = self.thresholds,\n                                        name = self.name)\n\n        # Modifying the value function\n        if self.value_function is not None:\n            reshaped_vf_array = np.array([cv2.resize(av, np.array(modified_agent.model.state_grid.shape)[::-1]).ravel()\n                                          for av in self.value_function.alpha_vector_array.reshape(len(self.value_function), *self.model.state_grid.shape)])\n            modified_vf = ValueFunction(modified_agent.model, alpha_vectors=reshaped_vf_array, action_list=self.value_function.actions)\n            modified_agent.value_function = modified_vf\n\n        return modified_agent\n\n\n    def initialize_state(self,\n                         n: int = 1,\n                         belief: BeliefSet | None = None\n                         ) -&gt; None:\n        '''\n        To use an agent within a simulation, the agent's state needs to be initialized.\n        The initialization consists of setting the agent's initial belief.\n        Multiple agents can be used at once for simulations, for this reason, the belief parameter is a BeliefSet by default.\n\n        Parameters\n        ----------\n        n : int, default=1\n            How many agents are to be used during the simulation.\n        belief : BeliefSet, optional\n            An optional set of beliefs to initialize the simulations with.\n        '''\n        assert self.value_function is not None, \"Agent was not trained, run the training function first...\"\n\n        if belief is None:\n            self.belief = BeliefSet(self.model, [Belief(self.model) for _ in range(n)])\n        else:\n            assert len(belief) == n, f\"The amount of beliefs provided ({len(belief)}) to initialize the state need to match the amount of stimulations to initialize (n={n}).\"\n\n            if self.on_gpu and not belief.is_on_gpu:\n                self.belief = belief.to_gpu()\n            elif not self.on_gpu and belief.is_on_gpu:\n                self.belief = belief.to_cpu()\n            else:\n                self.belief = belief\n\n\n    def choose_action(self) -&gt; np.ndarray:\n        '''\n        Function to let the agent or set of agents choose an action based on their current belief.\n\n        Returns\n        -------\n        movement_vector : np.ndarray\n            A single or a list of actions chosen by the agent(s) based on their belief.\n        '''\n        assert self.belief is not None, \"Agent was not initialized yet, run the initialize_state function first\"\n\n        # Evaluated value function\n        _, action = self.value_function.evaluate_at(self.belief)\n\n        # Recording the action played\n        self.action_played = action\n\n        # Converting action indexes to movement vectors\n        movemement_vector = self.action_set[action,:]\n\n        return movemement_vector\n\n\n    def update_state(self,\n                     action: np.ndarray,\n                     observation: np.ndarray,\n                     source_reached: np.ndarray\n                     ) -&gt; None | np.ndarray:\n        '''\n        Function to update the internal state(s) of the agent(s) based on the previous action(s) taken and the observation(s) received.\n\n        Parameters\n        ----------\n        action : np.ndarray\n            A 2D array of n movement vectors. If the environment is layered, the 1st component should be the layer.\n        observation : np.ndarray\n            The observation(s) the agent(s) made.\n        source_reached : np.ndarray\n            A boolean array of whether the agent(s) have reached the source or not.\n\n        Returns\n        -------\n        update_successfull : np.ndarray, optional\n            If nothing is returned, it means all the agent's state updates have been successfull.\n            Else, a boolean np.ndarray of size n can be returned confirming for each agent whether the update has been successful or not.\n        '''\n        assert self.belief is not None, \"Agent was not initialized yet, run the initialize_state function first\"\n\n        # Discretizing observations\n        observation_ids = self.discretize_observations(observation=observation, action=action, source_reached=source_reached)\n\n        # Update the set of beliefs\n        self.belief = self.belief.update(actions=self.action_played, observations=observation_ids, throw_error=False)\n\n        # Check for failed updates\n        update_successful = (self.belief.belief_array.sum(axis=1) != 0.0)\n\n        return update_successful\n\n\n    def kill(self,\n             simulations_to_kill: np.ndarray\n             ) -&gt; None:\n        '''\n        Function to kill any simulations that have not reached the source but can't continue further\n\n        Parameters\n        ----------\n        simulations_to_kill : np.ndarray\n            A boolean array of the simulations to kill.\n        '''\n        if all(simulations_to_kill):\n            self.belief = None\n        else:\n            self.belief = BeliefSet(self.belief.model, self.belief.belief_array[~simulations_to_kill])\n\n\n    def generate_beliefs_from_trajectory(self,\n                                         history: SimulationHistory,\n                                         trajectory_i: int = 0,\n                                         initial_belief: Belief | None = None\n                                         ) -&gt; BeliefSet:\n        '''\n        Function to generate a sequence of belief points from the trajectory from SimulationHistory instance.\n\n        Parameters\n        ----------\n        history : SimulationHistory\n            The simulation history from which the agent's trajectory is extracted.\n        trajectory_i : int, default=0\n            The id of the trajectory from which to build the belief sequence.\n        initial_belief : Belief, optional\n            The initial belief point from which to start the sequence.\n\n        Returns\n        -------\n        belief_sequence : BeliefSet\n            The sequence of beliefs the agent going through in the the trajectory of the simulation.\n        '''\n        # If the initial belief is not provided, generate one\n        if initial_belief is None:\n            initial_belief = Belief(self.model)\n\n        # Retrieve the trjactory's simulation dataframe\n        df = history.simulation_dfs[trajectory_i]\n\n        # Set the belief that will be iterate on\n        belief = initial_belief\n\n        # Belief sequence to be returned at the end\n        belief_sequence = [initial_belief]\n\n        for row_id, row in enumerate(df.iterrows()):\n            row = row[1]\n\n            # Skip initial position\n            if row_id == 0:\n                continue\n\n            # Check the ID of the action\n            a = np.argwhere(np.all((self.action_set == [row['dy'],row['dx']]), axis=1))[0,0]\n\n            # Retrieve observations\n            o = [row['o']]\n            if self.space_aware:\n                o += [row['y'],row['x']]\n\n            # Discretize observations\n            discrete_o = self.discretize_observations(observation=np.array([o]), action=np.array([a]), source_reached=np.array([False]))[0]\n\n            try:\n                # Update belief\n                belief = belief.update(a=a, o=discrete_o)\n                belief_sequence.append(belief)\n            except:\n                print(f'[Warning] Update of belief failed at step {row_id}...')\n\n        return BeliefSet(self.model, belief_sequence)\n</code></pre>"},{"location":"reference/agents/pbvi_agent/#olfactory_navigation.agents.pbvi_agent.PBVI_Agent.backup","title":"<code>backup(belief_set, value_function, gamma=0.99, append=False, belief_dominance_prune=True)</code>","text":"<p>This function has purpose to update the set of alpha vectors. It does so in 3 steps: 1. It creates projections from each alpha vector for each possible action and each possible observation 2. It collapses this set of generated alpha vectors by taking the weighted sum of the alpha vectors weighted by the observation probability and this for each action and for each belief. 3. Then it further collapses the set to take the best alpha vector and action per belief In the end we have a set of alpha vectors as large as the amount of beliefs.</p> <p>The alpha vectors are also pruned to avoid duplicates and remove dominated ones.</p> <p>Parameters:</p> Name Type Description Default <code>belief_set</code> <code>BeliefSet</code> <p>The belief set to use to generate the new alpha vectors with.</p> required <code>value_function</code> <code>ValueFunction</code> <p>The alpha vectors to generate the new set from.</p> required <code>gamma</code> <code>float</code> <p>The discount factor to value immediate rewards more than long term rewards. The learning rate is 1/gamma.</p> <code>0.99</code> <code>append</code> <code>bool</code> <p>Whether to append the new alpha vectors generated to the old alpha vectors before pruning.</p> <code>False</code> <code>belief_dominance_prune</code> <code>bool</code> <p>Whether, before returning the new value function, checks what alpha vectors have a supperior value, if so it adds it.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>new_alpha_set</code> <code>ValueFunction</code> <p>A list of updated alpha vectors.</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def backup(self,\n           belief_set: BeliefSet,\n           value_function: ValueFunction,\n           gamma: float = 0.99,\n           append: bool = False,\n           belief_dominance_prune: bool = True\n           ) -&gt; ValueFunction:\n    '''\n    This function has purpose to update the set of alpha vectors. It does so in 3 steps:\n    1. It creates projections from each alpha vector for each possible action and each possible observation\n    2. It collapses this set of generated alpha vectors by taking the weighted sum of the alpha vectors weighted by the observation probability and this for each action and for each belief.\n    3. Then it further collapses the set to take the best alpha vector and action per belief\n    In the end we have a set of alpha vectors as large as the amount of beliefs.\n\n    The alpha vectors are also pruned to avoid duplicates and remove dominated ones.\n\n    Parameters\n    ----------\n    belief_set : BeliefSet\n        The belief set to use to generate the new alpha vectors with.\n    value_function : ValueFunction\n        The alpha vectors to generate the new set from.\n    gamma : float, default=0.99\n        The discount factor to value immediate rewards more than long term rewards.\n        The learning rate is 1/gamma.\n    append : bool, default=False\n        Whether to append the new alpha vectors generated to the old alpha vectors before pruning.\n    belief_dominance_prune : bool, default=True\n        Whether, before returning the new value function, checks what alpha vectors have a supperior value, if so it adds it.\n\n    Returns\n    -------\n    new_alpha_set : ValueFunction\n        A list of updated alpha vectors.\n    '''\n    xp = np if not self.on_gpu else cp\n    model = self.model\n\n    # Step 1\n    vector_array = value_function.alpha_vector_array\n    vectors_array_reachable_states = vector_array[xp.arange(vector_array.shape[0])[:,None,None,None], model.reachable_states[None,:,:,:]]\n\n    gamma_a_o_t = gamma * xp.einsum('saor,vsar-&gt;aovs', model.reachable_transitional_observation_table, vectors_array_reachable_states)\n\n    # Step 2\n    belief_array = belief_set.belief_array # bs\n    best_alpha_ind = xp.argmax(xp.tensordot(belief_array, gamma_a_o_t, (1,3)), axis=3) # argmax(bs,aovs-&gt;baov) -&gt; bao\n\n    best_alphas_per_o = gamma_a_o_t[model.actions[None,:,None,None], model.observations[None,None,:,None], best_alpha_ind[:,:,:,None], model.states[None,None,None,:]] # baos\n\n    alpha_a = model.expected_rewards_table.T + xp.sum(best_alphas_per_o, axis=2) # as + bas\n\n    # Step 3\n    best_actions = xp.argmax(xp.einsum('bas,bs-&gt;ba', alpha_a, belief_array), axis=1)\n    alpha_vectors = xp.take_along_axis(alpha_a, best_actions[:,None,None],axis=1)[:,0,:]\n\n    # Belief domination\n    if belief_dominance_prune:\n        best_value_per_belief = xp.sum((belief_array * alpha_vectors), axis=1)\n        old_best_value_per_belief = xp.max(xp.matmul(belief_array, vector_array.T), axis=1)\n        dominating_vectors = best_value_per_belief &gt; old_best_value_per_belief\n\n        best_actions = best_actions[dominating_vectors]\n        alpha_vectors = alpha_vectors[dominating_vectors]\n\n    # Creation of value function\n    new_value_function = ValueFunction(model, alpha_vectors, best_actions)\n\n    # Union with previous value function\n    if append:\n        new_value_function.extend(value_function)\n\n    return new_value_function\n</code></pre>"},{"location":"reference/agents/pbvi_agent/#olfactory_navigation.agents.pbvi_agent.PBVI_Agent.choose_action","title":"<code>choose_action()</code>","text":"<p>Function to let the agent or set of agents choose an action based on their current belief.</p> <p>Returns:</p> Name Type Description <code>movement_vector</code> <code>ndarray</code> <p>A single or a list of actions chosen by the agent(s) based on their belief.</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def choose_action(self) -&gt; np.ndarray:\n    '''\n    Function to let the agent or set of agents choose an action based on their current belief.\n\n    Returns\n    -------\n    movement_vector : np.ndarray\n        A single or a list of actions chosen by the agent(s) based on their belief.\n    '''\n    assert self.belief is not None, \"Agent was not initialized yet, run the initialize_state function first\"\n\n    # Evaluated value function\n    _, action = self.value_function.evaluate_at(self.belief)\n\n    # Recording the action played\n    self.action_played = action\n\n    # Converting action indexes to movement vectors\n    movemement_vector = self.action_set[action,:]\n\n    return movemement_vector\n</code></pre>"},{"location":"reference/agents/pbvi_agent/#olfactory_navigation.agents.pbvi_agent.PBVI_Agent.compute_change","title":"<code>compute_change(value_function, new_value_function, belief_set)</code>","text":"<p>Function to compute whether the change between two value functions can be considered as having converged based on the eps parameter of the Solver. It check for each belief, the maximum value and take the max change between believe's value functions. If this max change is lower than eps * (gamma / (1 - gamma)).</p> <p>Parameters:</p> Name Type Description Default <code>value_function</code> <code>ValueFunction</code> <p>The first value function to compare.</p> required <code>new_value_function</code> <code>ValueFunction</code> <p>The second value function to compare.</p> required <code>belief_set</code> <code>BeliefSet</code> <p>The set of believes to check the values on to compute the max change on.</p> required <p>Returns:</p> Name Type Description <code>max_change</code> <code>float</code> <p>The maximum change between value functions at belief points.</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def compute_change(self,\n                   value_function: ValueFunction,\n                   new_value_function: ValueFunction,\n                   belief_set: BeliefSet\n                   ) -&gt; float:\n    '''\n    Function to compute whether the change between two value functions can be considered as having converged based on the eps parameter of the Solver.\n    It check for each belief, the maximum value and take the max change between believe's value functions.\n    If this max change is lower than eps * (gamma / (1 - gamma)).\n\n    Parameters\n    ----------\n    value_function : ValueFunction\n        The first value function to compare.\n    new_value_function : ValueFunction\n        The second value function to compare.\n    belief_set : BeliefSet\n        The set of believes to check the values on to compute the max change on.\n\n    Returns\n    -------\n    max_change : float\n        The maximum change between value functions at belief points.\n    '''\n    # Get numpy corresponding to the arrays\n    xp = np if not gpu_support else cp.get_array_module(value_function.alpha_vector_array)\n\n    # Computing Delta for each beliefs\n    max_val_per_belief = xp.max(xp.matmul(belief_set.belief_array, value_function.alpha_vector_array.T), axis=1)\n    new_max_val_per_belief = xp.max(xp.matmul(belief_set.belief_array, new_value_function.alpha_vector_array.T), axis=1)\n    max_change = xp.max(xp.abs(new_max_val_per_belief - max_val_per_belief))\n\n    return max_change\n</code></pre>"},{"location":"reference/agents/pbvi_agent/#olfactory_navigation.agents.pbvi_agent.PBVI_Agent.expand","title":"<code>expand(belief_set, value_function, max_generation, **kwargs)</code>","text":"<p>Abstract function! This function should be implemented in subclasses. The expand function consists in the exploration of the belief set. It takes as input a belief set and generates at most 'max_generation' beliefs from it.</p> <p>The current value function is also passed as an argument as it is used in some PBVI techniques to guide the belief exploration.</p> <p>Parameters:</p> Name Type Description Default <code>belief_set</code> <code>BeliefSet</code> <p>The belief or set of beliefs to be used as a starting point for the exploration.</p> required <code>value_function</code> <code>ValueFunction</code> <p>The current value function. To be used to guide the exploration process.</p> required <code>max_generation</code> <code>int</code> <p>How many beliefs to be generated at most.</p> required <code>kwargs</code> <p>Special parameters for the particular flavors of the PBVI Agent.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>new_belief_set</code> <code>BeliefSet</code> <p>A new (or expanded) set of beliefs.</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def expand(self,\n           belief_set: BeliefSet,\n           value_function: ValueFunction,\n           max_generation: int,\n           **kwargs\n           ) -&gt; BeliefSet:\n    '''\n    Abstract function!\n    This function should be implemented in subclasses.\n    The expand function consists in the exploration of the belief set.\n    It takes as input a belief set and generates at most 'max_generation' beliefs from it.\n\n    The current value function is also passed as an argument as it is used in some PBVI techniques to guide the belief exploration.\n\n    Parameters\n    ----------\n    belief_set : BeliefSet\n        The belief or set of beliefs to be used as a starting point for the exploration.\n    value_function : ValueFunction\n        The current value function. To be used to guide the exploration process.\n    max_generation : int\n        How many beliefs to be generated at most.\n    kwargs\n        Special parameters for the particular flavors of the PBVI Agent.\n\n    Returns\n    -------\n    new_belief_set : BeliefSet\n        A new (or expanded) set of beliefs.\n    '''\n    raise NotImplementedError('PBVI class is abstract so expand function is not implemented, make an PBVI_agent subclass to implement the method')\n</code></pre>"},{"location":"reference/agents/pbvi_agent/#olfactory_navigation.agents.pbvi_agent.PBVI_Agent.generate_beliefs_from_trajectory","title":"<code>generate_beliefs_from_trajectory(history, trajectory_i=0, initial_belief=None)</code>","text":"<p>Function to generate a sequence of belief points from the trajectory from SimulationHistory instance.</p> <p>Parameters:</p> Name Type Description Default <code>history</code> <code>SimulationHistory</code> <p>The simulation history from which the agent's trajectory is extracted.</p> required <code>trajectory_i</code> <code>int</code> <p>The id of the trajectory from which to build the belief sequence.</p> <code>0</code> <code>initial_belief</code> <code>Belief</code> <p>The initial belief point from which to start the sequence.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>belief_sequence</code> <code>BeliefSet</code> <p>The sequence of beliefs the agent going through in the the trajectory of the simulation.</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def generate_beliefs_from_trajectory(self,\n                                     history: SimulationHistory,\n                                     trajectory_i: int = 0,\n                                     initial_belief: Belief | None = None\n                                     ) -&gt; BeliefSet:\n    '''\n    Function to generate a sequence of belief points from the trajectory from SimulationHistory instance.\n\n    Parameters\n    ----------\n    history : SimulationHistory\n        The simulation history from which the agent's trajectory is extracted.\n    trajectory_i : int, default=0\n        The id of the trajectory from which to build the belief sequence.\n    initial_belief : Belief, optional\n        The initial belief point from which to start the sequence.\n\n    Returns\n    -------\n    belief_sequence : BeliefSet\n        The sequence of beliefs the agent going through in the the trajectory of the simulation.\n    '''\n    # If the initial belief is not provided, generate one\n    if initial_belief is None:\n        initial_belief = Belief(self.model)\n\n    # Retrieve the trjactory's simulation dataframe\n    df = history.simulation_dfs[trajectory_i]\n\n    # Set the belief that will be iterate on\n    belief = initial_belief\n\n    # Belief sequence to be returned at the end\n    belief_sequence = [initial_belief]\n\n    for row_id, row in enumerate(df.iterrows()):\n        row = row[1]\n\n        # Skip initial position\n        if row_id == 0:\n            continue\n\n        # Check the ID of the action\n        a = np.argwhere(np.all((self.action_set == [row['dy'],row['dx']]), axis=1))[0,0]\n\n        # Retrieve observations\n        o = [row['o']]\n        if self.space_aware:\n            o += [row['y'],row['x']]\n\n        # Discretize observations\n        discrete_o = self.discretize_observations(observation=np.array([o]), action=np.array([a]), source_reached=np.array([False]))[0]\n\n        try:\n            # Update belief\n            belief = belief.update(a=a, o=discrete_o)\n            belief_sequence.append(belief)\n        except:\n            print(f'[Warning] Update of belief failed at step {row_id}...')\n\n    return BeliefSet(self.model, belief_sequence)\n</code></pre>"},{"location":"reference/agents/pbvi_agent/#olfactory_navigation.agents.pbvi_agent.PBVI_Agent.initialize_state","title":"<code>initialize_state(n=1, belief=None)</code>","text":"<p>To use an agent within a simulation, the agent's state needs to be initialized. The initialization consists of setting the agent's initial belief. Multiple agents can be used at once for simulations, for this reason, the belief parameter is a BeliefSet by default.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>How many agents are to be used during the simulation.</p> <code>1</code> <code>belief</code> <code>BeliefSet</code> <p>An optional set of beliefs to initialize the simulations with.</p> <code>None</code> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def initialize_state(self,\n                     n: int = 1,\n                     belief: BeliefSet | None = None\n                     ) -&gt; None:\n    '''\n    To use an agent within a simulation, the agent's state needs to be initialized.\n    The initialization consists of setting the agent's initial belief.\n    Multiple agents can be used at once for simulations, for this reason, the belief parameter is a BeliefSet by default.\n\n    Parameters\n    ----------\n    n : int, default=1\n        How many agents are to be used during the simulation.\n    belief : BeliefSet, optional\n        An optional set of beliefs to initialize the simulations with.\n    '''\n    assert self.value_function is not None, \"Agent was not trained, run the training function first...\"\n\n    if belief is None:\n        self.belief = BeliefSet(self.model, [Belief(self.model) for _ in range(n)])\n    else:\n        assert len(belief) == n, f\"The amount of beliefs provided ({len(belief)}) to initialize the state need to match the amount of stimulations to initialize (n={n}).\"\n\n        if self.on_gpu and not belief.is_on_gpu:\n            self.belief = belief.to_gpu()\n        elif not self.on_gpu and belief.is_on_gpu:\n            self.belief = belief.to_cpu()\n        else:\n            self.belief = belief\n</code></pre>"},{"location":"reference/agents/pbvi_agent/#olfactory_navigation.agents.pbvi_agent.PBVI_Agent.kill","title":"<code>kill(simulations_to_kill)</code>","text":"<p>Function to kill any simulations that have not reached the source but can't continue further</p> <p>Parameters:</p> Name Type Description Default <code>simulations_to_kill</code> <code>ndarray</code> <p>A boolean array of the simulations to kill.</p> required Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def kill(self,\n         simulations_to_kill: np.ndarray\n         ) -&gt; None:\n    '''\n    Function to kill any simulations that have not reached the source but can't continue further\n\n    Parameters\n    ----------\n    simulations_to_kill : np.ndarray\n        A boolean array of the simulations to kill.\n    '''\n    if all(simulations_to_kill):\n        self.belief = None\n    else:\n        self.belief = BeliefSet(self.belief.model, self.belief.belief_array[~simulations_to_kill])\n</code></pre>"},{"location":"reference/agents/pbvi_agent/#olfactory_navigation.agents.pbvi_agent.PBVI_Agent.load","title":"<code>load(folder)</code>  <code>classmethod</code>","text":"<p>Function to load a PBVI agent from a given folder it has been saved to. It will load the environment the agent has been trained on along with it.</p> <p>If it is a subclass of the PBVI_Agent, an instance of that specific subclass will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>The agent folder.</p> required <p>Returns:</p> Name Type Description <code>instance</code> <code>PBVI_Agent</code> <p>The loaded instance of the PBVI Agent.</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>@classmethod\ndef load(cls,\n         folder: str\n         ) -&gt; 'PBVI_Agent':\n    '''\n    Function to load a PBVI agent from a given folder it has been saved to.\n    It will load the environment the agent has been trained on along with it.\n\n    If it is a subclass of the PBVI_Agent, an instance of that specific subclass will be returned.\n\n    Parameters\n    ----------\n    folder : str\n        The agent folder.\n\n    Returns\n    -------\n    instance : PBVI_Agent\n        The loaded instance of the PBVI Agent.\n    '''\n    # Load arguments\n    arguments = None\n    with open(folder + '/METADATA.json', 'r') as json_file:\n        arguments = json.load(json_file)\n\n    # Load environment\n    environment = Environment.load(arguments['environment_saved_at'])\n\n    # Load specific class\n    if arguments['class'] != 'PBVI_Agent':\n        from olfactory_navigation import agents\n        cls = {name:obj for name, obj in inspect.getmembers(agents)}[arguments['class']]\n\n    # Build instance\n    instance = cls(\n        environment = environment,\n        thresholds = arguments['thresholds'],\n        space_aware = arguments['space_aware'],\n        spacial_subdivisions = np.array(arguments['spacial_subdivisions']),\n        actions = {a_label: a_vector for a_label, a_vector in zip(arguments['action_labels'], arguments['action_set'])},\n        name = arguments['name'],\n        seed = arguments['seed']\n    )\n\n    # Load and set the value function on the instance\n    instance.value_function = ValueFunction.load(\n        file=folder + '/Value_Function.npy',\n        model=instance.model\n    )\n    instance.trained_at = arguments['trained_at']\n    instance.saved_at = folder\n\n    return instance\n</code></pre>"},{"location":"reference/agents/pbvi_agent/#olfactory_navigation.agents.pbvi_agent.PBVI_Agent.modify_environment","title":"<code>modify_environment(new_environment)</code>","text":"<p>Function to modify the environment of the agent. If the agent is already trained, the trained element should also be adapted to fit this new environment.</p> <p>Parameters:</p> Name Type Description Default <code>new_environment</code> <code>Environment</code> <p>A modified environment.</p> required <p>Returns:</p> Name Type Description <code>modified_agent</code> <code>PBVI_Agent</code> <p>A new pbvi agent with a modified environment</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def modify_environment(self,\n                       new_environment: Environment\n                       ) -&gt; 'Agent':\n    '''\n    Function to modify the environment of the agent.\n    If the agent is already trained, the trained element should also be adapted to fit this new environment.\n\n    Parameters\n    ----------\n    new_environment : Environment\n        A modified environment.\n\n    Returns\n    -------\n    modified_agent : PBVI_Agent\n        A new pbvi agent with a modified environment\n    '''\n    # TODO: Fix this to account for other init parameters\n    # GPU support\n    if self.on_gpu:\n        return self.to_cpu().modify_environment(new_environment=new_environment)\n\n    # Creating a new agent instance\n    modified_agent = self.__class__(environment = new_environment,\n                                    thresholds = self.thresholds,\n                                    name = self.name)\n\n    # Modifying the value function\n    if self.value_function is not None:\n        reshaped_vf_array = np.array([cv2.resize(av, np.array(modified_agent.model.state_grid.shape)[::-1]).ravel()\n                                      for av in self.value_function.alpha_vector_array.reshape(len(self.value_function), *self.model.state_grid.shape)])\n        modified_vf = ValueFunction(modified_agent.model, alpha_vectors=reshaped_vf_array, action_list=self.value_function.actions)\n        modified_agent.value_function = modified_vf\n\n    return modified_agent\n</code></pre>"},{"location":"reference/agents/pbvi_agent/#olfactory_navigation.agents.pbvi_agent.PBVI_Agent.save","title":"<code>save(folder=None, force=False, save_environment=False)</code>","text":"<p>The save function for PBVI Agents consists in recording the value function after the training. It saves the agent in a folder with the name of the agent (class name + training timestamp). In this folder, there will be the metadata of the agent (all the attributes) in a json format and the value function.</p> <p>Optionally, the environment can be saved too to be able to load it alongside the agent for future reuse. If the agent has already been saved, the saving will not happen unless the force parameter is toggled.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>The folder under which to save the agent (a subfolder will be created under this folder). The agent will therefore be saved at /Agent- . By default the current folder is used. <code>None</code> <code>force</code> <code>bool</code> <p>Whether to overwrite an already saved agent with the same name at the same path.</p> <code>False</code> <code>save_environment</code> <code>bool</code> <p>Whether to save the environment data along with the agent.</p> <code>False</code> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def save(self,\n         folder: str | None = None,\n         force: bool = False,\n         save_environment: bool = False\n         ) -&gt; None:\n    '''\n    The save function for PBVI Agents consists in recording the value function after the training.\n    It saves the agent in a folder with the name of the agent (class name + training timestamp).\n    In this folder, there will be the metadata of the agent (all the attributes) in a json format and the value function.\n\n    Optionally, the environment can be saved too to be able to load it alongside the agent for future reuse.\n    If the agent has already been saved, the saving will not happen unless the force parameter is toggled.\n\n    Parameters\n    ----------\n    folder : str, optional\n        The folder under which to save the agent (a subfolder will be created under this folder).\n        The agent will therefore be saved at &lt;folder&gt;/Agent-&lt;agent_name&gt; .\n        By default the current folder is used.\n    force : bool, default=False\n        Whether to overwrite an already saved agent with the same name at the same path.\n    save_environment : bool, default=False\n        Whether to save the environment data along with the agent.\n    '''\n    assert self.trained_at is not None, \"The agent is not trained, there is nothing to save.\"\n\n    # GPU support\n    if self.on_gpu:\n        self.cpu_version.save(folder=folder, force=force, save_environment=save_environment)\n        return\n\n    # Adding env name to folder path\n    if folder is None:\n        folder = f'./Agent-{self.name}'\n    else:\n        folder += '/Agent-' + self.name\n\n    # Checking the folder exists or creates it\n    if not os.path.exists(folder):\n        os.mkdir(folder)\n    elif len(os.listdir(folder)):\n        if force:\n            shutil.rmtree(folder)\n            os.mkdir(folder)\n        else:\n            raise Exception(f'{folder} is not empty. If you want to overwrite the saved model, enable \"force\".')\n\n    # If requested save environment\n    if save_environment:\n        self.environment.save(folder=folder)\n\n    # TODO: Add MODEL to save function\n    # Generating the metadata arguments dictionary\n    arguments = {}\n    arguments['name'] = self.name\n    arguments['class'] = self.class_name\n    if len(self.thresholds.shape) == 2:\n        arguments['thresholds'] = {layer_lab: layer_thresholds for layer_lab, layer_thresholds in zip(self.environment.layer_labels, self.thresholds.tolist())}\n    else:\n        arguments['thresholds'] = self.thresholds.tolist()\n    arguments['environment_name'] = self.environment.name\n    arguments['environment_saved_at'] = self.environment.saved_at\n    arguments['space_aware'] = self.space_aware\n    arguments['spacial_subdivisions'] = self.spacial_subdivisions.tolist()\n    arguments['action_labels'] = self.action_labels\n    arguments['action_set'] = self.action_set.tolist()\n    arguments['trained_at'] = self.trained_at\n    arguments['seed'] = self.seed\n\n    # Output the arguments to a METADATA file\n    with open(folder + '/METADATA.json', 'w') as json_file:\n        json.dump(arguments, json_file, indent=4)\n\n    # Save value function\n    self.value_function.save(folder=folder, file_name='Value_Function.npy')\n\n    # Finalization\n    self.saved_at = os.path.abspath(folder).replace('\\\\', '/')\n    print(f'Agent saved to: {folder}')\n</code></pre>"},{"location":"reference/agents/pbvi_agent/#olfactory_navigation.agents.pbvi_agent.PBVI_Agent.to_cpu","title":"<code>to_cpu()</code>","text":"<p>Function to send the numpy arrays of the agent to the cpu. It returns a new instance of the Agent class with the arrays on the cpu.</p> <p>Returns:</p> Name Type Description <code>cpu_agent</code> <code>Agent</code> <p>A new environment instance where the arrays are on the cpu memory.</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def to_cpu(self) -&gt; 'PBVI_Agent':\n    '''\n    Function to send the numpy arrays of the agent to the cpu.\n    It returns a new instance of the Agent class with the arrays on the cpu.\n\n    Returns\n    -------\n    cpu_agent : Agent\n        A new environment instance where the arrays are on the cpu memory.\n    '''\n    # Check whether the agent is already on the cpu or not\n    if not self.on_gpu:\n        return self\n\n    if self._alternate_version is not None:\n        print('[warning] A CPU instance already existed and is being recreated.')\n        self._alternate_version = None\n\n    # Generating a new instance\n    cls = self.__class__\n    cpu_agent = cls.__new__(cls)\n\n    # Copying arguments to gpu\n    for arg, val in self.__dict__.items():\n        if isinstance(val, cp.ndarray):\n            setattr(cpu_agent, arg, cp.asnumpy(val))\n        elif arg == 'rnd_state':\n            setattr(cpu_agent, arg, np.random.RandomState(self.seed))\n        elif isinstance(val, Model):\n            setattr(cpu_agent, arg, val.cpu_model)\n        elif isinstance(val, ValueFunction):\n            setattr(cpu_agent, arg, val.to_cpu())\n        elif isinstance(val, BeliefSet) or isinstance(val, Belief):\n            setattr(cpu_agent, arg, val.to_cpu())\n        else:\n            setattr(cpu_agent, arg, val)\n\n    # Self reference instances\n    self._alternate_version = cpu_agent\n    cpu_agent._alternate_version = self\n\n    cpu_agent.on_gpu = True\n    return cpu_agent\n</code></pre>"},{"location":"reference/agents/pbvi_agent/#olfactory_navigation.agents.pbvi_agent.PBVI_Agent.to_gpu","title":"<code>to_gpu()</code>","text":"<p>Function to send the numpy arrays of the agent to the gpu. It returns a new instance of the Agent class with the arrays on the gpu.</p> <p>Returns:</p> Name Type Description <code>gpu_agent</code> <code>Agent</code> <p>A copy of the agent with the arrays on the GPU.</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def to_gpu(self) -&gt; 'PBVI_Agent':\n    '''\n    Function to send the numpy arrays of the agent to the gpu.\n    It returns a new instance of the Agent class with the arrays on the gpu.\n\n    Returns\n    -------\n    gpu_agent : Agent\n        A copy of the agent with the arrays on the GPU.\n    '''\n    # Check whether the agent is already on the gpu or not\n    if self.on_gpu:\n        return self\n\n    # Warn and overwrite alternate_version in case it already exists\n    if self._alternate_version is not None:\n        print('[warning] A GPU instance already existed and is being recreated.')\n        self._alternate_version = None\n\n    assert gpu_support, \"GPU support is not enabled, Cupy might need to be installed...\"\n\n    # Generating a new instance\n    cls = self.__class__\n    gpu_agent = cls.__new__(cls)\n\n    # Copying arguments to gpu\n    for arg, val in self.__dict__.items():\n        if isinstance(val, np.ndarray):\n            setattr(gpu_agent, arg, cp.array(val))\n        elif arg == 'rnd_state':\n            setattr(gpu_agent, arg, cp.random.RandomState(self.seed))\n        elif isinstance(val, Model):\n            setattr(gpu_agent, arg, val.gpu_model)\n        elif isinstance(val, ValueFunction):\n            setattr(gpu_agent, arg, val.to_gpu())\n        elif isinstance(val, BeliefSet) or isinstance(val, Belief):\n            setattr(gpu_agent, arg, val.to_gpu())\n        else:\n            setattr(gpu_agent, arg, val)\n\n    # Self reference instances\n    self._alternate_version = gpu_agent\n    gpu_agent._alternate_version = self\n\n    gpu_agent.on_gpu = True\n    return gpu_agent\n</code></pre>"},{"location":"reference/agents/pbvi_agent/#olfactory_navigation.agents.pbvi_agent.PBVI_Agent.train","title":"<code>train(expansions, full_backup=True, update_passes=1, max_belief_growth=10, initial_belief=None, initial_value_function=None, prune_level=1, prune_interval=10, limit_value_function_size=-1, gamma=0.99, eps=1e-06, use_gpu=False, history_tracking_level=1, overwrite_training=False, print_progress=True, print_stats=True, **expand_arguments)</code>","text":"<p>Main loop of the Point-Based Value Iteration algorithm. It consists in 2 steps, Backup and Expand. 1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function 2. Backup: Updates the alpha vectors based on the current belief set</p> <p>Parameters:</p> Name Type Description Default <code>expansions</code> <code>int</code> <p>How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)</p> required <code>full_backup</code> <code>bool</code> <p>Whether to force the backup function has to be run on the full set beliefs uncovered since the beginning or only on the new points.</p> <code>True</code> <code>update_passes</code> <code>int</code> <p>How many times the backup function has to be run every time the belief set is expanded.</p> <code>1</code> <code>max_belief_growth</code> <code>int</code> <p>How many beliefs can be added at every expansion step to the belief set.</p> <code>10</code> <code>initial_belief</code> <code>BeliefSet or Belief</code> <p>An initial list of beliefs to start with.</p> <code>None</code> <code>initial_value_function</code> <code>ValueFunction</code> <p>An initial value function to start the solving process with.</p> <code>None</code> <code>prune_level</code> <code>int</code> <p>Parameter to prune the value function further before the expand function.</p> <code>1</code> <code>prune_interval</code> <code>int</code> <p>How often to prune the value function. It is counted in number of backup iterations.</p> <code>10</code> <code>limit_value_function_size</code> <code>int</code> <p>When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function If set to -1, the value function can grow without bounds.</p> <code>-1</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU with cupy array to accelerate solving.</p> <code>False</code> <code>gamma</code> <code>float</code> <p>The discount factor to value immediate rewards more than long term rewards. The learning rate is 1/gamma.</p> <code>0.99</code> <code>eps</code> <code>float</code> <p>The smallest allowed changed for the value function. Bellow the amound of change, the value function is considered converged and the value iteration process will end early.</p> <code>1e-6</code> <code>history_tracking_level</code> <code>int</code> <p>How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)</p> <code>1</code> <code>overwrite_training</code> <code>bool</code> <p>Whether to force the overwriting of the training if a value function already exists for this agent.</p> <code>False</code> <code>print_progress</code> <code>bool</code> <p>Whether or not to print out the progress of the value iteration process.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether or not to print out statistics at the end of the training run.</p> <code>True</code> <code>expand_arguments</code> <code>kwargs</code> <p>An arbitrary amount of parameters that will be passed on to the expand function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>solver_history</code> <code>SolverHistory</code> <p>The history of the solving process with some plotting options.</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def train(self,\n          expansions: int,\n          full_backup: bool = True,\n          update_passes: int = 1,\n          max_belief_growth: int = 10,\n          initial_belief: BeliefSet | Belief | None = None,\n          initial_value_function: ValueFunction | None = None,\n          prune_level: int = 1,\n          prune_interval: int = 10,\n          limit_value_function_size: int = -1,\n          gamma: float = 0.99,\n          eps: float = 1e-6,\n          use_gpu: bool = False,\n          history_tracking_level: int = 1,\n          overwrite_training: bool = False,\n          print_progress: bool = True,\n          print_stats: bool = True,\n          **expand_arguments\n          ) -&gt; TrainingHistory:\n    '''\n    Main loop of the Point-Based Value Iteration algorithm.\n    It consists in 2 steps, Backup and Expand.\n    1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n    2. Backup: Updates the alpha vectors based on the current belief set\n\n    Parameters\n    ----------\n    expansions : int\n        How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n    full_backup : bool, default=True\n        Whether to force the backup function has to be run on the full set beliefs uncovered since the beginning or only on the new points.\n    update_passes : int, default=1\n        How many times the backup function has to be run every time the belief set is expanded.\n    max_belief_growth : int, default=10\n        How many beliefs can be added at every expansion step to the belief set.\n    initial_belief : BeliefSet or Belief, optional\n        An initial list of beliefs to start with.\n    initial_value_function : ValueFunction, optional\n        An initial value function to start the solving process with.\n    prune_level : int, default=1\n        Parameter to prune the value function further before the expand function.\n    prune_interval : int, default=10\n        How often to prune the value function. It is counted in number of backup iterations.\n    limit_value_function_size : int, default=-1\n        When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n        If set to -1, the value function can grow without bounds.\n    use_gpu : bool, default=False\n        Whether to use the GPU with cupy array to accelerate solving.\n    gamma : float, default=0.99\n        The discount factor to value immediate rewards more than long term rewards.\n        The learning rate is 1/gamma.\n    eps : float, default=1e-6\n        The smallest allowed changed for the value function.\n        Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n    history_tracking_level : int, default=1\n        How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n    overwrite_training : bool, default=False\n        Whether to force the overwriting of the training if a value function already exists for this agent.\n    print_progress : bool, default=True\n        Whether or not to print out the progress of the value iteration process.\n    print_stats : bool, default=True\n        Whether or not to print out statistics at the end of the training run.\n    expand_arguments : kwargs\n        An arbitrary amount of parameters that will be passed on to the expand function.\n\n    Returns\n    -------\n    solver_history : SolverHistory\n        The history of the solving process with some plotting options.\n    '''\n    # GPU support\n    if use_gpu and not self.on_gpu:\n        gpu_agent = self.to_gpu()\n        solver_history = super(self.__class__, gpu_agent).train(\n            expansions=expansions,\n            full_backup=full_backup,\n            update_passes=update_passes,\n            max_belief_growth=max_belief_growth,\n            initial_belief=initial_belief,\n            initial_value_function=initial_value_function,\n            prune_level=prune_level,\n            prune_interval=prune_interval,\n            limit_value_function_size=limit_value_function_size,\n            gamma=gamma,\n            eps=eps,\n            use_gpu=use_gpu,\n            history_tracking_level=history_tracking_level,\n            overwrite_training=overwrite_training,\n            print_progress=print_progress,\n            print_stats=print_stats,\n            **expand_arguments\n        )\n\n        # Setting parameters of CPU agent after the training\n        self.value_function = gpu_agent.value_function.to_cpu()\n        self.trained_at = gpu_agent.trained_at\n        self.name = gpu_agent.name\n\n        return solver_history\n\n    xp = np if not self.on_gpu else cp\n\n    # Getting model\n    model = self.model\n\n    # Initial belief\n    if initial_belief is None:\n        belief_set = BeliefSet(model, [Belief(model)])\n    elif isinstance(initial_belief, BeliefSet):\n        belief_set = initial_belief.to_gpu() if self.on_gpu else initial_belief\n    else:\n        initial_belief = Belief(model, xp.array(initial_belief.values))\n        belief_set = BeliefSet(model, [initial_belief])\n\n    # Handeling the case where the agent is already trained\n    if (self.value_function is not None):\n        if overwrite_training:\n            print('[warning] The value function is being overwritten')\n            self.trained_at = None\n            self.name = '-'.join(self.name.split('-')[:-1])\n            self.value_function = None\n        else:\n            initial_value_function = self.value_function\n\n    # Initial value function\n    if initial_value_function is None:\n        value_function = ValueFunction(model, model.expected_rewards_table.T, model.actions)\n    else:\n        value_function = initial_value_function.to_gpu() if self.on_gpu else initial_value_function\n\n    # Convergence check boundary\n    max_allowed_change = eps * (gamma / (1-gamma))\n\n    # History tracking\n    training_history = TrainingHistory(tracking_level=history_tracking_level,\n                                       model=model,\n                                       gamma=gamma,\n                                       eps=eps,\n                                       expand_append=full_backup,\n                                       initial_value_function=value_function,\n                                       initial_belief_set=belief_set)\n\n    # Loop\n    iteration = 0\n    expand_value_function = value_function\n    old_value_function = value_function\n\n    try:\n        iterator = trange(expansions, desc='Expansions') if print_progress else range(expansions)\n        iterator_postfix = {}\n        for expansion_i in iterator:\n\n            # 1: Expand belief set\n            start_ts = datetime.now()\n\n            new_belief_set = self.expand(belief_set=belief_set,\n                                         value_function=value_function,\n                                         max_generation=max_belief_growth,\n                                         **expand_arguments)\n\n            # Add new beliefs points to the total belief_set\n            belief_set = belief_set.union(new_belief_set)\n\n            expand_time = (datetime.now() - start_ts).total_seconds()\n            training_history.add_expand_step(expansion_time=expand_time, belief_set=belief_set)\n\n            # 2: Backup, update value function (alpha vector set)\n            for _ in range(update_passes) if (not print_progress or update_passes &lt;= 1) else trange(update_passes, desc=f'Backups {expansion_i}'):\n                start_ts = datetime.now()\n\n                # Backup step\n                value_function = self.backup(belief_set if full_backup else new_belief_set,\n                                             value_function,\n                                             gamma=gamma,\n                                             append=(not full_backup),\n                                             belief_dominance_prune=False)\n                backup_time = (datetime.now() - start_ts).total_seconds()\n\n                # Additional pruning\n                if (iteration % prune_interval) == 0 and iteration &gt; 0:\n                    start_ts = datetime.now()\n                    vf_len = len(value_function)\n\n                    value_function.prune(prune_level)\n\n                    prune_time = (datetime.now() - start_ts).total_seconds()\n                    alpha_vectors_pruned = len(value_function) - vf_len\n                    training_history.add_prune_step(prune_time, alpha_vectors_pruned)\n\n                # Check if value function size is above threshold\n                if limit_value_function_size &gt;= 0 and len(value_function) &gt; limit_value_function_size:\n                    # Compute matrix multiplications between avs and beliefs\n                    alpha_value_per_belief = xp.matmul(value_function.alpha_vector_array, belief_set.belief_array.T)\n\n                    # Select the useful alpha vectors\n                    best_alpha_vector_per_belief = xp.argmax(alpha_value_per_belief, axis=0)\n                    useful_alpha_vectors = xp.unique(best_alpha_vector_per_belief)\n\n                    # Select a random selection of vectors to delete\n                    unuseful_alpha_vectors = xp.delete(xp.arange(len(value_function)), useful_alpha_vectors)\n                    random_vectors_to_delete = self.rnd_state.choice(unuseful_alpha_vectors,\n                                                                     size=max_belief_growth,\n                                                                     p=(xp.arange(len(unuseful_alpha_vectors))[::-1] / xp.sum(xp.arange(len(unuseful_alpha_vectors)))))\n                                                                     # replace=False,\n                                                                     # p=1/len(unuseful_alpha_vectors))\n\n                    value_function = ValueFunction(model=model,\n                                                   alpha_vectors=xp.delete(value_function.alpha_vector_array, random_vectors_to_delete, axis=0),\n                                                   action_list=xp.delete(value_function.actions, random_vectors_to_delete))\n\n                    iterator_postfix['|useful|'] = useful_alpha_vectors.shape[0]\n\n                # Compute the change between value functions\n                max_change = self.compute_change(value_function, old_value_function, belief_set)\n\n                # History tracking\n                training_history.add_backup_step(backup_time, max_change, value_function)\n\n                # Convergence check\n                if max_change &lt; max_allowed_change:\n                    break\n\n                old_value_function = value_function\n\n                # Update iteration counter\n                iteration += 1\n\n            # Compute change with old expansion value function\n            expand_max_change = self.compute_change(expand_value_function, value_function, belief_set)\n\n            if expand_max_change &lt; max_allowed_change:\n                if print_progress:\n                    print('Converged!')\n                break\n\n            expand_value_function = value_function\n\n            iterator_postfix['|V|'] = len(value_function)\n            iterator_postfix['|B|'] = len(belief_set)\n\n            if print_progress:\n                iterator.set_postfix(iterator_postfix)\n\n    except MemoryError as e:\n        print(f'Memory full: {e}')\n        print('Returning value function and history as is...\\n')\n\n    # Final pruning\n    start_ts = datetime.now()\n    vf_len = len(value_function)\n\n    value_function.prune(prune_level)\n\n    # History tracking\n    prune_time = (datetime.now() - start_ts).total_seconds()\n    alpha_vectors_pruned = len(value_function) - vf_len\n    training_history.add_prune_step(prune_time, alpha_vectors_pruned)\n\n    # Record when it was trained\n    self.trained_at = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    self.name += f'-trained_{self.trained_at}'\n\n    # Saving value function\n    self.value_function = value_function\n\n    # Print stats if requested\n    if print_stats:\n        print(training_history.summary)\n\n    return training_history\n</code></pre>"},{"location":"reference/agents/pbvi_agent/#olfactory_navigation.agents.pbvi_agent.PBVI_Agent.update_state","title":"<code>update_state(action, observation, source_reached)</code>","text":"<p>Function to update the internal state(s) of the agent(s) based on the previous action(s) taken and the observation(s) received.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>ndarray</code> <p>A 2D array of n movement vectors. If the environment is layered, the 1st component should be the layer.</p> required <code>observation</code> <code>ndarray</code> <p>The observation(s) the agent(s) made.</p> required <code>source_reached</code> <code>ndarray</code> <p>A boolean array of whether the agent(s) have reached the source or not.</p> required <p>Returns:</p> Name Type Description <code>update_successfull</code> <code>(ndarray, optional)</code> <p>If nothing is returned, it means all the agent's state updates have been successfull. Else, a boolean np.ndarray of size n can be returned confirming for each agent whether the update has been successful or not.</p> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def update_state(self,\n                 action: np.ndarray,\n                 observation: np.ndarray,\n                 source_reached: np.ndarray\n                 ) -&gt; None | np.ndarray:\n    '''\n    Function to update the internal state(s) of the agent(s) based on the previous action(s) taken and the observation(s) received.\n\n    Parameters\n    ----------\n    action : np.ndarray\n        A 2D array of n movement vectors. If the environment is layered, the 1st component should be the layer.\n    observation : np.ndarray\n        The observation(s) the agent(s) made.\n    source_reached : np.ndarray\n        A boolean array of whether the agent(s) have reached the source or not.\n\n    Returns\n    -------\n    update_successfull : np.ndarray, optional\n        If nothing is returned, it means all the agent's state updates have been successfull.\n        Else, a boolean np.ndarray of size n can be returned confirming for each agent whether the update has been successful or not.\n    '''\n    assert self.belief is not None, \"Agent was not initialized yet, run the initialize_state function first\"\n\n    # Discretizing observations\n    observation_ids = self.discretize_observations(observation=observation, action=action, source_reached=source_reached)\n\n    # Update the set of beliefs\n    self.belief = self.belief.update(actions=self.action_played, observations=observation_ids, throw_error=False)\n\n    # Check for failed updates\n    update_successful = (self.belief.belief_array.sum(axis=1) != 0.0)\n\n    return update_successful\n</code></pre>"},{"location":"reference/agents/pbvi_agent/#olfactory_navigation.agents.pbvi_agent.TrainingHistory","title":"<code>TrainingHistory</code>","text":"<p>Class to represent the history of a solver for a POMDP solver. It has mainly the purpose to have visualizations for the solution, belief set and the whole solving history. The visualizations available are:     - Belief set plot     - Solution plot     - Video of value function and belief set evolution over training.</p> <p>Parameters:</p> Name Type Description Default <code>tracking_level</code> <code>int</code> <p>The tracking level of the solver.</p> required <code>model</code> <code>Model</code> <p>The model the solver has solved.</p> required <code>gamma</code> <code>float</code> <p>The gamma parameter used by the solver (learning rate).</p> required <code>eps</code> <code>float</code> <p>The epsilon parameter used by the solver (covergence bound).</p> required <code>expand_append</code> <code>bool</code> <p>Whether the expand function appends new belief points to the belief set of reloads it all.</p> required <code>initial_value_function</code> <code>ValueFunction</code> <p>The initial value function the solver will use to start the solving process.</p> required <code>initial_belief_set</code> <code>BeliefSet</code> <p>The initial belief set the solver will use to start the solving process.</p> required <p>Attributes:</p> Name Type Description <code>tracking_level</code> <code>int</code> <code>model</code> <code>Model</code> <code>gamma</code> <code>float</code> <code>eps</code> <code>float</code> <code>expand_append</code> <code>bool</code> <code>run_ts</code> <code>datetime</code> <p>The time at which the SolverHistory object was instantiated which is assumed to be the start of the solving run.</p> <code>expansion_times</code> <code>list[float]</code> <p>A list of recorded times of the expand function.</p> <code>backup_times</code> <code>list[float]</code> <p>A list of recorded times of the backup function.</p> <code>alpha_vector_counts</code> <code>list[int]</code> <p>A list of recorded alpha vector count making up the value function over the solving process.</p> <code>beliefs_counts</code> <code>list[int]</code> <p>A list of recorded belief count making up the belief set over the solving process.</p> <code>value_function_changes</code> <code>list[float]</code> <p>A list of recorded value function changes (the maximum changed value between 2 value functions).</p> <code>value_functions</code> <code>list[ValueFunction]</code> <p>A list of recorded value functions.</p> <code>belief_sets</code> <code>list[BeliefSet]</code> <p>A list of recorded belief sets.</p> <code>solution</code> <code>ValueFunction</code> <code>explored_beliefs</code> <code>BeliefSet</code> Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>class TrainingHistory:\n    '''\n    Class to represent the history of a solver for a POMDP solver.\n    It has mainly the purpose to have visualizations for the solution, belief set and the whole solving history.\n    The visualizations available are:\n        - Belief set plot\n        - Solution plot\n        - Video of value function and belief set evolution over training.\n\n\n    Parameters\n    ----------\n    tracking_level : int\n        The tracking level of the solver.\n    model : Model\n        The model the solver has solved.\n    gamma : float\n        The gamma parameter used by the solver (learning rate).\n    eps : float\n        The epsilon parameter used by the solver (covergence bound).\n    expand_append : bool\n        Whether the expand function appends new belief points to the belief set of reloads it all.\n    initial_value_function : ValueFunction\n        The initial value function the solver will use to start the solving process.\n    initial_belief_set : BeliefSet\n        The initial belief set the solver will use to start the solving process.\n\n    Attributes\n    ----------\n    tracking_level : int\n    model : Model\n    gamma : float\n    eps : float\n    expand_append : bool\n    run_ts : datetime\n        The time at which the SolverHistory object was instantiated which is assumed to be the start of the solving run.\n    expansion_times : list[float]\n        A list of recorded times of the expand function.\n    backup_times : list[float]\n        A list of recorded times of the backup function.\n    alpha_vector_counts : list[int]\n        A list of recorded alpha vector count making up the value function over the solving process.\n    beliefs_counts : list[int]\n        A list of recorded belief count making up the belief set over the solving process.\n    value_function_changes : list[float]\n        A list of recorded value function changes (the maximum changed value between 2 value functions).\n    value_functions : list[ValueFunction]\n        A list of recorded value functions.\n    belief_sets : list[BeliefSet]\n        A list of recorded belief sets.\n    solution : ValueFunction\n    explored_beliefs : BeliefSet\n    '''\n    def __init__(self,\n                 tracking_level: int,\n                 model: Model,\n                 gamma: float,\n                 eps: float,\n                 expand_append: bool,\n                 initial_value_function: ValueFunction,\n                 initial_belief_set: BeliefSet\n                 ):\n\n        self.tracking_level = tracking_level\n        self.model = model\n        self.gamma = gamma\n        self.eps = eps\n        self.run_ts = datetime.now()\n\n        self.expand_append = expand_append\n\n        # Time tracking\n        self.expansion_times = []\n        self.backup_times = []\n        self.pruning_times = []\n\n        # Value function and belief set sizes tracking\n        self.alpha_vector_counts = []\n        self.beliefs_counts = []\n        self.prune_counts = []\n\n        if self.tracking_level &gt;= 1:\n            self.alpha_vector_counts.append(len(initial_value_function))\n            self.beliefs_counts.append(len(initial_belief_set))\n\n        # Value function and belief set tracking\n        self.belief_sets = []\n        self.value_functions = []\n        self.value_function_changes = []\n\n        if self.tracking_level &gt;= 2:\n            self.belief_sets.append(initial_belief_set)\n            self.value_functions.append(initial_value_function)\n\n\n    @property\n    def solution(self) -&gt; ValueFunction:\n        '''\n        The last value function of the solving process.\n        '''\n        assert self.tracking_level &gt;= 2, \"Tracking level is set too low, increase it to 2 if you want to have value function tracking as well.\"\n        return self.value_functions[-1]\n\n\n    @property\n    def explored_beliefs(self) -&gt; BeliefSet:\n        '''\n        The final set of beliefs explored during the solving.\n        '''\n        assert self.tracking_level &gt;= 2, \"Tracking level is set too low, increase it to 2 if you want to have belief sets tracking as well.\"\n        return self.belief_sets[-1]\n\n\n    def add_expand_step(self,\n                        expansion_time: float,\n                        belief_set: BeliefSet\n                        ) -&gt; None:\n        '''\n        Function to add an expansion step in the simulation history by the explored belief set the expand function generated.\n\n        Parameters\n        ----------\n        expansion_time : float\n            The time it took to run a step of expansion of the belief set. (Also known as the exploration step.)\n        belief_set : BeliefSet\n            The belief set used for the Update step of the solving process.\n        '''\n        if self.tracking_level &gt;= 1:\n            self.expansion_times.append(float(expansion_time))\n            self.beliefs_counts.append(len(belief_set))\n\n        if self.tracking_level &gt;= 2:\n            self.belief_sets.append(belief_set if not belief_set.is_on_gpu else belief_set.to_cpu())\n\n\n    def add_backup_step(self,\n                        backup_time: float,\n                        value_function_change: float,\n                        value_function: ValueFunction\n                        ) -&gt; None:\n        '''\n        Function to add a backup step in the simulation history by recording the value function the backup function generated.\n\n        Parameters\n        ----------\n        backup_time : float\n            The time it took to run a step of backup of the value function. (Also known as the value function update.)\n        value_function_change : float\n            The change between the value function of this iteration and of the previous iteration.\n        value_function : ValueFunction\n            The value function resulting after a step of the solving process.\n        '''\n        if self.tracking_level &gt;= 1:\n            self.backup_times.append(float(backup_time))\n            self.alpha_vector_counts.append(len(value_function))\n            self.value_function_changes.append(float(value_function_change))\n\n        if self.tracking_level &gt;= 2:\n            self.value_functions.append(value_function if not value_function.is_on_gpu else value_function.to_cpu())\n\n\n    def add_prune_step(self,\n                       prune_time: float,\n                       alpha_vectors_pruned: int\n                       ) -&gt; None:\n        '''\n        Function to add a prune step in the simulation history by recording the amount of alpha vectors that were pruned by the pruning function and how long it took.\n\n        Parameters\n        ----------\n        prune_time : float\n            The time it took to run the pruning step.\n        alpha_vectors_pruned : int\n            How many alpha vectors were pruned.\n        '''\n        if self.tracking_level &gt;= 1:\n            self.pruning_times.append(prune_time)\n            self.prune_counts.append(alpha_vectors_pruned)\n\n\n    @property\n    def summary(self) -&gt; str:\n        '''\n        A summary as a string of the information recorded.\n        '''\n        summary_str =  f'Summary of Point Based Value Iteration run'\n        summary_str += f'\\n  - Model: {self.model.state_count} state, {self.model.action_count} action, {self.model.observation_count} observations'\n        summary_str += f'\\n  - Converged or stopped after {len(self.expansion_times)} expansion steps and {len(self.backup_times)} backup steps.'\n\n        if self.tracking_level &gt;= 1:\n            summary_str += f'\\n  - Resulting value function has {self.alpha_vector_counts[-1]} alpha vectors.'\n            summary_str += f'\\n  - Converged in {(sum(self.expansion_times) + sum(self.backup_times)):.4f}s'\n            summary_str += f'\\n'\n\n            summary_str += f'\\n  - Expand function took on average {sum(self.expansion_times) / len(self.expansion_times):.4f}s '\n            if self.expand_append:\n                summary_str += f'and yielded on average {sum(np.diff(self.beliefs_counts)) / len(self.beliefs_counts[1:]):.2f} beliefs per iteration.'\n            else:\n                summary_str += f'and yielded on average {sum(self.beliefs_counts[1:]) / len(self.beliefs_counts[1:]):.2f} beliefs per iteration.'\n            summary_str += f' ({np.sum(np.divide(self.expansion_times, self.beliefs_counts[1:])) / len(self.expansion_times):.4f}s/it/belief)'\n\n            summary_str += f'\\n  - Backup function took on average {sum(self.backup_times) /len(self.backup_times):.4f}s '\n            summary_str += f'and yielded on average {np.average(np.diff(self.alpha_vector_counts)):.2f} alpha vectors per iteration.'\n            summary_str += f' ({np.sum(np.divide(self.backup_times, self.alpha_vector_counts[1:])) / len(self.backup_times):.4f}s/it/alpha)'\n\n            summary_str += f'\\n  - Pruning function took on average {sum(self.pruning_times) /len(self.pruning_times):.4f}s '\n            summary_str += f'and yielded on average prunings of {sum(self.prune_counts) / len(self.prune_counts):.2f} alpha vectors per iteration.'\n\n        return summary_str\n</code></pre>"},{"location":"reference/agents/pbvi_agent/#olfactory_navigation.agents.pbvi_agent.TrainingHistory.explored_beliefs","title":"<code>explored_beliefs</code>  <code>property</code>","text":"<p>The final set of beliefs explored during the solving.</p>"},{"location":"reference/agents/pbvi_agent/#olfactory_navigation.agents.pbvi_agent.TrainingHistory.solution","title":"<code>solution</code>  <code>property</code>","text":"<p>The last value function of the solving process.</p>"},{"location":"reference/agents/pbvi_agent/#olfactory_navigation.agents.pbvi_agent.TrainingHistory.summary","title":"<code>summary</code>  <code>property</code>","text":"<p>A summary as a string of the information recorded.</p>"},{"location":"reference/agents/pbvi_agent/#olfactory_navigation.agents.pbvi_agent.TrainingHistory.add_backup_step","title":"<code>add_backup_step(backup_time, value_function_change, value_function)</code>","text":"<p>Function to add a backup step in the simulation history by recording the value function the backup function generated.</p> <p>Parameters:</p> Name Type Description Default <code>backup_time</code> <code>float</code> <p>The time it took to run a step of backup of the value function. (Also known as the value function update.)</p> required <code>value_function_change</code> <code>float</code> <p>The change between the value function of this iteration and of the previous iteration.</p> required <code>value_function</code> <code>ValueFunction</code> <p>The value function resulting after a step of the solving process.</p> required Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def add_backup_step(self,\n                    backup_time: float,\n                    value_function_change: float,\n                    value_function: ValueFunction\n                    ) -&gt; None:\n    '''\n    Function to add a backup step in the simulation history by recording the value function the backup function generated.\n\n    Parameters\n    ----------\n    backup_time : float\n        The time it took to run a step of backup of the value function. (Also known as the value function update.)\n    value_function_change : float\n        The change between the value function of this iteration and of the previous iteration.\n    value_function : ValueFunction\n        The value function resulting after a step of the solving process.\n    '''\n    if self.tracking_level &gt;= 1:\n        self.backup_times.append(float(backup_time))\n        self.alpha_vector_counts.append(len(value_function))\n        self.value_function_changes.append(float(value_function_change))\n\n    if self.tracking_level &gt;= 2:\n        self.value_functions.append(value_function if not value_function.is_on_gpu else value_function.to_cpu())\n</code></pre>"},{"location":"reference/agents/pbvi_agent/#olfactory_navigation.agents.pbvi_agent.TrainingHistory.add_expand_step","title":"<code>add_expand_step(expansion_time, belief_set)</code>","text":"<p>Function to add an expansion step in the simulation history by the explored belief set the expand function generated.</p> <p>Parameters:</p> Name Type Description Default <code>expansion_time</code> <code>float</code> <p>The time it took to run a step of expansion of the belief set. (Also known as the exploration step.)</p> required <code>belief_set</code> <code>BeliefSet</code> <p>The belief set used for the Update step of the solving process.</p> required Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def add_expand_step(self,\n                    expansion_time: float,\n                    belief_set: BeliefSet\n                    ) -&gt; None:\n    '''\n    Function to add an expansion step in the simulation history by the explored belief set the expand function generated.\n\n    Parameters\n    ----------\n    expansion_time : float\n        The time it took to run a step of expansion of the belief set. (Also known as the exploration step.)\n    belief_set : BeliefSet\n        The belief set used for the Update step of the solving process.\n    '''\n    if self.tracking_level &gt;= 1:\n        self.expansion_times.append(float(expansion_time))\n        self.beliefs_counts.append(len(belief_set))\n\n    if self.tracking_level &gt;= 2:\n        self.belief_sets.append(belief_set if not belief_set.is_on_gpu else belief_set.to_cpu())\n</code></pre>"},{"location":"reference/agents/pbvi_agent/#olfactory_navigation.agents.pbvi_agent.TrainingHistory.add_prune_step","title":"<code>add_prune_step(prune_time, alpha_vectors_pruned)</code>","text":"<p>Function to add a prune step in the simulation history by recording the amount of alpha vectors that were pruned by the pruning function and how long it took.</p> <p>Parameters:</p> Name Type Description Default <code>prune_time</code> <code>float</code> <p>The time it took to run the pruning step.</p> required <code>alpha_vectors_pruned</code> <code>int</code> <p>How many alpha vectors were pruned.</p> required Source code in <code>olfactory_navigation/agents/pbvi_agent.py</code> <pre><code>def add_prune_step(self,\n                   prune_time: float,\n                   alpha_vectors_pruned: int\n                   ) -&gt; None:\n    '''\n    Function to add a prune step in the simulation history by recording the amount of alpha vectors that were pruned by the pruning function and how long it took.\n\n    Parameters\n    ----------\n    prune_time : float\n        The time it took to run the pruning step.\n    alpha_vectors_pruned : int\n        How many alpha vectors were pruned.\n    '''\n    if self.tracking_level &gt;= 1:\n        self.pruning_times.append(prune_time)\n        self.prune_counts.append(alpha_vectors_pruned)\n</code></pre>"},{"location":"reference/agents/pbvi_ger_agent/","title":"pbvi_ger_agent","text":""},{"location":"reference/agents/pbvi_ger_agent/#olfactory_navigation.agents.pbvi_ger_agent.PBVI_GER_Agent","title":"<code>PBVI_GER_Agent</code>","text":"<p>               Bases: <code>PBVI_Agent</code></p> <p>A flavor of the PBVI Agent. The expand function consists in choosing belief points that will most decrease the error in the value function (so increasing most the value).</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment to train the agent with.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.</p> <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <code>model</code> <code>Model</code> <p>A POMDP model to use to represent the olfactory environment. If not provided, the environment_converter parameter will be used.</p> <code>None</code> <code>environment_converter</code> <code>Callable</code> <p>A function to convert the olfactory environment instance to a POMDP Model instance. By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model. This parameter will be ignored if the model parameter is provided.</p> <code>exact_converter</code> <code>converter_parameters</code> <code>dict</code> <p>A set of additional parameters to be passed down to the environment converter.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>model</code> <code>Model</code> <p>The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.</p> <code>saved_at</code> <code>str</code> <p>The place on disk where the agent has been saved (None if not saved yet).</p> <code>on_gpu</code> <code>bool</code> <p>Whether the agent has been sent to the gpu or not.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>trained_at</code> <code>str</code> <p>A string timestamp of when the agent has been trained (None if not trained yet).</p> <code>value_function</code> <code>ValueFunction</code> <p>The value function used for the agent to make decisions.</p> <code>belief</code> <code>BeliefSet</code> <p>Used only during simulations. Part of the Agent's status. Where the agent believes he is over the state space. It is a list of n belief points based on how many simulations are running at once.</p> <code>action_played</code> <code>list[int]</code> <p>Used only during simulations. Part of the Agent's status. Records what action was last played by the agent. A list of n actions played based on how many simulations are running at once.</p> Source code in <code>olfactory_navigation/agents/pbvi_ger_agent.py</code> <pre><code>class PBVI_GER_Agent(PBVI_Agent):\n    '''\n    A flavor of the PBVI Agent. The expand function consists in choosing belief points that will most decrease the error in the value function (so increasing most the value).\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment to train the agent with.\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.\n    seed : int, default=12131415\n        For reproducible randomness.\n    model : Model, optional\n        A POMDP model to use to represent the olfactory environment.\n        If not provided, the environment_converter parameter will be used.\n    environment_converter : Callable, default=exact_converter\n        A function to convert the olfactory environment instance to a POMDP Model instance.\n        By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model.\n        This parameter will be ignored if the model parameter is provided.\n    converter_parameters : dict, optional\n        A set of additional parameters to be passed down to the environment converter.\n\n    Attributes\n    ---------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    model : pomdp.Model\n        The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.\n    saved_at : str\n        The place on disk where the agent has been saved (None if not saved yet).\n    on_gpu : bool\n        Whether the agent has been sent to the gpu or not.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    trained_at : str\n        A string timestamp of when the agent has been trained (None if not trained yet).\n    value_function : ValueFunction\n        The value function used for the agent to make decisions.\n    belief : BeliefSet\n        Used only during simulations.\n        Part of the Agent's status. Where the agent believes he is over the state space.\n        It is a list of n belief points based on how many simulations are running at once.\n    action_played : list[int]\n        Used only during simulations.\n        Part of the Agent's status. Records what action was last played by the agent.\n        A list of n actions played based on how many simulations are running at once.\n    '''\n    def expand(self,\n               belief_set: BeliefSet,\n               value_function: ValueFunction,\n               max_generation: int\n               ) -&gt; BeliefSet:\n        '''\n        Greedy Error Reduction.\n        It attempts to choose the believes that will maximize the improvement of the value function by minimizing the error.\n        The error is computed by the sum of the change between two beliefs and their two corresponding alpha vectors.\n\n        Parameters\n        ----------\n        belief_set : BeliefSet\n            List of beliefs to expand on.\n        value_function : ValueFunction\n            The current value function. Used to compute the value at belief points.\n        max_generation : int, default=10\n            The max amount of beliefs that can be added to the belief set at once.\n\n        Returns\n        -------\n        belief_set_new : BeliefSet\n            Union of the belief_set and the expansions of the beliefs in the belief_set.\n        '''\n        # GPU support\n        xp = np if not self.on_gpu else cp\n        model = self.model\n\n        old_shape = belief_set.belief_array.shape\n        to_generate = min(max_generation, old_shape[0])\n\n        new_belief_array = xp.empty((old_shape[0] + to_generate, old_shape[1]))\n        new_belief_array[:old_shape[0]] = belief_set.belief_array\n\n        # Finding the min and max rewards for computation of the epsilon\n        r_min = model._min_reward / (1 - self.gamma)\n        r_max = model._max_reward / (1 - self.gamma)\n\n        # Generation of all potential successor beliefs\n        successor_beliefs = xp.array([[[b.update(a,o).values for o in model.observations] for a in model.actions] for b in belief_set.belief_list])\n\n        # Finding the alphas associated with each previous beliefs\n        best_alpha = xp.argmax(xp.dot(belief_set.belief_array, value_function.alpha_vector_array.T), axis = 1)\n        b_alphas = value_function.alpha_vector_array[best_alpha]\n\n        # Difference between beliefs and their successors\n        b_diffs = successor_beliefs - belief_set.belief_array[:,None,None,:]\n\n        # Computing a 'next' alpha vector made of the max and min\n        alphas_p = xp.where(b_diffs &gt;= 0, r_max, r_min)\n\n        # Difference between alpha vectors and their successors alpha vector\n        alphas_diffs = alphas_p - b_alphas[:,None,None,:]\n\n        # Computing epsilon for all successor beliefs\n        eps = xp.einsum('baos,baos-&gt;bao', alphas_diffs, b_diffs)\n\n        # Computing the probability of the b and doing action a and receiving observation o\n        bao_probs = xp.einsum('bs,saor-&gt;bao', belief_set.belief_array, model.reachable_transitional_observation_table)\n\n        # Taking the sumproduct of the probs with the epsilons\n        res = xp.einsum('bao,bao-&gt;ba', bao_probs, eps)\n\n        # Picking the correct amount of initial beliefs and ideal actions\n        b_stars, a_stars = xp.unravel_index(xp.argsort(res, axis=None)[::-1][:to_generate], res.shape)\n\n        # And picking the ideal observations\n        o_star = xp.argmax(bao_probs[b_stars[:,None], a_stars[:,None], model.observations[None,:]] * eps[b_stars[:,None], a_stars[:,None], model.observations[None,:]], axis=1)\n\n        # Selecting the successor beliefs\n        new_belief_array = successor_beliefs[b_stars[:,None], a_stars[:,None], o_star[:,None], model.states[None,:]]\n\n        return BeliefSet(model, new_belief_array)\n\n\n    def train(self,\n              expansions: int,\n              update_passes: int = 1,\n              max_belief_growth: int = 10,\n              initial_belief: BeliefSet | Belief | None = None,\n              initial_value_function: ValueFunction | None = None,\n              prune_level: int = 1,\n              prune_interval: int = 10,\n              limit_value_function_size: int = -1,\n              gamma: float = 0.99,\n              eps: float = 1e-6,\n              use_gpu: bool = False,\n              history_tracking_level: int = 1,\n              overwrite_training: bool = False,\n              print_progress: bool = True,\n              print_stats: bool = True\n              ) -&gt; TrainingHistory:\n        '''\n        Main loop of the Point-Based Value Iteration algorithm.\n        It consists in 2 steps, Backup and Expand.\n        1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n        2. Backup: Updates the alpha vectors based on the current belief set\n\n        Greedy Error Reduction Point-Based Value Iteration:\n        - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)\n\n        Parameters\n        ----------\n        expansions : int\n            How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n        update_passes : int, default=1\n            How many times the backup function has to be run every time the belief set is expanded.\n        max_belief_growth : int, default=10\n            How many beliefs can be added at every expansion step to the belief set.\n        initial_belief : BeliefSet or Belief, optional\n            An initial list of beliefs to start with.\n        initial_value_function : ValueFunction, optional\n            An initial value function to start the solving process with.\n        prune_level : int, default=1\n            Parameter to prune the value function further before the expand function.\n        prune_interval : int, default=10\n            How often to prune the value function. It is counted in number of backup iterations.\n        limit_value_function_size : int, default=-1\n            When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n            If set to -1, the value function can grow without bounds.\n        use_gpu : bool, default=False\n            Whether to use the GPU with cupy array to accelerate solving.\n        gamma : float, default=0.99\n            The discount factor to value immediate rewards more than long term rewards.\n            The learning rate is 1/gamma.\n        eps : float, default=1e-6\n            The smallest allowed changed for the value function.\n            Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n        history_tracking_level : int, default=1\n            How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n        overwrite_training : bool, default=False\n            Whether to force the overwriting of the training if a value function already exists for this agent.\n        print_progress : bool, default=True\n            Whether or not to print out the progress of the value iteration process.\n        print_stats : bool, default=True\n            Whether or not to print out statistics at the end of the training run.\n\n        Returns\n        -------\n        solver_history : SolverHistory\n            The history of the solving process with some plotting options.\n        '''\n        return super().train(expansions = expansions,\n                             full_backup = True,\n                             update_passes = update_passes,\n                             max_belief_growth = max_belief_growth,\n                             initial_belief = initial_belief,\n                             initial_value_function = initial_value_function,\n                             prune_level = prune_level,\n                             prune_interval = prune_interval,\n                             limit_value_function_size = limit_value_function_size,\n                             gamma = gamma,\n                             eps = eps,\n                             use_gpu = use_gpu,\n                             history_tracking_level = history_tracking_level,\n                             overwrite_training = overwrite_training,\n                             print_progress = print_progress,\n                             print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/pbvi_ger_agent/#olfactory_navigation.agents.pbvi_ger_agent.PBVI_GER_Agent.expand","title":"<code>expand(belief_set, value_function, max_generation)</code>","text":"<p>Greedy Error Reduction. It attempts to choose the believes that will maximize the improvement of the value function by minimizing the error. The error is computed by the sum of the change between two beliefs and their two corresponding alpha vectors.</p> <p>Parameters:</p> Name Type Description Default <code>belief_set</code> <code>BeliefSet</code> <p>List of beliefs to expand on.</p> required <code>value_function</code> <code>ValueFunction</code> <p>The current value function. Used to compute the value at belief points.</p> required <code>max_generation</code> <code>int</code> <p>The max amount of beliefs that can be added to the belief set at once.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>belief_set_new</code> <code>BeliefSet</code> <p>Union of the belief_set and the expansions of the beliefs in the belief_set.</p> Source code in <code>olfactory_navigation/agents/pbvi_ger_agent.py</code> <pre><code>def expand(self,\n           belief_set: BeliefSet,\n           value_function: ValueFunction,\n           max_generation: int\n           ) -&gt; BeliefSet:\n    '''\n    Greedy Error Reduction.\n    It attempts to choose the believes that will maximize the improvement of the value function by minimizing the error.\n    The error is computed by the sum of the change between two beliefs and their two corresponding alpha vectors.\n\n    Parameters\n    ----------\n    belief_set : BeliefSet\n        List of beliefs to expand on.\n    value_function : ValueFunction\n        The current value function. Used to compute the value at belief points.\n    max_generation : int, default=10\n        The max amount of beliefs that can be added to the belief set at once.\n\n    Returns\n    -------\n    belief_set_new : BeliefSet\n        Union of the belief_set and the expansions of the beliefs in the belief_set.\n    '''\n    # GPU support\n    xp = np if not self.on_gpu else cp\n    model = self.model\n\n    old_shape = belief_set.belief_array.shape\n    to_generate = min(max_generation, old_shape[0])\n\n    new_belief_array = xp.empty((old_shape[0] + to_generate, old_shape[1]))\n    new_belief_array[:old_shape[0]] = belief_set.belief_array\n\n    # Finding the min and max rewards for computation of the epsilon\n    r_min = model._min_reward / (1 - self.gamma)\n    r_max = model._max_reward / (1 - self.gamma)\n\n    # Generation of all potential successor beliefs\n    successor_beliefs = xp.array([[[b.update(a,o).values for o in model.observations] for a in model.actions] for b in belief_set.belief_list])\n\n    # Finding the alphas associated with each previous beliefs\n    best_alpha = xp.argmax(xp.dot(belief_set.belief_array, value_function.alpha_vector_array.T), axis = 1)\n    b_alphas = value_function.alpha_vector_array[best_alpha]\n\n    # Difference between beliefs and their successors\n    b_diffs = successor_beliefs - belief_set.belief_array[:,None,None,:]\n\n    # Computing a 'next' alpha vector made of the max and min\n    alphas_p = xp.where(b_diffs &gt;= 0, r_max, r_min)\n\n    # Difference between alpha vectors and their successors alpha vector\n    alphas_diffs = alphas_p - b_alphas[:,None,None,:]\n\n    # Computing epsilon for all successor beliefs\n    eps = xp.einsum('baos,baos-&gt;bao', alphas_diffs, b_diffs)\n\n    # Computing the probability of the b and doing action a and receiving observation o\n    bao_probs = xp.einsum('bs,saor-&gt;bao', belief_set.belief_array, model.reachable_transitional_observation_table)\n\n    # Taking the sumproduct of the probs with the epsilons\n    res = xp.einsum('bao,bao-&gt;ba', bao_probs, eps)\n\n    # Picking the correct amount of initial beliefs and ideal actions\n    b_stars, a_stars = xp.unravel_index(xp.argsort(res, axis=None)[::-1][:to_generate], res.shape)\n\n    # And picking the ideal observations\n    o_star = xp.argmax(bao_probs[b_stars[:,None], a_stars[:,None], model.observations[None,:]] * eps[b_stars[:,None], a_stars[:,None], model.observations[None,:]], axis=1)\n\n    # Selecting the successor beliefs\n    new_belief_array = successor_beliefs[b_stars[:,None], a_stars[:,None], o_star[:,None], model.states[None,:]]\n\n    return BeliefSet(model, new_belief_array)\n</code></pre>"},{"location":"reference/agents/pbvi_ger_agent/#olfactory_navigation.agents.pbvi_ger_agent.PBVI_GER_Agent.train","title":"<code>train(expansions, update_passes=1, max_belief_growth=10, initial_belief=None, initial_value_function=None, prune_level=1, prune_interval=10, limit_value_function_size=-1, gamma=0.99, eps=1e-06, use_gpu=False, history_tracking_level=1, overwrite_training=False, print_progress=True, print_stats=True)</code>","text":"<p>Main loop of the Point-Based Value Iteration algorithm. It consists in 2 steps, Backup and Expand. 1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function 2. Backup: Updates the alpha vectors based on the current belief set</p> <p>Greedy Error Reduction Point-Based Value Iteration: - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)</p> <p>Parameters:</p> Name Type Description Default <code>expansions</code> <code>int</code> <p>How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)</p> required <code>update_passes</code> <code>int</code> <p>How many times the backup function has to be run every time the belief set is expanded.</p> <code>1</code> <code>max_belief_growth</code> <code>int</code> <p>How many beliefs can be added at every expansion step to the belief set.</p> <code>10</code> <code>initial_belief</code> <code>BeliefSet or Belief</code> <p>An initial list of beliefs to start with.</p> <code>None</code> <code>initial_value_function</code> <code>ValueFunction</code> <p>An initial value function to start the solving process with.</p> <code>None</code> <code>prune_level</code> <code>int</code> <p>Parameter to prune the value function further before the expand function.</p> <code>1</code> <code>prune_interval</code> <code>int</code> <p>How often to prune the value function. It is counted in number of backup iterations.</p> <code>10</code> <code>limit_value_function_size</code> <code>int</code> <p>When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function If set to -1, the value function can grow without bounds.</p> <code>-1</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU with cupy array to accelerate solving.</p> <code>False</code> <code>gamma</code> <code>float</code> <p>The discount factor to value immediate rewards more than long term rewards. The learning rate is 1/gamma.</p> <code>0.99</code> <code>eps</code> <code>float</code> <p>The smallest allowed changed for the value function. Bellow the amound of change, the value function is considered converged and the value iteration process will end early.</p> <code>1e-6</code> <code>history_tracking_level</code> <code>int</code> <p>How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)</p> <code>1</code> <code>overwrite_training</code> <code>bool</code> <p>Whether to force the overwriting of the training if a value function already exists for this agent.</p> <code>False</code> <code>print_progress</code> <code>bool</code> <p>Whether or not to print out the progress of the value iteration process.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether or not to print out statistics at the end of the training run.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>solver_history</code> <code>SolverHistory</code> <p>The history of the solving process with some plotting options.</p> Source code in <code>olfactory_navigation/agents/pbvi_ger_agent.py</code> <pre><code>def train(self,\n          expansions: int,\n          update_passes: int = 1,\n          max_belief_growth: int = 10,\n          initial_belief: BeliefSet | Belief | None = None,\n          initial_value_function: ValueFunction | None = None,\n          prune_level: int = 1,\n          prune_interval: int = 10,\n          limit_value_function_size: int = -1,\n          gamma: float = 0.99,\n          eps: float = 1e-6,\n          use_gpu: bool = False,\n          history_tracking_level: int = 1,\n          overwrite_training: bool = False,\n          print_progress: bool = True,\n          print_stats: bool = True\n          ) -&gt; TrainingHistory:\n    '''\n    Main loop of the Point-Based Value Iteration algorithm.\n    It consists in 2 steps, Backup and Expand.\n    1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n    2. Backup: Updates the alpha vectors based on the current belief set\n\n    Greedy Error Reduction Point-Based Value Iteration:\n    - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)\n\n    Parameters\n    ----------\n    expansions : int\n        How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n    update_passes : int, default=1\n        How many times the backup function has to be run every time the belief set is expanded.\n    max_belief_growth : int, default=10\n        How many beliefs can be added at every expansion step to the belief set.\n    initial_belief : BeliefSet or Belief, optional\n        An initial list of beliefs to start with.\n    initial_value_function : ValueFunction, optional\n        An initial value function to start the solving process with.\n    prune_level : int, default=1\n        Parameter to prune the value function further before the expand function.\n    prune_interval : int, default=10\n        How often to prune the value function. It is counted in number of backup iterations.\n    limit_value_function_size : int, default=-1\n        When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n        If set to -1, the value function can grow without bounds.\n    use_gpu : bool, default=False\n        Whether to use the GPU with cupy array to accelerate solving.\n    gamma : float, default=0.99\n        The discount factor to value immediate rewards more than long term rewards.\n        The learning rate is 1/gamma.\n    eps : float, default=1e-6\n        The smallest allowed changed for the value function.\n        Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n    history_tracking_level : int, default=1\n        How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n    overwrite_training : bool, default=False\n        Whether to force the overwriting of the training if a value function already exists for this agent.\n    print_progress : bool, default=True\n        Whether or not to print out the progress of the value iteration process.\n    print_stats : bool, default=True\n        Whether or not to print out statistics at the end of the training run.\n\n    Returns\n    -------\n    solver_history : SolverHistory\n        The history of the solving process with some plotting options.\n    '''\n    return super().train(expansions = expansions,\n                         full_backup = True,\n                         update_passes = update_passes,\n                         max_belief_growth = max_belief_growth,\n                         initial_belief = initial_belief,\n                         initial_value_function = initial_value_function,\n                         prune_level = prune_level,\n                         prune_interval = prune_interval,\n                         limit_value_function_size = limit_value_function_size,\n                         gamma = gamma,\n                         eps = eps,\n                         use_gpu = use_gpu,\n                         history_tracking_level = history_tracking_level,\n                         overwrite_training = overwrite_training,\n                         print_progress = print_progress,\n                         print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/pbvi_ra_agent/","title":"pbvi_ra_agent","text":""},{"location":"reference/agents/pbvi_ra_agent/#olfactory_navigation.agents.pbvi_ra_agent.PBVI_RA_Agent","title":"<code>PBVI_RA_Agent</code>","text":"<p>               Bases: <code>PBVI_Agent</code></p> <p>A flavor of the PBVI Agent. The expand function consists in choosing random belief points.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment to train the agent with.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.</p> <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <code>model</code> <code>Model</code> <p>A POMDP model to use to represent the olfactory environment. If not provided, the environment_converter parameter will be used.</p> <code>None</code> <code>environment_converter</code> <code>Callable</code> <p>A function to convert the olfactory environment instance to a POMDP Model instance. By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model. This parameter will be ignored if the model parameter is provided.</p> <code>exact_converter</code> <code>converter_parameters</code> <code>dict</code> <p>A set of additional parameters to be passed down to the environment converter.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>model</code> <code>Model</code> <p>The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.</p> <code>saved_at</code> <code>str</code> <p>The place on disk where the agent has been saved (None if not saved yet).</p> <code>on_gpu</code> <code>bool</code> <p>Whether the agent has been sent to the gpu or not.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>trained_at</code> <code>str</code> <p>A string timestamp of when the agent has been trained (None if not trained yet).</p> <code>value_function</code> <code>ValueFunction</code> <p>The value function used for the agent to make decisions.</p> <code>belief</code> <code>BeliefSet</code> <p>Used only during simulations. Part of the Agent's status. Where the agent believes he is over the state space. It is a list of n belief points based on how many simulations are running at once.</p> <code>action_played</code> <code>list[int]</code> <p>Used only during simulations. Part of the Agent's status. Records what action was last played by the agent. A list of n actions played based on how many simulations are running at once.</p> Source code in <code>olfactory_navigation/agents/pbvi_ra_agent.py</code> <pre><code>class PBVI_RA_Agent(PBVI_Agent):\n    '''\n    A flavor of the PBVI Agent. The expand function consists in choosing random belief points.\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment to train the agent with.\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.\n    seed : int, default=12131415\n        For reproducible randomness.\n    model : Model, optional\n        A POMDP model to use to represent the olfactory environment.\n        If not provided, the environment_converter parameter will be used.\n    environment_converter : Callable, default=exact_converter\n        A function to convert the olfactory environment instance to a POMDP Model instance.\n        By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model.\n        This parameter will be ignored if the model parameter is provided.\n    converter_parameters : dict, optional\n        A set of additional parameters to be passed down to the environment converter.\n\n    Attributes\n    ---------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    model : pomdp.Model\n        The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.\n    saved_at : str\n        The place on disk where the agent has been saved (None if not saved yet).\n    on_gpu : bool\n        Whether the agent has been sent to the gpu or not.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    trained_at : str\n        A string timestamp of when the agent has been trained (None if not trained yet).\n    value_function : ValueFunction\n        The value function used for the agent to make decisions.\n    belief : BeliefSet\n        Used only during simulations.\n        Part of the Agent's status. Where the agent believes he is over the state space.\n        It is a list of n belief points based on how many simulations are running at once.\n    action_played : list[int]\n        Used only during simulations.\n        Part of the Agent's status. Records what action was last played by the agent.\n        A list of n actions played based on how many simulations are running at once.\n    '''\n    def expand(self,\n               belief_set: BeliefSet,\n               value_function: ValueFunction,\n               max_generation: int\n               ) -&gt; BeliefSet:\n        '''\n        This expansion technique relies only randomness and will generate at most 'max_generation' beliefs.\n\n        Parameters\n        ----------\n        belief_set : BeliefSet\n            List of beliefs to expand on.\n        value_function : ValueFunction\n            The current value function. (NOT USED)\n        max_generation : int, default=10\n            The max amount of beliefs that can be added to the belief set at once.\n\n        Returns\n        -------\n        new_belief_set : BeliefSet\n            Union of the belief_set and the expansions of the beliefs in the belief_set.\n        '''\n        # GPU support\n        xp = np if not self.on_gpu else cp\n        model = self.model\n\n        # How many new beliefs to add\n        generation_count = min(belief_set.belief_array.shape[0], max_generation)\n\n        # Generation of the new beliefs at random\n        new_beliefs = self.rnd_state.random((generation_count, model.state_count))\n        new_beliefs /= xp.sum(new_beliefs, axis=1)[:,None]\n\n        return BeliefSet(model, new_beliefs)\n\n\n    def train(self,\n              expansions: int,\n              update_passes: int = 1,\n              max_belief_growth: int = 10,\n              initial_belief: BeliefSet | Belief | None = None,\n              initial_value_function: ValueFunction | None = None,\n              prune_level: int = 1,\n              prune_interval: int = 10,\n              limit_value_function_size: int = -1,\n              gamma: float = 0.99,\n              eps: float = 1e-6,\n              use_gpu: bool = False,\n              history_tracking_level: int = 1,\n              overwrite_training: bool = False,\n              print_progress: bool = True,\n              print_stats: bool = True\n              ) -&gt; TrainingHistory:\n        '''\n        Main loop of the Point-Based Value Iteration algorithm.\n        It consists in 2 steps, Backup and Expand.\n        1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n        2. Backup: Updates the alpha vectors based on the current belief set\n\n        Random Point-Based Value Iteration:\n        - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)\n\n        Parameters\n        ----------\n        expansions : int\n            How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n        update_passes : int, default=1\n            How many times the backup function has to be run every time the belief set is expanded.\n        max_belief_growth : int, default=10\n            How many beliefs can be added at every expansion step to the belief set.\n        initial_belief : BeliefSet or Belief, optional\n            An initial list of beliefs to start with.\n        initial_value_function : ValueFunction, optional\n            An initial value function to start the solving process with.\n        prune_level : int, default=1\n            Parameter to prune the value function further before the expand function.\n        prune_interval : int, default=10\n            How often to prune the value function. It is counted in number of backup iterations.\n        limit_value_function_size : int, default=-1\n            When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n            If set to -1, the value function can grow without bounds.\n        use_gpu : bool, default=False\n            Whether to use the GPU with cupy array to accelerate solving.\n        gamma : float, default=0.99\n            The discount factor to value immediate rewards more than long term rewards.\n            The learning rate is 1/gamma.\n        eps : float, default=1e-6\n            The smallest allowed changed for the value function.\n            Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n        history_tracking_level : int, default=1\n            How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n        overwrite_training : bool, default=False\n            Whether to force the overwriting of the training if a value function already exists for this agent.\n        print_progress : bool, default=True\n            Whether or not to print out the progress of the value iteration process.\n        print_stats : bool, default=True\n            Whether or not to print out statistics at the end of the training run.\n\n        Returns\n        -------\n        solver_history : SolverHistory\n            The history of the solving process with some plotting options.\n        '''\n        return super().train(expansions = expansions,\n                             full_backup = True,\n                             update_passes = update_passes,\n                             max_belief_growth = max_belief_growth,\n                             initial_belief = initial_belief,\n                             initial_value_function = initial_value_function,\n                             prune_level = prune_level,\n                             prune_interval = prune_interval,\n                             limit_value_function_size = limit_value_function_size,\n                             gamma = gamma,\n                             eps = eps,\n                             use_gpu = use_gpu,\n                             history_tracking_level = history_tracking_level,\n                             overwrite_training = overwrite_training,\n                             print_progress = print_progress,\n                             print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/pbvi_ra_agent/#olfactory_navigation.agents.pbvi_ra_agent.PBVI_RA_Agent.expand","title":"<code>expand(belief_set, value_function, max_generation)</code>","text":"<p>This expansion technique relies only randomness and will generate at most 'max_generation' beliefs.</p> <p>Parameters:</p> Name Type Description Default <code>belief_set</code> <code>BeliefSet</code> <p>List of beliefs to expand on.</p> required <code>value_function</code> <code>ValueFunction</code> <p>The current value function. (NOT USED)</p> required <code>max_generation</code> <code>int</code> <p>The max amount of beliefs that can be added to the belief set at once.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>new_belief_set</code> <code>BeliefSet</code> <p>Union of the belief_set and the expansions of the beliefs in the belief_set.</p> Source code in <code>olfactory_navigation/agents/pbvi_ra_agent.py</code> <pre><code>def expand(self,\n           belief_set: BeliefSet,\n           value_function: ValueFunction,\n           max_generation: int\n           ) -&gt; BeliefSet:\n    '''\n    This expansion technique relies only randomness and will generate at most 'max_generation' beliefs.\n\n    Parameters\n    ----------\n    belief_set : BeliefSet\n        List of beliefs to expand on.\n    value_function : ValueFunction\n        The current value function. (NOT USED)\n    max_generation : int, default=10\n        The max amount of beliefs that can be added to the belief set at once.\n\n    Returns\n    -------\n    new_belief_set : BeliefSet\n        Union of the belief_set and the expansions of the beliefs in the belief_set.\n    '''\n    # GPU support\n    xp = np if not self.on_gpu else cp\n    model = self.model\n\n    # How many new beliefs to add\n    generation_count = min(belief_set.belief_array.shape[0], max_generation)\n\n    # Generation of the new beliefs at random\n    new_beliefs = self.rnd_state.random((generation_count, model.state_count))\n    new_beliefs /= xp.sum(new_beliefs, axis=1)[:,None]\n\n    return BeliefSet(model, new_beliefs)\n</code></pre>"},{"location":"reference/agents/pbvi_ra_agent/#olfactory_navigation.agents.pbvi_ra_agent.PBVI_RA_Agent.train","title":"<code>train(expansions, update_passes=1, max_belief_growth=10, initial_belief=None, initial_value_function=None, prune_level=1, prune_interval=10, limit_value_function_size=-1, gamma=0.99, eps=1e-06, use_gpu=False, history_tracking_level=1, overwrite_training=False, print_progress=True, print_stats=True)</code>","text":"<p>Main loop of the Point-Based Value Iteration algorithm. It consists in 2 steps, Backup and Expand. 1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function 2. Backup: Updates the alpha vectors based on the current belief set</p> <p>Random Point-Based Value Iteration: - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)</p> <p>Parameters:</p> Name Type Description Default <code>expansions</code> <code>int</code> <p>How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)</p> required <code>update_passes</code> <code>int</code> <p>How many times the backup function has to be run every time the belief set is expanded.</p> <code>1</code> <code>max_belief_growth</code> <code>int</code> <p>How many beliefs can be added at every expansion step to the belief set.</p> <code>10</code> <code>initial_belief</code> <code>BeliefSet or Belief</code> <p>An initial list of beliefs to start with.</p> <code>None</code> <code>initial_value_function</code> <code>ValueFunction</code> <p>An initial value function to start the solving process with.</p> <code>None</code> <code>prune_level</code> <code>int</code> <p>Parameter to prune the value function further before the expand function.</p> <code>1</code> <code>prune_interval</code> <code>int</code> <p>How often to prune the value function. It is counted in number of backup iterations.</p> <code>10</code> <code>limit_value_function_size</code> <code>int</code> <p>When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function If set to -1, the value function can grow without bounds.</p> <code>-1</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU with cupy array to accelerate solving.</p> <code>False</code> <code>gamma</code> <code>float</code> <p>The discount factor to value immediate rewards more than long term rewards. The learning rate is 1/gamma.</p> <code>0.99</code> <code>eps</code> <code>float</code> <p>The smallest allowed changed for the value function. Bellow the amound of change, the value function is considered converged and the value iteration process will end early.</p> <code>1e-6</code> <code>history_tracking_level</code> <code>int</code> <p>How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)</p> <code>1</code> <code>overwrite_training</code> <code>bool</code> <p>Whether to force the overwriting of the training if a value function already exists for this agent.</p> <code>False</code> <code>print_progress</code> <code>bool</code> <p>Whether or not to print out the progress of the value iteration process.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether or not to print out statistics at the end of the training run.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>solver_history</code> <code>SolverHistory</code> <p>The history of the solving process with some plotting options.</p> Source code in <code>olfactory_navigation/agents/pbvi_ra_agent.py</code> <pre><code>def train(self,\n          expansions: int,\n          update_passes: int = 1,\n          max_belief_growth: int = 10,\n          initial_belief: BeliefSet | Belief | None = None,\n          initial_value_function: ValueFunction | None = None,\n          prune_level: int = 1,\n          prune_interval: int = 10,\n          limit_value_function_size: int = -1,\n          gamma: float = 0.99,\n          eps: float = 1e-6,\n          use_gpu: bool = False,\n          history_tracking_level: int = 1,\n          overwrite_training: bool = False,\n          print_progress: bool = True,\n          print_stats: bool = True\n          ) -&gt; TrainingHistory:\n    '''\n    Main loop of the Point-Based Value Iteration algorithm.\n    It consists in 2 steps, Backup and Expand.\n    1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n    2. Backup: Updates the alpha vectors based on the current belief set\n\n    Random Point-Based Value Iteration:\n    - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)\n\n    Parameters\n    ----------\n    expansions : int\n        How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n    update_passes : int, default=1\n        How many times the backup function has to be run every time the belief set is expanded.\n    max_belief_growth : int, default=10\n        How many beliefs can be added at every expansion step to the belief set.\n    initial_belief : BeliefSet or Belief, optional\n        An initial list of beliefs to start with.\n    initial_value_function : ValueFunction, optional\n        An initial value function to start the solving process with.\n    prune_level : int, default=1\n        Parameter to prune the value function further before the expand function.\n    prune_interval : int, default=10\n        How often to prune the value function. It is counted in number of backup iterations.\n    limit_value_function_size : int, default=-1\n        When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n        If set to -1, the value function can grow without bounds.\n    use_gpu : bool, default=False\n        Whether to use the GPU with cupy array to accelerate solving.\n    gamma : float, default=0.99\n        The discount factor to value immediate rewards more than long term rewards.\n        The learning rate is 1/gamma.\n    eps : float, default=1e-6\n        The smallest allowed changed for the value function.\n        Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n    history_tracking_level : int, default=1\n        How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n    overwrite_training : bool, default=False\n        Whether to force the overwriting of the training if a value function already exists for this agent.\n    print_progress : bool, default=True\n        Whether or not to print out the progress of the value iteration process.\n    print_stats : bool, default=True\n        Whether or not to print out statistics at the end of the training run.\n\n    Returns\n    -------\n    solver_history : SolverHistory\n        The history of the solving process with some plotting options.\n    '''\n    return super().train(expansions = expansions,\n                         full_backup = True,\n                         update_passes = update_passes,\n                         max_belief_growth = max_belief_growth,\n                         initial_belief = initial_belief,\n                         initial_value_function = initial_value_function,\n                         prune_level = prune_level,\n                         prune_interval = prune_interval,\n                         limit_value_function_size = limit_value_function_size,\n                         gamma = gamma,\n                         eps = eps,\n                         use_gpu = use_gpu,\n                         history_tracking_level = history_tracking_level,\n                         overwrite_training = overwrite_training,\n                         print_progress = print_progress,\n                         print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/pbvi_ssea_agent/","title":"pbvi_ssea_agent","text":""},{"location":"reference/agents/pbvi_ssea_agent/#olfactory_navigation.agents.pbvi_ssea_agent.PBVI_SSEA_Agent","title":"<code>PBVI_SSEA_Agent</code>","text":"<p>               Bases: <code>PBVI_Agent</code></p> <p>A flavor of the PBVI Agent. The expand function consists in choosing belief points furtest away (L2 distance) from any other belief point already in the belief set based on that.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment to train the agent with.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.</p> <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <code>model</code> <code>Model</code> <p>A POMDP model to use to represent the olfactory environment. If not provided, the environment_converter parameter will be used.</p> <code>None</code> <code>environment_converter</code> <code>Callable</code> <p>A function to convert the olfactory environment instance to a POMDP Model instance. By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model. This parameter will be ignored if the model parameter is provided.</p> <code>exact_converter</code> <code>converter_parameters</code> <code>dict</code> <p>A set of additional parameters to be passed down to the environment converter.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>model</code> <code>Model</code> <p>The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.</p> <code>saved_at</code> <code>str</code> <p>The place on disk where the agent has been saved (None if not saved yet).</p> <code>on_gpu</code> <code>bool</code> <p>Whether the agent has been sent to the gpu or not.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>trained_at</code> <code>str</code> <p>A string timestamp of when the agent has been trained (None if not trained yet).</p> <code>value_function</code> <code>ValueFunction</code> <p>The value function used for the agent to make decisions.</p> <code>belief</code> <code>BeliefSet</code> <p>Used only during simulations. Part of the Agent's status. Where the agent believes he is over the state space. It is a list of n belief points based on how many simulations are running at once.</p> <code>action_played</code> <code>list[int]</code> <p>Used only during simulations. Part of the Agent's status. Records what action was last played by the agent. A list of n actions played based on how many simulations are running at once.</p> Source code in <code>olfactory_navigation/agents/pbvi_ssea_agent.py</code> <pre><code>class PBVI_SSEA_Agent(PBVI_Agent):\n    '''\n    A flavor of the PBVI Agent. The expand function consists in choosing belief points furtest away (L2 distance) from any other belief point already in the belief set based on that.\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment to train the agent with.\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.\n    seed : int, default=12131415\n        For reproducible randomness.\n    model : Model, optional\n        A POMDP model to use to represent the olfactory environment.\n        If not provided, the environment_converter parameter will be used.\n    environment_converter : Callable, default=exact_converter\n        A function to convert the olfactory environment instance to a POMDP Model instance.\n        By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model.\n        This parameter will be ignored if the model parameter is provided.\n    converter_parameters : dict, optional\n        A set of additional parameters to be passed down to the environment converter.\n\n    Attributes\n    ---------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    model : pomdp.Model\n        The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.\n    saved_at : str\n        The place on disk where the agent has been saved (None if not saved yet).\n    on_gpu : bool\n        Whether the agent has been sent to the gpu or not.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    trained_at : str\n        A string timestamp of when the agent has been trained (None if not trained yet).\n    value_function : ValueFunction\n        The value function used for the agent to make decisions.\n    belief : BeliefSet\n        Used only during simulations.\n        Part of the Agent's status. Where the agent believes he is over the state space.\n        It is a list of n belief points based on how many simulations are running at once.\n    action_played : list[int]\n        Used only during simulations.\n        Part of the Agent's status. Records what action was last played by the agent.\n        A list of n actions played based on how many simulations are running at once.\n    '''\n    def expand(self,\n               belief_set: BeliefSet,\n               value_function: ValueFunction,\n               max_generation: int\n               ) -&gt; BeliefSet:\n        '''\n        Stochastic Simulation with Exploratory Action.\n        Simulates running steps forward for each possible action knowing we are a state s, chosen randomly with according to the belief probability.\n        These lead to a new state s_p and a observation o for each action.\n        From all these and observation o we can generate updated beliefs.\n        Then it takes the belief that is furthest away from other beliefs, meaning it explores the most the belief space.\n\n        Parameters\n        ----------\n        belief_set : BeliefSet\n            List of beliefs to expand on.\n        value_function : ValueFunction\n            The current value function. (NOT USED)\n        max_generation : int, default=10\n            The max amount of beliefs that can be added to the belief set at once.\n\n        Returns\n        -------\n        belief_set_new : BeliefSet\n            Union of the belief_set and the expansions of the beliefs in the belief_set.\n        '''\n        # GPU support\n        xp = np if not self.on_gpu else cp\n        model = self.model\n\n        old_shape = belief_set.belief_array.shape\n        to_generate = min(max_generation, old_shape[0])\n\n        # Generation of successors\n        successor_beliefs = xp.array([[[b.update(a,o).values for o in model.observations] for a in model.actions] for b in belief_set.belief_list])\n\n        # Compute the distances between each pair and of successor are source beliefs\n        diff = (belief_set.belief_array[:, None,None,None, :] - successor_beliefs)\n        dist = xp.sqrt(xp.einsum('bnaos,bnaos-&gt;bnao', diff, diff))\n\n        # Taking the min distance for each belief\n        belief_min_dists = xp.min(dist,axis=0)\n\n        # Taking the max distanced successors\n        b_star, a_star, o_star = xp.unravel_index(xp.argsort(belief_min_dists, axis=None)[::-1][:to_generate], successor_beliefs.shape[:-1])\n\n        # Selecting successor beliefs\n        new_belief_array = successor_beliefs[b_star[:,None], a_star[:,None], o_star[:,None], model.states[None,:]]\n\n        return BeliefSet(model, new_belief_array)\n\n\n    def train(self,\n              expansions: int,\n              update_passes: int = 1,\n              max_belief_growth: int = 10,\n              initial_belief: BeliefSet | Belief | None = None,\n              initial_value_function: ValueFunction | None = None,\n              prune_level: int = 1,\n              prune_interval: int = 10,\n              limit_value_function_size: int = -1,\n              gamma: float = 0.99,\n              eps: float = 1e-6,\n              use_gpu: bool = False,\n              history_tracking_level: int = 1,\n              overwrite_training: bool = False,\n              print_progress: bool = True,\n              print_stats: bool = True\n              ) -&gt; TrainingHistory:\n        '''\n        Main loop of the Point-Based Value Iteration algorithm.\n        It consists in 2 steps, Backup and Expand.\n        1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n        2. Backup: Updates the alpha vectors based on the current belief set\n\n        Stochastic Search with Exploratory Action Point-Based Value Iteration:\n        - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)\n\n        Parameters\n        ----------\n        expansions : int\n            How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n        update_passes : int, default=1\n            How many times the backup function has to be run every time the belief set is expanded.\n        max_belief_growth : int, default=10\n            How many beliefs can be added at every expansion step to the belief set.\n        initial_belief : BeliefSet or Belief, optional\n            An initial list of beliefs to start with.\n        initial_value_function : ValueFunction, optional\n            An initial value function to start the solving process with.\n        prune_level : int, default=1\n            Parameter to prune the value function further before the expand function.\n        prune_interval : int, default=10\n            How often to prune the value function. It is counted in number of backup iterations.\n        limit_value_function_size : int, default=-1\n            When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n            If set to -1, the value function can grow without bounds.\n        use_gpu : bool, default=False\n            Whether to use the GPU with cupy array to accelerate solving.\n        gamma : float, default=0.99\n            The discount factor to value immediate rewards more than long term rewards.\n            The learning rate is 1/gamma.\n        eps : float, default=1e-6\n            The smallest allowed changed for the value function.\n            Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n        history_tracking_level : int, default=1\n            How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n        overwrite_training : bool, default=False\n            Whether to force the overwriting of the training if a value function already exists for this agent.\n        print_progress : bool, default=True\n            Whether or not to print out the progress of the value iteration process.\n        print_stats : bool, default=True\n            Whether or not to print out statistics at the end of the training run.\n\n        Returns\n        -------\n        solver_history : SolverHistory\n            The history of the solving process with some plotting options.\n        '''\n        return super().train(expansions = expansions,\n                             full_backup = True,\n                             update_passes = update_passes,\n                             max_belief_growth = max_belief_growth,\n                             initial_belief = initial_belief,\n                             initial_value_function = initial_value_function,\n                             prune_level = prune_level,\n                             prune_interval = prune_interval,\n                             limit_value_function_size = limit_value_function_size,\n                             gamma = gamma,\n                             eps = eps,\n                             use_gpu = use_gpu,\n                             history_tracking_level = history_tracking_level,\n                             overwrite_training = overwrite_training,\n                             print_progress = print_progress,\n                             print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/pbvi_ssea_agent/#olfactory_navigation.agents.pbvi_ssea_agent.PBVI_SSEA_Agent.expand","title":"<code>expand(belief_set, value_function, max_generation)</code>","text":"<p>Stochastic Simulation with Exploratory Action. Simulates running steps forward for each possible action knowing we are a state s, chosen randomly with according to the belief probability. These lead to a new state s_p and a observation o for each action. From all these and observation o we can generate updated beliefs. Then it takes the belief that is furthest away from other beliefs, meaning it explores the most the belief space.</p> <p>Parameters:</p> Name Type Description Default <code>belief_set</code> <code>BeliefSet</code> <p>List of beliefs to expand on.</p> required <code>value_function</code> <code>ValueFunction</code> <p>The current value function. (NOT USED)</p> required <code>max_generation</code> <code>int</code> <p>The max amount of beliefs that can be added to the belief set at once.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>belief_set_new</code> <code>BeliefSet</code> <p>Union of the belief_set and the expansions of the beliefs in the belief_set.</p> Source code in <code>olfactory_navigation/agents/pbvi_ssea_agent.py</code> <pre><code>def expand(self,\n           belief_set: BeliefSet,\n           value_function: ValueFunction,\n           max_generation: int\n           ) -&gt; BeliefSet:\n    '''\n    Stochastic Simulation with Exploratory Action.\n    Simulates running steps forward for each possible action knowing we are a state s, chosen randomly with according to the belief probability.\n    These lead to a new state s_p and a observation o for each action.\n    From all these and observation o we can generate updated beliefs.\n    Then it takes the belief that is furthest away from other beliefs, meaning it explores the most the belief space.\n\n    Parameters\n    ----------\n    belief_set : BeliefSet\n        List of beliefs to expand on.\n    value_function : ValueFunction\n        The current value function. (NOT USED)\n    max_generation : int, default=10\n        The max amount of beliefs that can be added to the belief set at once.\n\n    Returns\n    -------\n    belief_set_new : BeliefSet\n        Union of the belief_set and the expansions of the beliefs in the belief_set.\n    '''\n    # GPU support\n    xp = np if not self.on_gpu else cp\n    model = self.model\n\n    old_shape = belief_set.belief_array.shape\n    to_generate = min(max_generation, old_shape[0])\n\n    # Generation of successors\n    successor_beliefs = xp.array([[[b.update(a,o).values for o in model.observations] for a in model.actions] for b in belief_set.belief_list])\n\n    # Compute the distances between each pair and of successor are source beliefs\n    diff = (belief_set.belief_array[:, None,None,None, :] - successor_beliefs)\n    dist = xp.sqrt(xp.einsum('bnaos,bnaos-&gt;bnao', diff, diff))\n\n    # Taking the min distance for each belief\n    belief_min_dists = xp.min(dist,axis=0)\n\n    # Taking the max distanced successors\n    b_star, a_star, o_star = xp.unravel_index(xp.argsort(belief_min_dists, axis=None)[::-1][:to_generate], successor_beliefs.shape[:-1])\n\n    # Selecting successor beliefs\n    new_belief_array = successor_beliefs[b_star[:,None], a_star[:,None], o_star[:,None], model.states[None,:]]\n\n    return BeliefSet(model, new_belief_array)\n</code></pre>"},{"location":"reference/agents/pbvi_ssea_agent/#olfactory_navigation.agents.pbvi_ssea_agent.PBVI_SSEA_Agent.train","title":"<code>train(expansions, update_passes=1, max_belief_growth=10, initial_belief=None, initial_value_function=None, prune_level=1, prune_interval=10, limit_value_function_size=-1, gamma=0.99, eps=1e-06, use_gpu=False, history_tracking_level=1, overwrite_training=False, print_progress=True, print_stats=True)</code>","text":"<p>Main loop of the Point-Based Value Iteration algorithm. It consists in 2 steps, Backup and Expand. 1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function 2. Backup: Updates the alpha vectors based on the current belief set</p> <p>Stochastic Search with Exploratory Action Point-Based Value Iteration: - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)</p> <p>Parameters:</p> Name Type Description Default <code>expansions</code> <code>int</code> <p>How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)</p> required <code>update_passes</code> <code>int</code> <p>How many times the backup function has to be run every time the belief set is expanded.</p> <code>1</code> <code>max_belief_growth</code> <code>int</code> <p>How many beliefs can be added at every expansion step to the belief set.</p> <code>10</code> <code>initial_belief</code> <code>BeliefSet or Belief</code> <p>An initial list of beliefs to start with.</p> <code>None</code> <code>initial_value_function</code> <code>ValueFunction</code> <p>An initial value function to start the solving process with.</p> <code>None</code> <code>prune_level</code> <code>int</code> <p>Parameter to prune the value function further before the expand function.</p> <code>1</code> <code>prune_interval</code> <code>int</code> <p>How often to prune the value function. It is counted in number of backup iterations.</p> <code>10</code> <code>limit_value_function_size</code> <code>int</code> <p>When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function If set to -1, the value function can grow without bounds.</p> <code>-1</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU with cupy array to accelerate solving.</p> <code>False</code> <code>gamma</code> <code>float</code> <p>The discount factor to value immediate rewards more than long term rewards. The learning rate is 1/gamma.</p> <code>0.99</code> <code>eps</code> <code>float</code> <p>The smallest allowed changed for the value function. Bellow the amound of change, the value function is considered converged and the value iteration process will end early.</p> <code>1e-6</code> <code>history_tracking_level</code> <code>int</code> <p>How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)</p> <code>1</code> <code>overwrite_training</code> <code>bool</code> <p>Whether to force the overwriting of the training if a value function already exists for this agent.</p> <code>False</code> <code>print_progress</code> <code>bool</code> <p>Whether or not to print out the progress of the value iteration process.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether or not to print out statistics at the end of the training run.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>solver_history</code> <code>SolverHistory</code> <p>The history of the solving process with some plotting options.</p> Source code in <code>olfactory_navigation/agents/pbvi_ssea_agent.py</code> <pre><code>def train(self,\n          expansions: int,\n          update_passes: int = 1,\n          max_belief_growth: int = 10,\n          initial_belief: BeliefSet | Belief | None = None,\n          initial_value_function: ValueFunction | None = None,\n          prune_level: int = 1,\n          prune_interval: int = 10,\n          limit_value_function_size: int = -1,\n          gamma: float = 0.99,\n          eps: float = 1e-6,\n          use_gpu: bool = False,\n          history_tracking_level: int = 1,\n          overwrite_training: bool = False,\n          print_progress: bool = True,\n          print_stats: bool = True\n          ) -&gt; TrainingHistory:\n    '''\n    Main loop of the Point-Based Value Iteration algorithm.\n    It consists in 2 steps, Backup and Expand.\n    1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n    2. Backup: Updates the alpha vectors based on the current belief set\n\n    Stochastic Search with Exploratory Action Point-Based Value Iteration:\n    - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)\n\n    Parameters\n    ----------\n    expansions : int\n        How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n    update_passes : int, default=1\n        How many times the backup function has to be run every time the belief set is expanded.\n    max_belief_growth : int, default=10\n        How many beliefs can be added at every expansion step to the belief set.\n    initial_belief : BeliefSet or Belief, optional\n        An initial list of beliefs to start with.\n    initial_value_function : ValueFunction, optional\n        An initial value function to start the solving process with.\n    prune_level : int, default=1\n        Parameter to prune the value function further before the expand function.\n    prune_interval : int, default=10\n        How often to prune the value function. It is counted in number of backup iterations.\n    limit_value_function_size : int, default=-1\n        When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n        If set to -1, the value function can grow without bounds.\n    use_gpu : bool, default=False\n        Whether to use the GPU with cupy array to accelerate solving.\n    gamma : float, default=0.99\n        The discount factor to value immediate rewards more than long term rewards.\n        The learning rate is 1/gamma.\n    eps : float, default=1e-6\n        The smallest allowed changed for the value function.\n        Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n    history_tracking_level : int, default=1\n        How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n    overwrite_training : bool, default=False\n        Whether to force the overwriting of the training if a value function already exists for this agent.\n    print_progress : bool, default=True\n        Whether or not to print out the progress of the value iteration process.\n    print_stats : bool, default=True\n        Whether or not to print out statistics at the end of the training run.\n\n    Returns\n    -------\n    solver_history : SolverHistory\n        The history of the solving process with some plotting options.\n    '''\n    return super().train(expansions = expansions,\n                         full_backup = True,\n                         update_passes = update_passes,\n                         max_belief_growth = max_belief_growth,\n                         initial_belief = initial_belief,\n                         initial_value_function = initial_value_function,\n                         prune_level = prune_level,\n                         prune_interval = prune_interval,\n                         limit_value_function_size = limit_value_function_size,\n                         gamma = gamma,\n                         eps = eps,\n                         use_gpu = use_gpu,\n                         history_tracking_level = history_tracking_level,\n                         overwrite_training = overwrite_training,\n                         print_progress = print_progress,\n                         print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/pbvi_ssga_agent/","title":"pbvi_ssga_agent","text":""},{"location":"reference/agents/pbvi_ssga_agent/#olfactory_navigation.agents.pbvi_ssga_agent.PBVI_SSGA_Agent","title":"<code>PBVI_SSGA_Agent</code>","text":"<p>               Bases: <code>PBVI_Agent</code></p> <p>A flavor of the PBVI Agent. The expand function consists in choosing actions in an epsilon greedy fashion and generating random observations and generating belief points based on that.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment to train the agent with.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.</p> <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <code>model</code> <code>Model</code> <p>A POMDP model to use to represent the olfactory environment. If not provided, the environment_converter parameter will be used.</p> <code>None</code> <code>environment_converter</code> <code>Callable</code> <p>A function to convert the olfactory environment instance to a POMDP Model instance. By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model. This parameter will be ignored if the model parameter is provided.</p> <code>exact_converter</code> <code>converter_parameters</code> <code>dict</code> <p>A set of additional parameters to be passed down to the environment converter.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>model</code> <code>Model</code> <p>The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.</p> <code>saved_at</code> <code>str</code> <p>The place on disk where the agent has been saved (None if not saved yet).</p> <code>on_gpu</code> <code>bool</code> <p>Whether the agent has been sent to the gpu or not.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>trained_at</code> <code>str</code> <p>A string timestamp of when the agent has been trained (None if not trained yet).</p> <code>value_function</code> <code>ValueFunction</code> <p>The value function used for the agent to make decisions.</p> <code>belief</code> <code>BeliefSet</code> <p>Used only during simulations. Part of the Agent's status. Where the agent believes he is over the state space. It is a list of n belief points based on how many simulations are running at once.</p> <code>action_played</code> <code>list[int]</code> <p>Used only during simulations. Part of the Agent's status. Records what action was last played by the agent. A list of n actions played based on how many simulations are running at once.</p> Source code in <code>olfactory_navigation/agents/pbvi_ssga_agent.py</code> <pre><code>class PBVI_SSGA_Agent(PBVI_Agent):\n    '''\n    A flavor of the PBVI Agent. The expand function consists in choosing actions in an epsilon greedy fashion and generating random observations and generating belief points based on that.\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment to train the agent with.\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.\n    seed : int, default=12131415\n        For reproducible randomness.\n    model : Model, optional\n        A POMDP model to use to represent the olfactory environment.\n        If not provided, the environment_converter parameter will be used.\n    environment_converter : Callable, default=exact_converter\n        A function to convert the olfactory environment instance to a POMDP Model instance.\n        By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model.\n        This parameter will be ignored if the model parameter is provided.\n    converter_parameters : dict, optional\n        A set of additional parameters to be passed down to the environment converter.\n\n    Attributes\n    ---------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    model : pomdp.Model\n        The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.\n    saved_at : str\n        The place on disk where the agent has been saved (None if not saved yet).\n    on_gpu : bool\n        Whether the agent has been sent to the gpu or not.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    trained_at : str\n        A string timestamp of when the agent has been trained (None if not trained yet).\n    value_function : ValueFunction\n        The value function used for the agent to make decisions.\n    belief : BeliefSet\n        Used only during simulations.\n        Part of the Agent's status. Where the agent believes he is over the state space.\n        It is a list of n belief points based on how many simulations are running at once.\n    action_played : list[int]\n        Used only during simulations.\n        Part of the Agent's status. Records what action was last played by the agent.\n        A list of n actions played based on how many simulations are running at once.\n    '''\n    def expand(self,\n               belief_set: BeliefSet,\n               value_function: ValueFunction,\n               max_generation: int,\n               epsilon: float = 0.99\n               ) -&gt; BeliefSet:\n        '''\n        Stochastic Simulation with Greedy Action.\n        Simulates running a single-step forward from the beliefs in the \"belief_set\".\n        The step forward is taking assuming we are in a random state s (weighted by the belief),\n        then taking the best action a based on the belief with probability 'epsilon'.\n        These lead to a new state s_p and a observation o.\n        From this action a and observation o we can update our belief.\n\n        Parameters\n        ----------\n        belief_set : BeliefSet\n            List of beliefs to expand on.\n        value_function : ValueFunction\n            The current value function. (NOT USED)\n        max_generation : int, default=10\n            The max amount of beliefs that can be added to the belief set at once.\n        epsilon : float, default=0.99\n            The epsilon parameter that determines whether to choose an action greedily or randomly.\n\n        Returns\n        -------\n        belief_set_new : BeliefSet\n            Union of the belief_set and the expansions of the beliefs in the belief_set.\n        '''\n        # GPU support\n        xp = np if not self.on_gpu else cp\n        model = self.model\n\n        old_shape = belief_set.belief_array.shape\n        to_generate = min(max_generation, old_shape[0])\n\n        new_belief_array = xp.empty((to_generate, old_shape[1]))\n\n        # Random previous beliefs\n        rand_ind = self.rnd_state.choice(np.arange(old_shape[0]), to_generate, replace=False)\n\n        for i, belief_vector in enumerate(belief_set.belief_array[rand_ind]):\n            b = Belief(model, belief_vector)\n            s = b.random_state()\n\n            if self.rnd_state.random() &lt; epsilon:\n                a = self.rnd_state.choice(model.actions)\n            else:\n                best_alpha_index = xp.argmax(xp.dot(value_function.alpha_vector_array, b.values))\n                a = value_function.actions[best_alpha_index]\n\n            s_p = model.transition(s, a)\n            o = model.observe(s_p, a)\n            b_new = b.update(a, o)\n\n            new_belief_array[i] = b_new.values\n\n        return BeliefSet(model, new_belief_array)\n\n\n    def train(self,\n              expansions: int,\n              update_passes: int = 1,\n              max_belief_growth: int = 10,\n              initial_belief: BeliefSet | Belief | None = None,\n              initial_value_function: ValueFunction | None = None,\n              prune_level: int = 1,\n              prune_interval: int = 10,\n              limit_value_function_size: int = -1,\n              gamma: float = 0.99,\n              eps: float = 1e-6,\n              use_gpu: bool = False,\n              history_tracking_level: int = 1,\n              overwrite_training: bool = False,\n              print_progress: bool = True,\n              print_stats: bool = True,\n              epsilon: float = 0.99\n              ) -&gt; TrainingHistory:\n        '''\n        Main loop of the Point-Based Value Iteration algorithm.\n        It consists in 2 steps, Backup and Expand.\n        1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n        2. Backup: Updates the alpha vectors based on the current belief set\n\n        Stochastic Search with Greedy Action Point-Based Value Iteration:\n        - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)\n\n        Parameters\n        ----------\n        expansions : int\n            How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n        update_passes : int, default=1\n            How many times the backup function has to be run every time the belief set is expanded.\n        max_belief_growth : int, default=10\n            How many beliefs can be added at every expansion step to the belief set.\n        initial_belief : BeliefSet or Belief, optional\n            An initial list of beliefs to start with.\n        initial_value_function : ValueFunction, optional\n            An initial value function to start the solving process with.\n        prune_level : int, default=1\n            Parameter to prune the value function further before the expand function.\n        prune_interval : int, default=10\n            How often to prune the value function. It is counted in number of backup iterations.\n        limit_value_function_size : int, default=-1\n            When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n            If set to -1, the value function can grow without bounds.\n        use_gpu : bool, default=False\n            Whether to use the GPU with cupy array to accelerate solving.\n        gamma : float, default=0.99\n            The discount factor to value immediate rewards more than long term rewards.\n            The learning rate is 1/gamma.\n        eps : float, default=1e-6\n            The smallest allowed changed for the value function.\n            Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n        history_tracking_level : int, default=1\n            How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n        overwrite_training : bool, default=False\n            Whether to force the overwriting of the training if a value function already exists for this agent.\n        print_progress : bool, default=True\n            Whether or not to print out the progress of the value iteration process.\n        print_stats : bool, default=True\n            Whether or not to print out statistics at the end of the training run.\n        epsilon : float, default=0.99\n            Expand function parameter. threshold to how often to choose the action greedily to how often randomly.\n\n        Returns\n        -------\n        solver_history : SolverHistory\n            The history of the solving process with some plotting options.\n        '''\n        return super().train(expansions = expansions,\n                             full_backup = True,\n                             update_passes = update_passes,\n                             max_belief_growth = max_belief_growth,\n                             initial_belief = initial_belief,\n                             initial_value_function = initial_value_function,\n                             prune_level = prune_level,\n                             prune_interval = prune_interval,\n                             limit_value_function_size = limit_value_function_size,\n                             gamma = gamma,\n                             eps = eps,\n                             use_gpu = use_gpu,\n                             history_tracking_level = history_tracking_level,\n                             overwrite_training = overwrite_training,\n                             print_progress = print_progress,\n                             print_stats = print_stats,\n                             epsilon = epsilon)\n</code></pre>"},{"location":"reference/agents/pbvi_ssga_agent/#olfactory_navigation.agents.pbvi_ssga_agent.PBVI_SSGA_Agent.expand","title":"<code>expand(belief_set, value_function, max_generation, epsilon=0.99)</code>","text":"<p>Stochastic Simulation with Greedy Action. Simulates running a single-step forward from the beliefs in the \"belief_set\". The step forward is taking assuming we are in a random state s (weighted by the belief), then taking the best action a based on the belief with probability 'epsilon'. These lead to a new state s_p and a observation o. From this action a and observation o we can update our belief.</p> <p>Parameters:</p> Name Type Description Default <code>belief_set</code> <code>BeliefSet</code> <p>List of beliefs to expand on.</p> required <code>value_function</code> <code>ValueFunction</code> <p>The current value function. (NOT USED)</p> required <code>max_generation</code> <code>int</code> <p>The max amount of beliefs that can be added to the belief set at once.</p> <code>10</code> <code>epsilon</code> <code>float</code> <p>The epsilon parameter that determines whether to choose an action greedily or randomly.</p> <code>0.99</code> <p>Returns:</p> Name Type Description <code>belief_set_new</code> <code>BeliefSet</code> <p>Union of the belief_set and the expansions of the beliefs in the belief_set.</p> Source code in <code>olfactory_navigation/agents/pbvi_ssga_agent.py</code> <pre><code>def expand(self,\n           belief_set: BeliefSet,\n           value_function: ValueFunction,\n           max_generation: int,\n           epsilon: float = 0.99\n           ) -&gt; BeliefSet:\n    '''\n    Stochastic Simulation with Greedy Action.\n    Simulates running a single-step forward from the beliefs in the \"belief_set\".\n    The step forward is taking assuming we are in a random state s (weighted by the belief),\n    then taking the best action a based on the belief with probability 'epsilon'.\n    These lead to a new state s_p and a observation o.\n    From this action a and observation o we can update our belief.\n\n    Parameters\n    ----------\n    belief_set : BeliefSet\n        List of beliefs to expand on.\n    value_function : ValueFunction\n        The current value function. (NOT USED)\n    max_generation : int, default=10\n        The max amount of beliefs that can be added to the belief set at once.\n    epsilon : float, default=0.99\n        The epsilon parameter that determines whether to choose an action greedily or randomly.\n\n    Returns\n    -------\n    belief_set_new : BeliefSet\n        Union of the belief_set and the expansions of the beliefs in the belief_set.\n    '''\n    # GPU support\n    xp = np if not self.on_gpu else cp\n    model = self.model\n\n    old_shape = belief_set.belief_array.shape\n    to_generate = min(max_generation, old_shape[0])\n\n    new_belief_array = xp.empty((to_generate, old_shape[1]))\n\n    # Random previous beliefs\n    rand_ind = self.rnd_state.choice(np.arange(old_shape[0]), to_generate, replace=False)\n\n    for i, belief_vector in enumerate(belief_set.belief_array[rand_ind]):\n        b = Belief(model, belief_vector)\n        s = b.random_state()\n\n        if self.rnd_state.random() &lt; epsilon:\n            a = self.rnd_state.choice(model.actions)\n        else:\n            best_alpha_index = xp.argmax(xp.dot(value_function.alpha_vector_array, b.values))\n            a = value_function.actions[best_alpha_index]\n\n        s_p = model.transition(s, a)\n        o = model.observe(s_p, a)\n        b_new = b.update(a, o)\n\n        new_belief_array[i] = b_new.values\n\n    return BeliefSet(model, new_belief_array)\n</code></pre>"},{"location":"reference/agents/pbvi_ssga_agent/#olfactory_navigation.agents.pbvi_ssga_agent.PBVI_SSGA_Agent.train","title":"<code>train(expansions, update_passes=1, max_belief_growth=10, initial_belief=None, initial_value_function=None, prune_level=1, prune_interval=10, limit_value_function_size=-1, gamma=0.99, eps=1e-06, use_gpu=False, history_tracking_level=1, overwrite_training=False, print_progress=True, print_stats=True, epsilon=0.99)</code>","text":"<p>Main loop of the Point-Based Value Iteration algorithm. It consists in 2 steps, Backup and Expand. 1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function 2. Backup: Updates the alpha vectors based on the current belief set</p> <p>Stochastic Search with Greedy Action Point-Based Value Iteration: - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)</p> <p>Parameters:</p> Name Type Description Default <code>expansions</code> <code>int</code> <p>How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)</p> required <code>update_passes</code> <code>int</code> <p>How many times the backup function has to be run every time the belief set is expanded.</p> <code>1</code> <code>max_belief_growth</code> <code>int</code> <p>How many beliefs can be added at every expansion step to the belief set.</p> <code>10</code> <code>initial_belief</code> <code>BeliefSet or Belief</code> <p>An initial list of beliefs to start with.</p> <code>None</code> <code>initial_value_function</code> <code>ValueFunction</code> <p>An initial value function to start the solving process with.</p> <code>None</code> <code>prune_level</code> <code>int</code> <p>Parameter to prune the value function further before the expand function.</p> <code>1</code> <code>prune_interval</code> <code>int</code> <p>How often to prune the value function. It is counted in number of backup iterations.</p> <code>10</code> <code>limit_value_function_size</code> <code>int</code> <p>When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function If set to -1, the value function can grow without bounds.</p> <code>-1</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU with cupy array to accelerate solving.</p> <code>False</code> <code>gamma</code> <code>float</code> <p>The discount factor to value immediate rewards more than long term rewards. The learning rate is 1/gamma.</p> <code>0.99</code> <code>eps</code> <code>float</code> <p>The smallest allowed changed for the value function. Bellow the amound of change, the value function is considered converged and the value iteration process will end early.</p> <code>1e-6</code> <code>history_tracking_level</code> <code>int</code> <p>How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)</p> <code>1</code> <code>overwrite_training</code> <code>bool</code> <p>Whether to force the overwriting of the training if a value function already exists for this agent.</p> <code>False</code> <code>print_progress</code> <code>bool</code> <p>Whether or not to print out the progress of the value iteration process.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether or not to print out statistics at the end of the training run.</p> <code>True</code> <code>epsilon</code> <code>float</code> <p>Expand function parameter. threshold to how often to choose the action greedily to how often randomly.</p> <code>0.99</code> <p>Returns:</p> Name Type Description <code>solver_history</code> <code>SolverHistory</code> <p>The history of the solving process with some plotting options.</p> Source code in <code>olfactory_navigation/agents/pbvi_ssga_agent.py</code> <pre><code>def train(self,\n          expansions: int,\n          update_passes: int = 1,\n          max_belief_growth: int = 10,\n          initial_belief: BeliefSet | Belief | None = None,\n          initial_value_function: ValueFunction | None = None,\n          prune_level: int = 1,\n          prune_interval: int = 10,\n          limit_value_function_size: int = -1,\n          gamma: float = 0.99,\n          eps: float = 1e-6,\n          use_gpu: bool = False,\n          history_tracking_level: int = 1,\n          overwrite_training: bool = False,\n          print_progress: bool = True,\n          print_stats: bool = True,\n          epsilon: float = 0.99\n          ) -&gt; TrainingHistory:\n    '''\n    Main loop of the Point-Based Value Iteration algorithm.\n    It consists in 2 steps, Backup and Expand.\n    1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n    2. Backup: Updates the alpha vectors based on the current belief set\n\n    Stochastic Search with Greedy Action Point-Based Value Iteration:\n    - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)\n\n    Parameters\n    ----------\n    expansions : int\n        How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n    update_passes : int, default=1\n        How many times the backup function has to be run every time the belief set is expanded.\n    max_belief_growth : int, default=10\n        How many beliefs can be added at every expansion step to the belief set.\n    initial_belief : BeliefSet or Belief, optional\n        An initial list of beliefs to start with.\n    initial_value_function : ValueFunction, optional\n        An initial value function to start the solving process with.\n    prune_level : int, default=1\n        Parameter to prune the value function further before the expand function.\n    prune_interval : int, default=10\n        How often to prune the value function. It is counted in number of backup iterations.\n    limit_value_function_size : int, default=-1\n        When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n        If set to -1, the value function can grow without bounds.\n    use_gpu : bool, default=False\n        Whether to use the GPU with cupy array to accelerate solving.\n    gamma : float, default=0.99\n        The discount factor to value immediate rewards more than long term rewards.\n        The learning rate is 1/gamma.\n    eps : float, default=1e-6\n        The smallest allowed changed for the value function.\n        Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n    history_tracking_level : int, default=1\n        How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n    overwrite_training : bool, default=False\n        Whether to force the overwriting of the training if a value function already exists for this agent.\n    print_progress : bool, default=True\n        Whether or not to print out the progress of the value iteration process.\n    print_stats : bool, default=True\n        Whether or not to print out statistics at the end of the training run.\n    epsilon : float, default=0.99\n        Expand function parameter. threshold to how often to choose the action greedily to how often randomly.\n\n    Returns\n    -------\n    solver_history : SolverHistory\n        The history of the solving process with some plotting options.\n    '''\n    return super().train(expansions = expansions,\n                         full_backup = True,\n                         update_passes = update_passes,\n                         max_belief_growth = max_belief_growth,\n                         initial_belief = initial_belief,\n                         initial_value_function = initial_value_function,\n                         prune_level = prune_level,\n                         prune_interval = prune_interval,\n                         limit_value_function_size = limit_value_function_size,\n                         gamma = gamma,\n                         eps = eps,\n                         use_gpu = use_gpu,\n                         history_tracking_level = history_tracking_level,\n                         overwrite_training = overwrite_training,\n                         print_progress = print_progress,\n                         print_stats = print_stats,\n                         epsilon = epsilon)\n</code></pre>"},{"location":"reference/agents/pbvi_ssra_agent/","title":"pbvi_ssra_agent","text":""},{"location":"reference/agents/pbvi_ssra_agent/#olfactory_navigation.agents.pbvi_ssra_agent.PBVI_SSRA_Agent","title":"<code>PBVI_SSRA_Agent</code>","text":"<p>               Bases: <code>PBVI_Agent</code></p> <p>A flavor of the PBVI Agent. The expand function consists in choosing random actions and observations and generating belief points based on that.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment to train the agent with.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.</p> <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <code>model</code> <code>Model</code> <p>A POMDP model to use to represent the olfactory environment. If not provided, the environment_converter parameter will be used.</p> <code>None</code> <code>environment_converter</code> <code>Callable</code> <p>A function to convert the olfactory environment instance to a POMDP Model instance. By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model. This parameter will be ignored if the model parameter is provided.</p> <code>exact_converter</code> <code>converter_parameters</code> <code>dict</code> <p>A set of additional parameters to be passed down to the environment converter.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>model</code> <code>Model</code> <p>The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.</p> <code>saved_at</code> <code>str</code> <p>The place on disk where the agent has been saved (None if not saved yet).</p> <code>on_gpu</code> <code>bool</code> <p>Whether the agent has been sent to the gpu or not.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>trained_at</code> <code>str</code> <p>A string timestamp of when the agent has been trained (None if not trained yet).</p> <code>value_function</code> <code>ValueFunction</code> <p>The value function used for the agent to make decisions.</p> <code>belief</code> <code>BeliefSet</code> <p>Used only during simulations. Part of the Agent's status. Where the agent believes he is over the state space. It is a list of n belief points based on how many simulations are running at once.</p> <code>action_played</code> <code>list[int]</code> <p>Used only during simulations. Part of the Agent's status. Records what action was last played by the agent. A list of n actions played based on how many simulations are running at once.</p> Source code in <code>olfactory_navigation/agents/pbvi_ssra_agent.py</code> <pre><code>class PBVI_SSRA_Agent(PBVI_Agent):\n    '''\n    A flavor of the PBVI Agent. The expand function consists in choosing random actions and observations and generating belief points based on that.\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment to train the agent with.\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.\n    seed : int, default=12131415\n        For reproducible randomness.\n    model : Model, optional\n        A POMDP model to use to represent the olfactory environment.\n        If not provided, the environment_converter parameter will be used.\n    environment_converter : Callable, default=exact_converter\n        A function to convert the olfactory environment instance to a POMDP Model instance.\n        By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model.\n        This parameter will be ignored if the model parameter is provided.\n    converter_parameters : dict, optional\n        A set of additional parameters to be passed down to the environment converter.\n\n    Attributes\n    ---------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    model : pomdp.Model\n        The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.\n    saved_at : str\n        The place on disk where the agent has been saved (None if not saved yet).\n    on_gpu : bool\n        Whether the agent has been sent to the gpu or not.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    trained_at : str\n        A string timestamp of when the agent has been trained (None if not trained yet).\n    value_function : ValueFunction\n        The value function used for the agent to make decisions.\n    belief : BeliefSet\n        Used only during simulations.\n        Part of the Agent's status. Where the agent believes he is over the state space.\n        It is a list of n belief points based on how many simulations are running at once.\n    action_played : list[int]\n        Used only during simulations.\n        Part of the Agent's status. Records what action was last played by the agent.\n        A list of n actions played based on how many simulations are running at once.\n    '''\n    def expand(self,\n               belief_set: BeliefSet,\n               value_function: ValueFunction,\n               max_generation: int\n               ) -&gt; BeliefSet:\n        '''\n        Stochastic Simulation with Random Action.\n        Simulates running a single-step forward from the beliefs in the \"belief_set\".\n        The step forward is taking assuming we are in a random state (weighted by the belief) and taking a random action leading to a state s_p and a observation o.\n        From this action a and observation o we can update our belief.\n\n        Parameters\n        ----------\n        belief_set : BeliefSet\n            List of beliefs to expand on.\n        value_function : ValueFunction\n            The current value function. (NOT USED)\n        max_generation : int, default=10\n            The max amount of beliefs that can be added to the belief set at once.\n\n        Returns\n        -------\n        belief_set_new : BeliefSet\n            Union of the belief_set and the expansions of the beliefs in the belief_set.\n        '''\n        # GPU support\n        xp = np if not self.on_gpu else cp\n        model = self.model\n\n        old_shape = belief_set.belief_array.shape\n        to_generate = min(max_generation, old_shape[0])\n\n        new_belief_array = xp.empty((to_generate, old_shape[1]))\n\n        # Random previous beliefs\n        rand_ind = self.rnd_state.choice(np.arange(old_shape[0]), to_generate, replace=False)\n\n        for i, belief_vector in enumerate(belief_set.belief_array[rand_ind]):\n            b = Belief(model, belief_vector)\n            s = b.random_state()\n            a = self.rnd_state.choice(model.actions)\n            s_p = model.transition(s, a)\n            o = model.observe(s_p, a)\n            b_new = b.update(a, o)\n\n            new_belief_array[i] = b_new.values\n\n        return BeliefSet(model, new_belief_array)\n\n\n    def train(self,\n              expansions: int,\n              update_passes: int = 1,\n              max_belief_growth: int = 10,\n              initial_belief: BeliefSet | Belief | None = None,\n              initial_value_function: ValueFunction | None = None,\n              prune_level: int = 1,\n              prune_interval: int = 10,\n              limit_value_function_size: int = -1,\n              gamma: float = 0.99,\n              eps: float = 1e-6,\n              use_gpu: bool = False,\n              history_tracking_level: int = 1,\n              overwrite_training: bool = False,\n              print_progress: bool = True,\n              print_stats: bool = True\n              ) -&gt; TrainingHistory:\n        '''\n        Main loop of the Point-Based Value Iteration algorithm.\n        It consists in 2 steps, Backup and Expand.\n        1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n        2. Backup: Updates the alpha vectors based on the current belief set\n\n        Stochastic Search with Random Action Point-Based Value Iteration:\n        - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)\n\n        Parameters\n        ----------\n        expansions : int\n            How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n        update_passes : int, default=1\n            How many times the backup function has to be run every time the belief set is expanded.\n        max_belief_growth : int, default=10\n            How many beliefs can be added at every expansion step to the belief set.\n        initial_belief : BeliefSet or Belief, optional\n            An initial list of beliefs to start with.\n        initial_value_function : ValueFunction, optional\n            An initial value function to start the solving process with.\n        prune_level : int, default=1\n            Parameter to prune the value function further before the expand function.\n        prune_interval : int, default=10\n            How often to prune the value function. It is counted in number of backup iterations.\n        limit_value_function_size : int, default=-1\n            When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n            If set to -1, the value function can grow without bounds.\n        use_gpu : bool, default=False\n            Whether to use the GPU with cupy array to accelerate solving.\n        gamma : float, default=0.99\n            The discount factor to value immediate rewards more than long term rewards.\n            The learning rate is 1/gamma.\n        eps : float, default=1e-6\n            The smallest allowed changed for the value function.\n            Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n        history_tracking_level : int, default=1\n            How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n        overwrite_training : bool, default=False\n            Whether to force the overwriting of the training if a value function already exists for this agent.\n        print_progress : bool, default=True\n            Whether or not to print out the progress of the value iteration process.\n        print_stats : bool, default=True\n            Whether or not to print out statistics at the end of the training run.\n\n        Returns\n        -------\n        solver_history : SolverHistory\n            The history of the solving process with some plotting options.\n        '''\n        return super().train(expansions = expansions,\n                             full_backup = True,\n                             update_passes = update_passes,\n                             max_belief_growth = max_belief_growth,\n                             initial_belief = initial_belief,\n                             initial_value_function = initial_value_function,\n                             prune_level = prune_level,\n                             prune_interval = prune_interval,\n                             limit_value_function_size = limit_value_function_size,\n                             gamma = gamma,\n                             eps = eps,\n                             use_gpu = use_gpu,\n                             history_tracking_level = history_tracking_level,\n                             overwrite_training = overwrite_training,\n                             print_progress = print_progress,\n                             print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/pbvi_ssra_agent/#olfactory_navigation.agents.pbvi_ssra_agent.PBVI_SSRA_Agent.expand","title":"<code>expand(belief_set, value_function, max_generation)</code>","text":"<p>Stochastic Simulation with Random Action. Simulates running a single-step forward from the beliefs in the \"belief_set\". The step forward is taking assuming we are in a random state (weighted by the belief) and taking a random action leading to a state s_p and a observation o. From this action a and observation o we can update our belief.</p> <p>Parameters:</p> Name Type Description Default <code>belief_set</code> <code>BeliefSet</code> <p>List of beliefs to expand on.</p> required <code>value_function</code> <code>ValueFunction</code> <p>The current value function. (NOT USED)</p> required <code>max_generation</code> <code>int</code> <p>The max amount of beliefs that can be added to the belief set at once.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>belief_set_new</code> <code>BeliefSet</code> <p>Union of the belief_set and the expansions of the beliefs in the belief_set.</p> Source code in <code>olfactory_navigation/agents/pbvi_ssra_agent.py</code> <pre><code>def expand(self,\n           belief_set: BeliefSet,\n           value_function: ValueFunction,\n           max_generation: int\n           ) -&gt; BeliefSet:\n    '''\n    Stochastic Simulation with Random Action.\n    Simulates running a single-step forward from the beliefs in the \"belief_set\".\n    The step forward is taking assuming we are in a random state (weighted by the belief) and taking a random action leading to a state s_p and a observation o.\n    From this action a and observation o we can update our belief.\n\n    Parameters\n    ----------\n    belief_set : BeliefSet\n        List of beliefs to expand on.\n    value_function : ValueFunction\n        The current value function. (NOT USED)\n    max_generation : int, default=10\n        The max amount of beliefs that can be added to the belief set at once.\n\n    Returns\n    -------\n    belief_set_new : BeliefSet\n        Union of the belief_set and the expansions of the beliefs in the belief_set.\n    '''\n    # GPU support\n    xp = np if not self.on_gpu else cp\n    model = self.model\n\n    old_shape = belief_set.belief_array.shape\n    to_generate = min(max_generation, old_shape[0])\n\n    new_belief_array = xp.empty((to_generate, old_shape[1]))\n\n    # Random previous beliefs\n    rand_ind = self.rnd_state.choice(np.arange(old_shape[0]), to_generate, replace=False)\n\n    for i, belief_vector in enumerate(belief_set.belief_array[rand_ind]):\n        b = Belief(model, belief_vector)\n        s = b.random_state()\n        a = self.rnd_state.choice(model.actions)\n        s_p = model.transition(s, a)\n        o = model.observe(s_p, a)\n        b_new = b.update(a, o)\n\n        new_belief_array[i] = b_new.values\n\n    return BeliefSet(model, new_belief_array)\n</code></pre>"},{"location":"reference/agents/pbvi_ssra_agent/#olfactory_navigation.agents.pbvi_ssra_agent.PBVI_SSRA_Agent.train","title":"<code>train(expansions, update_passes=1, max_belief_growth=10, initial_belief=None, initial_value_function=None, prune_level=1, prune_interval=10, limit_value_function_size=-1, gamma=0.99, eps=1e-06, use_gpu=False, history_tracking_level=1, overwrite_training=False, print_progress=True, print_stats=True)</code>","text":"<p>Main loop of the Point-Based Value Iteration algorithm. It consists in 2 steps, Backup and Expand. 1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function 2. Backup: Updates the alpha vectors based on the current belief set</p> <p>Stochastic Search with Random Action Point-Based Value Iteration: - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)</p> <p>Parameters:</p> Name Type Description Default <code>expansions</code> <code>int</code> <p>How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)</p> required <code>update_passes</code> <code>int</code> <p>How many times the backup function has to be run every time the belief set is expanded.</p> <code>1</code> <code>max_belief_growth</code> <code>int</code> <p>How many beliefs can be added at every expansion step to the belief set.</p> <code>10</code> <code>initial_belief</code> <code>BeliefSet or Belief</code> <p>An initial list of beliefs to start with.</p> <code>None</code> <code>initial_value_function</code> <code>ValueFunction</code> <p>An initial value function to start the solving process with.</p> <code>None</code> <code>prune_level</code> <code>int</code> <p>Parameter to prune the value function further before the expand function.</p> <code>1</code> <code>prune_interval</code> <code>int</code> <p>How often to prune the value function. It is counted in number of backup iterations.</p> <code>10</code> <code>limit_value_function_size</code> <code>int</code> <p>When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function If set to -1, the value function can grow without bounds.</p> <code>-1</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU with cupy array to accelerate solving.</p> <code>False</code> <code>gamma</code> <code>float</code> <p>The discount factor to value immediate rewards more than long term rewards. The learning rate is 1/gamma.</p> <code>0.99</code> <code>eps</code> <code>float</code> <p>The smallest allowed changed for the value function. Bellow the amound of change, the value function is considered converged and the value iteration process will end early.</p> <code>1e-6</code> <code>history_tracking_level</code> <code>int</code> <p>How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)</p> <code>1</code> <code>overwrite_training</code> <code>bool</code> <p>Whether to force the overwriting of the training if a value function already exists for this agent.</p> <code>False</code> <code>print_progress</code> <code>bool</code> <p>Whether or not to print out the progress of the value iteration process.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether or not to print out statistics at the end of the training run.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>solver_history</code> <code>SolverHistory</code> <p>The history of the solving process with some plotting options.</p> Source code in <code>olfactory_navigation/agents/pbvi_ssra_agent.py</code> <pre><code>def train(self,\n          expansions: int,\n          update_passes: int = 1,\n          max_belief_growth: int = 10,\n          initial_belief: BeliefSet | Belief | None = None,\n          initial_value_function: ValueFunction | None = None,\n          prune_level: int = 1,\n          prune_interval: int = 10,\n          limit_value_function_size: int = -1,\n          gamma: float = 0.99,\n          eps: float = 1e-6,\n          use_gpu: bool = False,\n          history_tracking_level: int = 1,\n          overwrite_training: bool = False,\n          print_progress: bool = True,\n          print_stats: bool = True\n          ) -&gt; TrainingHistory:\n    '''\n    Main loop of the Point-Based Value Iteration algorithm.\n    It consists in 2 steps, Backup and Expand.\n    1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n    2. Backup: Updates the alpha vectors based on the current belief set\n\n    Stochastic Search with Random Action Point-Based Value Iteration:\n    - By default it performs the backup on the whole set of beliefs generated since the start. (so it full_backup=True)\n\n    Parameters\n    ----------\n    expansions : int\n        How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n    update_passes : int, default=1\n        How many times the backup function has to be run every time the belief set is expanded.\n    max_belief_growth : int, default=10\n        How many beliefs can be added at every expansion step to the belief set.\n    initial_belief : BeliefSet or Belief, optional\n        An initial list of beliefs to start with.\n    initial_value_function : ValueFunction, optional\n        An initial value function to start the solving process with.\n    prune_level : int, default=1\n        Parameter to prune the value function further before the expand function.\n    prune_interval : int, default=10\n        How often to prune the value function. It is counted in number of backup iterations.\n    limit_value_function_size : int, default=-1\n        When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n        If set to -1, the value function can grow without bounds.\n    use_gpu : bool, default=False\n        Whether to use the GPU with cupy array to accelerate solving.\n    gamma : float, default=0.99\n        The discount factor to value immediate rewards more than long term rewards.\n        The learning rate is 1/gamma.\n    eps : float, default=1e-6\n        The smallest allowed changed for the value function.\n        Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n    history_tracking_level : int, default=1\n        How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n    overwrite_training : bool, default=False\n        Whether to force the overwriting of the training if a value function already exists for this agent.\n    print_progress : bool, default=True\n        Whether or not to print out the progress of the value iteration process.\n    print_stats : bool, default=True\n        Whether or not to print out statistics at the end of the training run.\n\n    Returns\n    -------\n    solver_history : SolverHistory\n        The history of the solving process with some plotting options.\n    '''\n    return super().train(expansions = expansions,\n                         full_backup = True,\n                         update_passes = update_passes,\n                         max_belief_growth = max_belief_growth,\n                         initial_belief = initial_belief,\n                         initial_value_function = initial_value_function,\n                         prune_level = prune_level,\n                         prune_interval = prune_interval,\n                         limit_value_function_size = limit_value_function_size,\n                         gamma = gamma,\n                         eps = eps,\n                         use_gpu = use_gpu,\n                         history_tracking_level = history_tracking_level,\n                         overwrite_training = overwrite_training,\n                         print_progress = print_progress,\n                         print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/perseus_agent/","title":"perseus_agent","text":""},{"location":"reference/agents/perseus_agent/#olfactory_navigation.agents.perseus_agent.Perseus_Agent","title":"<code>Perseus_Agent</code>","text":"<p>               Bases: <code>PBVI_Agent</code></p> <p>A flavor of the PBVI Agent.</p>"},{"location":"reference/agents/perseus_agent/#olfactory_navigation.agents.perseus_agent.Perseus_Agent--todo-do-document-of-perseus-agent","title":"TODO: Do document of Perseus agent","text":""},{"location":"reference/agents/perseus_agent/#olfactory_navigation.agents.perseus_agent.Perseus_Agent--todo-fix-perseus-expand","title":"TODO: FIX Perseus expand","text":"<p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment to train the agent with.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.</p> <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <code>model</code> <code>Model</code> <p>A POMDP model to use to represent the olfactory environment. If not provided, the environment_converter parameter will be used.</p> <code>None</code> <code>environment_converter</code> <code>Callable</code> <p>A function to convert the olfactory environment instance to a POMDP Model instance. By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model. This parameter will be ignored if the model parameter is provided.</p> <code>exact_converter</code> <code>converter_parameters</code> <code>dict</code> <p>A set of additional parameters to be passed down to the environment converter.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>model</code> <code>Model</code> <p>The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.</p> <code>saved_at</code> <code>str</code> <p>The place on disk where the agent has been saved (None if not saved yet).</p> <code>on_gpu</code> <code>bool</code> <p>Whether the agent has been sent to the gpu or not.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>trained_at</code> <code>str</code> <p>A string timestamp of when the agent has been trained (None if not trained yet).</p> <code>value_function</code> <code>ValueFunction</code> <p>The value function used for the agent to make decisions.</p> <code>belief</code> <code>BeliefSet</code> <p>Used only during simulations. Part of the Agent's status. Where the agent believes he is over the state space. It is a list of n belief points based on how many simulations are running at once.</p> <code>action_played</code> <code>list[int]</code> <p>Used only during simulations. Part of the Agent's status. Records what action was last played by the agent. A list of n actions played based on how many simulations are running at once.</p> Source code in <code>olfactory_navigation/agents/perseus_agent.py</code> <pre><code>class Perseus_Agent(PBVI_Agent):\n    '''\n    A flavor of the PBVI Agent.\n\n    # TODO: Do document of Perseus agent\n    # TODO: FIX Perseus expand\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment to train the agent with.\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.\n    seed : int, default=12131415\n        For reproducible randomness.\n    model : Model, optional\n        A POMDP model to use to represent the olfactory environment.\n        If not provided, the environment_converter parameter will be used.\n    environment_converter : Callable, default=exact_converter\n        A function to convert the olfactory environment instance to a POMDP Model instance.\n        By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model.\n        This parameter will be ignored if the model parameter is provided.\n    converter_parameters : dict, optional\n        A set of additional parameters to be passed down to the environment converter.\n\n    Attributes\n    ---------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    model : pomdp.Model\n        The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.\n    saved_at : str\n        The place on disk where the agent has been saved (None if not saved yet).\n    on_gpu : bool\n        Whether the agent has been sent to the gpu or not.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    trained_at : str\n        A string timestamp of when the agent has been trained (None if not trained yet).\n    value_function : ValueFunction\n        The value function used for the agent to make decisions.\n    belief : BeliefSet\n        Used only during simulations.\n        Part of the Agent's status. Where the agent believes he is over the state space.\n        It is a list of n belief points based on how many simulations are running at once.\n    action_played : list[int]\n        Used only during simulations.\n        Part of the Agent's status. Records what action was last played by the agent.\n        A list of n actions played based on how many simulations are running at once.\n    '''\n    def expand(self,\n               belief_set: BeliefSet,\n               value_function: ValueFunction,\n               max_generation: int\n               ) -&gt; BeliefSet:\n        '''\n        # TODO\n\n        Parameters\n        ----------\n        belief_set : BeliefSet\n            List of beliefs to expand on.\n        value_function : ValueFunction\n            The current value function. (NOT USED)\n        max_generation : int, default=10\n            The max amount of beliefs that can be added to the belief set at once.\n\n        Returns\n        -------\n        belief_set : BeliefSet\n            A new sequence of beliefs.\n        '''\n        # GPU support\n        xp = np if not self.on_gpu else cp\n        model = self.model\n\n        b = belief_set.belief_list[0]\n        belief_sequence = []\n\n        for i in range(max_generation):\n            # Choose random action\n            a = int(self.rnd_state.choice(model.actions, size=1)[0])\n\n            # Choose random observation based on prob: P(o|b,a)\n            obs_prob = xp.einsum('sor,s-&gt;o', model.reachable_transitional_observation_table[:,a,:,:], b.values)\n            o = int(self.rnd_state.choice(model.observations, size=1, p=obs_prob)[0])\n\n            # Update belief\n            bao = b.update(a,o)\n\n            # Finalization\n            belief_sequence.append(bao)\n            b = bao\n\n        return BeliefSet(model, belief_sequence)\n\n\n    def train(self,\n              expansions: int,\n              update_passes: int = 1,\n              max_belief_growth: int = 10,\n              initial_belief: BeliefSet | Belief | None = None,\n              initial_value_function: ValueFunction | None = None,\n              prune_level: int = 1,\n              prune_interval: int = 10,\n              limit_value_function_size: int = -1,\n              gamma: float = 0.99,\n              eps: float = 1e-6,\n              use_gpu: bool = False,\n              history_tracking_level: int = 1,\n              overwrite_training: bool = False,\n              print_progress: bool = True,\n              print_stats: bool = True\n              ) -&gt; TrainingHistory:\n        '''\n        Main loop of the Point-Based Value Iteration algorithm.\n        It consists in 2 steps, Backup and Expand.\n        1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n        2. Backup: Updates the alpha vectors based on the current belief set\n\n        Heuristic Search Value Iteration:\n        - By default it performs the backup only on set of beliefs generated by the expand function. (so it full_backup=False)\n\n        Parameters\n        ----------\n        expansions : int\n            How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n        update_passes : int, default=1\n            How many times the backup function has to be run every time the belief set is expanded.\n        max_belief_growth : int, default=10\n            How many beliefs can be added at every expansion step to the belief set.\n        initial_belief : BeliefSet or Belief, optional\n            An initial list of beliefs to start with.\n        initial_value_function : ValueFunction, optional\n            An initial value function to start the solving process with.\n        prune_level : int, default=1\n            Parameter to prune the value function further before the expand function.\n        prune_interval : int, default=10\n            How often to prune the value function. It is counted in number of backup iterations.\n        limit_value_function_size : int, default=-1\n            When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n            If set to -1, the value function can grow without bounds.\n        use_gpu : bool, default=False\n            Whether to use the GPU with cupy array to accelerate solving.\n        gamma : float, default=0.99\n            The discount factor to value immediate rewards more than long term rewards.\n            The learning rate is 1/gamma.\n        eps : float, default=1e-6\n            The smallest allowed changed for the value function.\n            Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n        history_tracking_level : int, default=1\n            How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n        overwrite_training : bool, default=False\n            Whether to force the overwriting of the training if a value function already exists for this agent.\n        print_progress : bool, default=True\n            Whether or not to print out the progress of the value iteration process.\n        print_stats : bool, default=True\n            Whether or not to print out statistics at the end of the training run.\n\n        Returns\n        -------\n        solver_history : SolverHistory\n            The history of the solving process with some plotting options.\n        '''\n        return super().train(expansions = expansions,\n                             full_backup = False,\n                             update_passes = update_passes,\n                             max_belief_growth = max_belief_growth,\n                             initial_belief = initial_belief,\n                             initial_value_function = initial_value_function,\n                             prune_level = prune_level,\n                             prune_interval = prune_interval,\n                             limit_value_function_size = limit_value_function_size,\n                             gamma = gamma,\n                             eps = eps,\n                             use_gpu = use_gpu,\n                             history_tracking_level = history_tracking_level,\n                             overwrite_training = overwrite_training,\n                             print_progress = print_progress,\n                             print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/perseus_agent/#olfactory_navigation.agents.perseus_agent.Perseus_Agent.expand","title":"<code>expand(belief_set, value_function, max_generation)</code>","text":""},{"location":"reference/agents/perseus_agent/#olfactory_navigation.agents.perseus_agent.Perseus_Agent.expand--todo","title":"TODO","text":"<p>Parameters:</p> Name Type Description Default <code>belief_set</code> <code>BeliefSet</code> <p>List of beliefs to expand on.</p> required <code>value_function</code> <code>ValueFunction</code> <p>The current value function. (NOT USED)</p> required <code>max_generation</code> <code>int</code> <p>The max amount of beliefs that can be added to the belief set at once.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>belief_set</code> <code>BeliefSet</code> <p>A new sequence of beliefs.</p> Source code in <code>olfactory_navigation/agents/perseus_agent.py</code> <pre><code>def expand(self,\n           belief_set: BeliefSet,\n           value_function: ValueFunction,\n           max_generation: int\n           ) -&gt; BeliefSet:\n    '''\n    # TODO\n\n    Parameters\n    ----------\n    belief_set : BeliefSet\n        List of beliefs to expand on.\n    value_function : ValueFunction\n        The current value function. (NOT USED)\n    max_generation : int, default=10\n        The max amount of beliefs that can be added to the belief set at once.\n\n    Returns\n    -------\n    belief_set : BeliefSet\n        A new sequence of beliefs.\n    '''\n    # GPU support\n    xp = np if not self.on_gpu else cp\n    model = self.model\n\n    b = belief_set.belief_list[0]\n    belief_sequence = []\n\n    for i in range(max_generation):\n        # Choose random action\n        a = int(self.rnd_state.choice(model.actions, size=1)[0])\n\n        # Choose random observation based on prob: P(o|b,a)\n        obs_prob = xp.einsum('sor,s-&gt;o', model.reachable_transitional_observation_table[:,a,:,:], b.values)\n        o = int(self.rnd_state.choice(model.observations, size=1, p=obs_prob)[0])\n\n        # Update belief\n        bao = b.update(a,o)\n\n        # Finalization\n        belief_sequence.append(bao)\n        b = bao\n\n    return BeliefSet(model, belief_sequence)\n</code></pre>"},{"location":"reference/agents/perseus_agent/#olfactory_navigation.agents.perseus_agent.Perseus_Agent.train","title":"<code>train(expansions, update_passes=1, max_belief_growth=10, initial_belief=None, initial_value_function=None, prune_level=1, prune_interval=10, limit_value_function_size=-1, gamma=0.99, eps=1e-06, use_gpu=False, history_tracking_level=1, overwrite_training=False, print_progress=True, print_stats=True)</code>","text":"<p>Main loop of the Point-Based Value Iteration algorithm. It consists in 2 steps, Backup and Expand. 1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function 2. Backup: Updates the alpha vectors based on the current belief set</p> <p>Heuristic Search Value Iteration: - By default it performs the backup only on set of beliefs generated by the expand function. (so it full_backup=False)</p> <p>Parameters:</p> Name Type Description Default <code>expansions</code> <code>int</code> <p>How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)</p> required <code>update_passes</code> <code>int</code> <p>How many times the backup function has to be run every time the belief set is expanded.</p> <code>1</code> <code>max_belief_growth</code> <code>int</code> <p>How many beliefs can be added at every expansion step to the belief set.</p> <code>10</code> <code>initial_belief</code> <code>BeliefSet or Belief</code> <p>An initial list of beliefs to start with.</p> <code>None</code> <code>initial_value_function</code> <code>ValueFunction</code> <p>An initial value function to start the solving process with.</p> <code>None</code> <code>prune_level</code> <code>int</code> <p>Parameter to prune the value function further before the expand function.</p> <code>1</code> <code>prune_interval</code> <code>int</code> <p>How often to prune the value function. It is counted in number of backup iterations.</p> <code>10</code> <code>limit_value_function_size</code> <code>int</code> <p>When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function If set to -1, the value function can grow without bounds.</p> <code>-1</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU with cupy array to accelerate solving.</p> <code>False</code> <code>gamma</code> <code>float</code> <p>The discount factor to value immediate rewards more than long term rewards. The learning rate is 1/gamma.</p> <code>0.99</code> <code>eps</code> <code>float</code> <p>The smallest allowed changed for the value function. Bellow the amound of change, the value function is considered converged and the value iteration process will end early.</p> <code>1e-6</code> <code>history_tracking_level</code> <code>int</code> <p>How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)</p> <code>1</code> <code>overwrite_training</code> <code>bool</code> <p>Whether to force the overwriting of the training if a value function already exists for this agent.</p> <code>False</code> <code>print_progress</code> <code>bool</code> <p>Whether or not to print out the progress of the value iteration process.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether or not to print out statistics at the end of the training run.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>solver_history</code> <code>SolverHistory</code> <p>The history of the solving process with some plotting options.</p> Source code in <code>olfactory_navigation/agents/perseus_agent.py</code> <pre><code>def train(self,\n          expansions: int,\n          update_passes: int = 1,\n          max_belief_growth: int = 10,\n          initial_belief: BeliefSet | Belief | None = None,\n          initial_value_function: ValueFunction | None = None,\n          prune_level: int = 1,\n          prune_interval: int = 10,\n          limit_value_function_size: int = -1,\n          gamma: float = 0.99,\n          eps: float = 1e-6,\n          use_gpu: bool = False,\n          history_tracking_level: int = 1,\n          overwrite_training: bool = False,\n          print_progress: bool = True,\n          print_stats: bool = True\n          ) -&gt; TrainingHistory:\n    '''\n    Main loop of the Point-Based Value Iteration algorithm.\n    It consists in 2 steps, Backup and Expand.\n    1. Expand: Expands the belief set base with a expansion strategy given by the parameter expand_function\n    2. Backup: Updates the alpha vectors based on the current belief set\n\n    Heuristic Search Value Iteration:\n    - By default it performs the backup only on set of beliefs generated by the expand function. (so it full_backup=False)\n\n    Parameters\n    ----------\n    expansions : int\n        How many times the algorithm has to expand the belief set. (the size will be doubled every time, eg: for 5, the belief set will be of size 32)\n    update_passes : int, default=1\n        How many times the backup function has to be run every time the belief set is expanded.\n    max_belief_growth : int, default=10\n        How many beliefs can be added at every expansion step to the belief set.\n    initial_belief : BeliefSet or Belief, optional\n        An initial list of beliefs to start with.\n    initial_value_function : ValueFunction, optional\n        An initial value function to start the solving process with.\n    prune_level : int, default=1\n        Parameter to prune the value function further before the expand function.\n    prune_interval : int, default=10\n        How often to prune the value function. It is counted in number of backup iterations.\n    limit_value_function_size : int, default=-1\n        When the value function size crosses this threshold, a random selection of 'max_belief_growth' alpha vectors will be removed from the value function\n        If set to -1, the value function can grow without bounds.\n    use_gpu : bool, default=False\n        Whether to use the GPU with cupy array to accelerate solving.\n    gamma : float, default=0.99\n        The discount factor to value immediate rewards more than long term rewards.\n        The learning rate is 1/gamma.\n    eps : float, default=1e-6\n        The smallest allowed changed for the value function.\n        Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n    history_tracking_level : int, default=1\n        How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n    overwrite_training : bool, default=False\n        Whether to force the overwriting of the training if a value function already exists for this agent.\n    print_progress : bool, default=True\n        Whether or not to print out the progress of the value iteration process.\n    print_stats : bool, default=True\n        Whether or not to print out statistics at the end of the training run.\n\n    Returns\n    -------\n    solver_history : SolverHistory\n        The history of the solving process with some plotting options.\n    '''\n    return super().train(expansions = expansions,\n                         full_backup = False,\n                         update_passes = update_passes,\n                         max_belief_growth = max_belief_growth,\n                         initial_belief = initial_belief,\n                         initial_value_function = initial_value_function,\n                         prune_level = prune_level,\n                         prune_interval = prune_interval,\n                         limit_value_function_size = limit_value_function_size,\n                         gamma = gamma,\n                         eps = eps,\n                         use_gpu = use_gpu,\n                         history_tracking_level = history_tracking_level,\n                         overwrite_training = overwrite_training,\n                         print_progress = print_progress,\n                         print_stats = print_stats)\n</code></pre>"},{"location":"reference/agents/q_agent/","title":"q_agent","text":""},{"location":"reference/agents/qmdp_agent/","title":"qmdp_agent","text":""},{"location":"reference/agents/qmdp_agent/#olfactory_navigation.agents.qmdp_agent.QMDP_Agent","title":"<code>QMDP_Agent</code>","text":"<p>               Bases: <code>PBVI_Agent</code></p> <p>An agent that relies on Model-Based Reinforcement Learning. It is a simplified version of the PBVI_Agent. It runs the a Value Iteration solver, assuming full observability. The value function that comes out from this is therefore used to make choices.</p> <p>As stated, during simulations, the agent will choose actions based on an argmax of what action has the highest matrix product of the value function with the belief vector.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The olfactory environment to train the agent with.</p> required <code>thresholds</code> <code>float or list[float] or dict[str, float] or dict[str, list[float]]</code> <p>The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not. If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor. A dictionary of (list of) thresholds can also be provided when the environment is layered. In such case, the number of layers provided must match the environment's layers and their labels must match. The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.</p> <code>3e-6</code> <code>space_aware</code> <code>bool</code> <p>Whether the agent is aware of it's own position in space. This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable. Note: The observation array will have a different shape when returned to the update_state function!</p> <code>False</code> <code>spacial_subdivisions</code> <code>ndarray</code> <p>How many spacial compartments the agent has to internally represent the space it lives in. By default, it will be as many as there are grid points in the environment.</p> <code>None</code> <code>actions</code> <code>dict or ndarray</code> <p>The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension). Else, a dict of strings and action vectors where the strings represent the action labels. If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)</p> <code>None</code> <code>name</code> <code>str</code> <p>A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.</p> <code>None</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <code>model</code> <code>Model</code> <p>A POMDP model to use to represent the olfactory environment. If not provided, the environment_converter parameter will be used.</p> <code>None</code> <code>environment_converter</code> <code>Callable</code> <p>A function to convert the olfactory environment instance to a POMDP Model instance. By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model. This parameter will be ignored if the model parameter is provided.</p> <code>exact_converter</code> <code>converter_parameters</code> <code>dict</code> <p>A set of additional parameters to be passed down to the environment converter.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>environment</code> <code>Environment</code> <code>thresholds</code> <code>ndarray</code> <p>An array of the thresholds of detection, starting with -inf and ending with +inf. In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.</p> <code>space_aware</code> <code>bool</code> <code>spacial_subdivisions</code> <code>ndarray</code> <code>name</code> <code>str</code> <code>action_set</code> <code>ndarray</code> <p>The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].</p> <code>action_labels</code> <code>list[str]</code> <p>The labels associated to the action vectors present in the action set.</p> <code>model</code> <code>Model</code> <p>The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.</p> <code>saved_at</code> <code>str</code> <p>The place on disk where the agent has been saved (None if not saved yet).</p> <code>on_gpu</code> <code>bool</code> <p>Whether the agent has been sent to the gpu or not.</p> <code>class_name</code> <code>str</code> <p>The name of the class of the agent.</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> <code>cpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>gpu_version</code> <code>Agent</code> <p>An instance of the agent on the CPU. If it already is, it returns itself.</p> <code>trained_at</code> <code>str</code> <p>A string timestamp of when the agent has been trained (None if not trained yet).</p> <code>value_function</code> <code>ValueFunction</code> <p>The value function used for the agent to make decisions.</p> <code>belief</code> <code>BeliefSet</code> <p>Used only during simulations. Part of the Agent's status. Where the agent believes he is over the state space. It is a list of n belief points based on how many simulations are running at once.</p> <code>action_played</code> <code>list[int]</code> <p>Used only during simulations. Part of the Agent's status. Records what action was last played by the agent. A list of n actions played based on how many simulations are running at once.</p> Source code in <code>olfactory_navigation/agents/qmdp_agent.py</code> <pre><code>class QMDP_Agent(PBVI_Agent):\n    '''\n    An agent that relies on Model-Based Reinforcement Learning. It is a simplified version of the PBVI_Agent.\n    It runs the a Value Iteration solver, assuming full observability. The value function that comes out from this is therefore used to make choices.\n\n    As stated, during simulations, the agent will choose actions based on an argmax of what action has the highest matrix product of the value function with the belief vector.\n\n\n    Parameters\n    ----------\n    environment : Environment\n        The olfactory environment to train the agent with.\n    thresholds : float or list[float] or dict[str, float] or dict[str, list[float]], default=3e-6\n        The olfactory thresholds. If an odor cue above this threshold is detected, the agent detects it, else it does not.\n        If a list of thresholds is provided, he agent should be able to detect |thresholds|+1 levels of odor.\n        A dictionary of (list of) thresholds can also be provided when the environment is layered.\n        In such case, the number of layers provided must match the environment's layers and their labels must match.\n        The thresholds provided will be converted to an array where the levels start with -inf and end with +inf.\n    space_aware : bool, default=False\n        Whether the agent is aware of it's own position in space.\n        This is to be used in scenarios where, for example, the agent is an enclosed container and the source is the variable.\n        Note: The observation array will have a different shape when returned to the update_state function!\n    spacial_subdivisions : np.ndarray, optional\n        How many spacial compartments the agent has to internally represent the space it lives in.\n        By default, it will be as many as there are grid points in the environment.\n    actions : dict or np.ndarray, optional\n        The set of action available to the agent. It should match the type of environment (ie: if the environment has layers, it should contain a layer component to the action vector, and similarly for a third dimension).\n        Else, a dict of strings and action vectors where the strings represent the action labels.\n        If none is provided, by default, all unit movement vectors are included and shuch for all layers (if the environment has layers.)\n    name : str, optional\n        A custom name to give the agent. If not provided is will be a combination of the class-name and the threshold.\n    seed : int, default=12131415\n        For reproducible randomness.\n    model : Model, optional\n        A POMDP model to use to represent the olfactory environment.\n        If not provided, the environment_converter parameter will be used.\n    environment_converter : Callable, default=exact_converter\n        A function to convert the olfactory environment instance to a POMDP Model instance.\n        By default, we use an exact convertion that keeps the shape of the environment to make the amount of states of the POMDP Model.\n        This parameter will be ignored if the model parameter is provided.\n    converter_parameters : dict, optional\n        A set of additional parameters to be passed down to the environment converter.\n\n    Attributes\n    ---------\n    environment : Environment\n    thresholds : np.ndarray\n        An array of the thresholds of detection, starting with -inf and ending with +inf.\n        In the case of a 2D array of thresholds, the rows of thresholds apply to the different layers of the environment.\n    space_aware : bool\n    spacial_subdivisions : np.ndarray\n    name : str\n    action_set : np.ndarray\n        The actions allowed of the agent. Formulated as movement vectors as [(layer,) (dz,) dy, dx].\n    action_labels : list[str]\n        The labels associated to the action vectors present in the action set.\n    model : pomdp.Model\n        The environment converted to a POMDP model using the \"from_environment\" constructor of the pomdp.Model class.\n    saved_at : str\n        The place on disk where the agent has been saved (None if not saved yet).\n    on_gpu : bool\n        Whether the agent has been sent to the gpu or not.\n    class_name : str\n        The name of the class of the agent.\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    cpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    gpu_version : Agent\n        An instance of the agent on the CPU. If it already is, it returns itself.\n    trained_at : str\n        A string timestamp of when the agent has been trained (None if not trained yet).\n    value_function : ValueFunction\n        The value function used for the agent to make decisions.\n    belief : BeliefSet\n        Used only during simulations.\n        Part of the Agent's status. Where the agent believes he is over the state space.\n        It is a list of n belief points based on how many simulations are running at once.\n    action_played : list[int]\n        Used only during simulations.\n        Part of the Agent's status. Records what action was last played by the agent.\n        A list of n actions played based on how many simulations are running at once.\n    '''\n    def train(self,\n              expansions: int,\n              initial_value_function: ValueFunction | None = None,\n              gamma: float = 0.99,\n              eps: float = 1e-6,\n              use_gpu: bool = False,\n              history_tracking_level: int = 1,\n              overwrite_training: bool = False,\n              print_progress: bool = True,\n              print_stats: bool = True\n              ) -&gt; TrainingHistory:\n        '''\n        Simplified version of the training. It consists in running the Value Iteration process.\n\n        Parameters\n        ----------\n        expansions : int\n            How many iterations to run the Value Iteration process for.\n        initial_value_function : ValueFunction, optional\n            An initial value function to start the solving process with.\n        use_gpu : bool, default=False\n            Whether to use the GPU with cupy array to accelerate solving.\n        gamma : float, default=0.99\n            The discount factor to value immediate rewards more than long term rewards.\n            The learning rate is 1/gamma.\n        eps : float, default=1e-6\n            The smallest allowed changed for the value function.\n            Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n        history_tracking_level : int, default=1\n            How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n        overwrite_training : bool, default=False\n            Whether to force the overwriting of the training if a value function already exists for this agent.\n        print_progress : bool, default=True\n            Whether or not to print out the progress of the value iteration process.\n        print_stats : bool, default=True\n            Whether or not to print out statistics at the end of the training run.\n\n        Returns\n        -------\n        solver_history : SolverHistory\n            The history of the solving process with some plotting options.\n        '''\n        # Handeling the case where the agent is already trained\n        if (self.value_function is not None):\n            if overwrite_training:\n                self.trained_at = None\n                self.name = '-'.join(self.name.split('-')[:-1])\n                self.value_function = None\n            else:\n                initial_value_function = self.value_function\n\n        model = self.model if not use_gpu else self.model.gpu_model\n\n        # Value Iteration solving\n        value_function, hist = vi_solver.solve(model = model,\n                                               horizon = expansions,\n                                               initial_value_function = initial_value_function,\n                                               gamma = gamma,\n                                               eps = eps,\n                                               use_gpu = use_gpu,\n                                               history_tracking_level = history_tracking_level,\n                                               print_progress = print_progress)\n\n        # Record when it was trained\n        self.trained_at = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        self.name += f'-trained_{self.trained_at}'\n\n        self.value_function = value_function.to_cpu() if not self.on_gpu else value_function.to_gpu()\n\n        # Print stats if requested\n        if print_stats:\n            print(hist.summary)\n\n        return hist\n</code></pre>"},{"location":"reference/agents/qmdp_agent/#olfactory_navigation.agents.qmdp_agent.QMDP_Agent.train","title":"<code>train(expansions, initial_value_function=None, gamma=0.99, eps=1e-06, use_gpu=False, history_tracking_level=1, overwrite_training=False, print_progress=True, print_stats=True)</code>","text":"<p>Simplified version of the training. It consists in running the Value Iteration process.</p> <p>Parameters:</p> Name Type Description Default <code>expansions</code> <code>int</code> <p>How many iterations to run the Value Iteration process for.</p> required <code>initial_value_function</code> <code>ValueFunction</code> <p>An initial value function to start the solving process with.</p> <code>None</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU with cupy array to accelerate solving.</p> <code>False</code> <code>gamma</code> <code>float</code> <p>The discount factor to value immediate rewards more than long term rewards. The learning rate is 1/gamma.</p> <code>0.99</code> <code>eps</code> <code>float</code> <p>The smallest allowed changed for the value function. Bellow the amound of change, the value function is considered converged and the value iteration process will end early.</p> <code>1e-6</code> <code>history_tracking_level</code> <code>int</code> <p>How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)</p> <code>1</code> <code>overwrite_training</code> <code>bool</code> <p>Whether to force the overwriting of the training if a value function already exists for this agent.</p> <code>False</code> <code>print_progress</code> <code>bool</code> <p>Whether or not to print out the progress of the value iteration process.</p> <code>True</code> <code>print_stats</code> <code>bool</code> <p>Whether or not to print out statistics at the end of the training run.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>solver_history</code> <code>SolverHistory</code> <p>The history of the solving process with some plotting options.</p> Source code in <code>olfactory_navigation/agents/qmdp_agent.py</code> <pre><code>def train(self,\n          expansions: int,\n          initial_value_function: ValueFunction | None = None,\n          gamma: float = 0.99,\n          eps: float = 1e-6,\n          use_gpu: bool = False,\n          history_tracking_level: int = 1,\n          overwrite_training: bool = False,\n          print_progress: bool = True,\n          print_stats: bool = True\n          ) -&gt; TrainingHistory:\n    '''\n    Simplified version of the training. It consists in running the Value Iteration process.\n\n    Parameters\n    ----------\n    expansions : int\n        How many iterations to run the Value Iteration process for.\n    initial_value_function : ValueFunction, optional\n        An initial value function to start the solving process with.\n    use_gpu : bool, default=False\n        Whether to use the GPU with cupy array to accelerate solving.\n    gamma : float, default=0.99\n        The discount factor to value immediate rewards more than long term rewards.\n        The learning rate is 1/gamma.\n    eps : float, default=1e-6\n        The smallest allowed changed for the value function.\n        Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n    history_tracking_level : int, default=1\n        How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n    overwrite_training : bool, default=False\n        Whether to force the overwriting of the training if a value function already exists for this agent.\n    print_progress : bool, default=True\n        Whether or not to print out the progress of the value iteration process.\n    print_stats : bool, default=True\n        Whether or not to print out statistics at the end of the training run.\n\n    Returns\n    -------\n    solver_history : SolverHistory\n        The history of the solving process with some plotting options.\n    '''\n    # Handeling the case where the agent is already trained\n    if (self.value_function is not None):\n        if overwrite_training:\n            self.trained_at = None\n            self.name = '-'.join(self.name.split('-')[:-1])\n            self.value_function = None\n        else:\n            initial_value_function = self.value_function\n\n    model = self.model if not use_gpu else self.model.gpu_model\n\n    # Value Iteration solving\n    value_function, hist = vi_solver.solve(model = model,\n                                           horizon = expansions,\n                                           initial_value_function = initial_value_function,\n                                           gamma = gamma,\n                                           eps = eps,\n                                           use_gpu = use_gpu,\n                                           history_tracking_level = history_tracking_level,\n                                           print_progress = print_progress)\n\n    # Record when it was trained\n    self.trained_at = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    self.name += f'-trained_{self.trained_at}'\n\n    self.value_function = value_function.to_cpu() if not self.on_gpu else value_function.to_gpu()\n\n    # Print stats if requested\n    if print_stats:\n        print(hist.summary)\n\n    return hist\n</code></pre>"},{"location":"reference/agents/model_based_util/","title":"model_based_util","text":""},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.Belief","title":"<code>Belief</code>","text":"<p>A class representing a belief in the space of a given model. It is the belief to be in any combination of states: eg:     - In a 2 state POMDP: a belief of (0.5, 0.5) represent the complete ignorance of which state we are in. Where a (1.0, 0.0) belief is the certainty to be in state 0.</p> <p>The belief update function has been implemented based on the belief update define in the paper of J. Pineau, G. Gordon, and S. Thrun, 'Point-based approximations for fast POMDP solving'</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model on which the belief applies on.</p> required <code>values</code> <code>ndarray</code> <p>A vector of the probabilities to be in each state of the model. The sum of the probabilities must sum to 1. If not specified, it will be set as the start probabilities of the model.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>Model</code> <code>values</code> <code>ndarray</code> <code>bytes_repr</code> <code>bytes</code> <p>A representation in bytes of the value of the belief</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>class Belief:\n    '''\n    A class representing a belief in the space of a given model. It is the belief to be in any combination of states:\n    eg:\n        - In a 2 state POMDP: a belief of (0.5, 0.5) represent the complete ignorance of which state we are in. Where a (1.0, 0.0) belief is the certainty to be in state 0.\n\n    The belief update function has been implemented based on the belief update define in the paper of J. Pineau, G. Gordon, and S. Thrun, 'Point-based approximations for fast POMDP solving'\n\n\n    Parameters\n    ----------\n    model : pomdp.Model\n        The model on which the belief applies on.\n    values : np.ndarray, optional\n        A vector of the probabilities to be in each state of the model. The sum of the probabilities must sum to 1.\n        If not specified, it will be set as the start probabilities of the model.\n\n    Attributes\n    ----------\n    model : pomdp.Model\n    values : np.ndarray\n    bytes_repr : bytes\n        A representation in bytes of the value of the belief\n    '''\n    def __init__(self,\n                 model: Model,\n                 values: np.ndarray | None = None\n                 ) -&gt; None:\n        assert model is not None\n        self.model = model\n\n        if values is not None:\n            assert values.shape[0] == model.state_count, \"Belief must contain be of dimension |S|\"\n\n            xp = np if not gpu_support else cp.get_array_module(values)\n\n            prob_sum = xp.sum(values)\n            rounded_sum = xp.round(prob_sum, decimals=3)\n            assert rounded_sum == 1.0, f\"States probabilities in belief must sum to 1 (found: {prob_sum}; rounded {rounded_sum})\"\n\n            self._values = values\n        else:\n            self._values = model.start_probabilities\n\n\n    def __new__(cls, *args, **kwargs):\n        instance = super().__new__(cls)\n\n        instance._bytes_repr = None\n        instance._successors = {}\n\n        return instance\n\n\n    @property\n    def bytes_repr(self) -&gt; bytes:\n        '''\n        A representation as bytes of a belief.\n        '''\n        if self._bytes_repr is None:\n            self._bytes_repr = self.values.tobytes()\n        return self._bytes_repr\n\n\n    def __eq__(self, other: object) -&gt; bool:\n        '''\n        A way to check the equality between two belief points.\n        The byte representation of each belief point is compared.\n        '''\n        return self.bytes_repr == other.bytes_repr\n\n\n    @property\n    def values(self) -&gt; np.ndarray:\n        '''\n        An array of the probability distribution to be in each state.\n        '''\n        return self._values\n\n\n    def update(self,\n               a: int,\n               o: int,\n               throw_error: bool = True\n               ) -&gt; 'Belief':\n        '''\n        Returns a new belief based on this current belief, the most recent action (a) and the most recent observation (o).\n\n        Parameters\n        ----------\n        a : int\n            The most recent action.\n        o : int\n            The most recent observation.\n        throw_error : bool, default=True\n            Whether the creation of an impossible belief (sum of probabilities of 0.0) will throw an error or not.\n\n        Returns\n        -------\n        new_belief : Belief\n            An updated belief\n        '''\n        xp = np if not gpu_support else cp.get_array_module(self._values)\n\n        # Check if successor exists\n        succ_id = f'{a}_{o}'\n        succ = self._successors.get(succ_id)\n        if succ is not None:\n            return succ\n\n        # Computing new probabilities\n        reachable_state_probabilities = self.model.reachable_transitional_observation_table[:,a,o,:] * self.values[:,None]\n        new_state_probabilities = xp.bincount(self.model.reachable_states[:,a,:].flatten(), weights=reachable_state_probabilities.flatten(), minlength=self.model.state_count)\n\n        # Normalization\n        probability_sum = xp.sum(new_state_probabilities)\n        if probability_sum == 0:\n            if throw_error:\n                raise ValueError(\"Impossible belief: the sum of probabilities is 0...\")\n        else:\n            new_state_probabilities /= probability_sum\n\n        # Generation of new belief from new state probabilities\n        new_belief = self.__new__(self.__class__)\n        new_belief.model = self.model\n        new_belief._values = new_state_probabilities\n\n        # Remember generated successor\n        self._successors[succ_id] = new_belief\n\n        return new_belief\n\n\n    def generate_successors(self) -&gt; list['Belief']:\n        '''\n        Function to generate a set of belief that can be reached for each actions and observations available in the model.\n\n        Returns\n        -------\n        successor_beliefs : list[Belief]\n            The successor beliefs.\n        '''\n        successor_beliefs = []\n        for a in self.model.actions:\n            for o in self.model.observations:\n                b_ao = self.update(a,o)\n                successor_beliefs.append(b_ao)\n\n        return successor_beliefs\n\n\n    def random_state(self) -&gt; int:\n        '''\n        Returns a random state of the model weighted by the belief probabily.\n\n        Returns\n        -------\n        rand_s : int\n            A random state.\n        '''\n        xp = np if not gpu_support else cp.get_array_module(self._values)\n\n        rand_s = int(self.model.rnd_state.choice(a=self.model.states, size=1, p=self._values)[0])\n        return rand_s\n\n\n    @property\n    def entropy(self) -&gt; float:\n        '''\n        The entropy of the belief point\n        '''\n        xp = np if not gpu_support else cp.get_array_module(self._values)\n\n        return float(entropy(self._values) if xp == np else cupy_entropy(self._values))\n\n\n    def plot(self, size: int = 5) -&gt; None:\n        '''\n        Function to plot a heatmap of the belief distribution if the belief is of a grid model.\n\n        Parameters\n        ----------\n        size : int, default=5\n            The scale of the plot.\n        '''\n        # Plot setup\n        plt.figure(figsize=(size*1.2,size))\n\n        model = self.model.cpu_model\n\n        # Ticks\n        dimensions = model.state_grid.shape\n        x_ticks = np.arange(0, dimensions[1], (1 if dimensions[1] &lt; 10 else int(dimensions[1] / 10)))\n        y_ticks = np.arange(0, dimensions[0], (1 if dimensions[0] &lt; 5 else int(dimensions[0] / 5)))\n\n        plt.xticks(x_ticks)\n        plt.yticks(y_ticks)\n\n        # Title\n        plt.title(f'Belief (probability distribution over states)')\n\n        # Actual plot\n        belief_values = self._values if (not gpu_support) or (cp.get_array_module(self._values) == np) else cp.asnumpy(self._values)\n        grid_values = belief_values[model.state_grid]\n        plt.imshow(grid_values,cmap='Blues')\n        plt.colorbar()\n        plt.show()\n</code></pre>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.Belief.bytes_repr","title":"<code>bytes_repr</code>  <code>property</code>","text":"<p>A representation as bytes of a belief.</p>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.Belief.entropy","title":"<code>entropy</code>  <code>property</code>","text":"<p>The entropy of the belief point</p>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.Belief.values","title":"<code>values</code>  <code>property</code>","text":"<p>An array of the probability distribution to be in each state.</p>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.Belief.__eq__","title":"<code>__eq__(other)</code>","text":"<p>A way to check the equality between two belief points. The byte representation of each belief point is compared.</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    '''\n    A way to check the equality between two belief points.\n    The byte representation of each belief point is compared.\n    '''\n    return self.bytes_repr == other.bytes_repr\n</code></pre>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.Belief.generate_successors","title":"<code>generate_successors()</code>","text":"<p>Function to generate a set of belief that can be reached for each actions and observations available in the model.</p> <p>Returns:</p> Name Type Description <code>successor_beliefs</code> <code>list[Belief]</code> <p>The successor beliefs.</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>def generate_successors(self) -&gt; list['Belief']:\n    '''\n    Function to generate a set of belief that can be reached for each actions and observations available in the model.\n\n    Returns\n    -------\n    successor_beliefs : list[Belief]\n        The successor beliefs.\n    '''\n    successor_beliefs = []\n    for a in self.model.actions:\n        for o in self.model.observations:\n            b_ao = self.update(a,o)\n            successor_beliefs.append(b_ao)\n\n    return successor_beliefs\n</code></pre>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.Belief.plot","title":"<code>plot(size=5)</code>","text":"<p>Function to plot a heatmap of the belief distribution if the belief is of a grid model.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>The scale of the plot.</p> <code>5</code> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>def plot(self, size: int = 5) -&gt; None:\n    '''\n    Function to plot a heatmap of the belief distribution if the belief is of a grid model.\n\n    Parameters\n    ----------\n    size : int, default=5\n        The scale of the plot.\n    '''\n    # Plot setup\n    plt.figure(figsize=(size*1.2,size))\n\n    model = self.model.cpu_model\n\n    # Ticks\n    dimensions = model.state_grid.shape\n    x_ticks = np.arange(0, dimensions[1], (1 if dimensions[1] &lt; 10 else int(dimensions[1] / 10)))\n    y_ticks = np.arange(0, dimensions[0], (1 if dimensions[0] &lt; 5 else int(dimensions[0] / 5)))\n\n    plt.xticks(x_ticks)\n    plt.yticks(y_ticks)\n\n    # Title\n    plt.title(f'Belief (probability distribution over states)')\n\n    # Actual plot\n    belief_values = self._values if (not gpu_support) or (cp.get_array_module(self._values) == np) else cp.asnumpy(self._values)\n    grid_values = belief_values[model.state_grid]\n    plt.imshow(grid_values,cmap='Blues')\n    plt.colorbar()\n    plt.show()\n</code></pre>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.Belief.random_state","title":"<code>random_state()</code>","text":"<p>Returns a random state of the model weighted by the belief probabily.</p> <p>Returns:</p> Name Type Description <code>rand_s</code> <code>int</code> <p>A random state.</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>def random_state(self) -&gt; int:\n    '''\n    Returns a random state of the model weighted by the belief probabily.\n\n    Returns\n    -------\n    rand_s : int\n        A random state.\n    '''\n    xp = np if not gpu_support else cp.get_array_module(self._values)\n\n    rand_s = int(self.model.rnd_state.choice(a=self.model.states, size=1, p=self._values)[0])\n    return rand_s\n</code></pre>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.Belief.update","title":"<code>update(a, o, throw_error=True)</code>","text":"<p>Returns a new belief based on this current belief, the most recent action (a) and the most recent observation (o).</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>The most recent action.</p> required <code>o</code> <code>int</code> <p>The most recent observation.</p> required <code>throw_error</code> <code>bool</code> <p>Whether the creation of an impossible belief (sum of probabilities of 0.0) will throw an error or not.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>new_belief</code> <code>Belief</code> <p>An updated belief</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>def update(self,\n           a: int,\n           o: int,\n           throw_error: bool = True\n           ) -&gt; 'Belief':\n    '''\n    Returns a new belief based on this current belief, the most recent action (a) and the most recent observation (o).\n\n    Parameters\n    ----------\n    a : int\n        The most recent action.\n    o : int\n        The most recent observation.\n    throw_error : bool, default=True\n        Whether the creation of an impossible belief (sum of probabilities of 0.0) will throw an error or not.\n\n    Returns\n    -------\n    new_belief : Belief\n        An updated belief\n    '''\n    xp = np if not gpu_support else cp.get_array_module(self._values)\n\n    # Check if successor exists\n    succ_id = f'{a}_{o}'\n    succ = self._successors.get(succ_id)\n    if succ is not None:\n        return succ\n\n    # Computing new probabilities\n    reachable_state_probabilities = self.model.reachable_transitional_observation_table[:,a,o,:] * self.values[:,None]\n    new_state_probabilities = xp.bincount(self.model.reachable_states[:,a,:].flatten(), weights=reachable_state_probabilities.flatten(), minlength=self.model.state_count)\n\n    # Normalization\n    probability_sum = xp.sum(new_state_probabilities)\n    if probability_sum == 0:\n        if throw_error:\n            raise ValueError(\"Impossible belief: the sum of probabilities is 0...\")\n    else:\n        new_state_probabilities /= probability_sum\n\n    # Generation of new belief from new state probabilities\n    new_belief = self.__new__(self.__class__)\n    new_belief.model = self.model\n    new_belief._values = new_state_probabilities\n\n    # Remember generated successor\n    self._successors[succ_id] = new_belief\n\n    return new_belief\n</code></pre>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.BeliefSet","title":"<code>BeliefSet</code>","text":"<p>Class to represent a set of beliefs with regard to a POMDP model. It has the purpose to store the beliefs in a numpy array format and be able to conver it to a list of Belief class objects.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model on which the beliefs apply.</p> required <code>beliefs</code> <code>list[Belief] or ndarray</code> <p>The actual set of beliefs.</p> required <p>Attributes:</p> Name Type Description <code>model</code> <code>Model</code> <code>belief_array</code> <code>ndarray</code> <p>A 2D array of shape N x S of N belief vectors.</p> <code>belief_list</code> <code>list[Belief]</code> <p>A list of N Belief object.</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>class BeliefSet:\n    '''\n    Class to represent a set of beliefs with regard to a POMDP model.\n    It has the purpose to store the beliefs in a numpy array format and be able to conver it to a list of Belief class objects.\n\n\n    Parameters\n    ----------\n    model : pomdp.Model\n        The model on which the beliefs apply.\n    beliefs : list[Belief] or np.ndarray\n        The actual set of beliefs.\n\n    Attributes\n    ----------\n    model : pomdp.Model\n    belief_array : np.ndarray\n        A 2D array of shape N x S of N belief vectors.\n    belief_list : list[Belief]\n        A list of N Belief object.\n    '''\n    def __init__(self,\n                 model: Model,\n                 beliefs: list[Belief] | np.ndarray\n                 ) -&gt; None:\n        self.model = model\n\n        self._belief_list = None\n        self._belief_array = None\n        self._uniqueness_dict = None\n\n        self.is_on_gpu = False\n\n        if isinstance(beliefs, list):\n            assert all(len(b.values) == model.state_count for b in beliefs), f\"Beliefs in belief list provided dont all have shape ({model.state_count},)\"\n            self._belief_list = beliefs\n\n            # Check if on gpu and make sure all beliefs are also on the gpu\n            if (len(beliefs) &gt; 0) and gpu_support and cp.get_array_module(beliefs[0].values) == cp:\n                assert all(cp.get_array_module(b.values) == cp for b in beliefs), \"Either all or none of the alpha vectors should be on the GPU, not just some.\"\n                self.is_on_gpu = True\n        else:\n            assert beliefs.shape[1] == model.state_count, f\"Belief array provided doesnt have the right shape (expected (-,{model.state_count}), received {beliefs.shape})\"\n\n            self._belief_array = beliefs\n\n            # Check if array is on gpu\n            if gpu_support and cp.get_array_module(beliefs) == cp:\n                self.is_on_gpu = True\n\n\n    @property\n    def belief_array(self) -&gt; np.ndarray:\n        '''\n        A matrix of size N x S containing N belief vectors. If belief set is stored as a list of Belief objects, the matrix of beliefs will be generated from them.\n        '''\n        xp = cp if (gpu_support and self.is_on_gpu) else np\n\n        if self._belief_array is None:\n            self._belief_array = xp.array([b.values for b in self._belief_list])\n        return self._belief_array\n\n\n    @property\n    def belief_list(self) -&gt; list[Belief]:\n        '''\n        A list of Belief objects. If the belief set is represented as a matrix of Belief vectors, the list of Belief objects will be generated from it.\n        '''\n        if self._belief_list is None:\n            self._belief_list = [Belief(self.model, belief_vector) for belief_vector in self._belief_array]\n        return self._belief_list\n\n\n    def generate_all_successors(self) -&gt; 'BeliefSet':\n        '''\n        Function to generate the successors beliefs of all the beliefs in the belief set.\n\n        Returns\n        -------\n        all_successors : BeliefSet\n            All successors of all beliefs in the belief set.\n        '''\n        all_successors = []\n        for belief in self.belief_list:\n            all_successors.extend(belief.generate_successors())\n        return BeliefSet(self.model, all_successors)\n\n\n    def update(self,\n               actions: list | np.ndarray,\n               observations: list | np.ndarray,\n               throw_error: bool = True\n               ) -&gt; 'BeliefSet':\n        '''\n        Returns a new belief based on this current belief, the most recent action (a) and the most recent observation (o).\n\n        Parameters\n        ----------\n        actions : list or np.ndarray\n            The most recent played actions.\n        observations : list or np.ndarray\n            The most recent received observations.\n        throw_error : bool, default=True\n            Whether the throw an error when attempting to generate impossible beliefs.\n\n        Returns\n        -------\n        new_belief_set : BeliefSet\n            An set of updated beliefs.\n        '''\n        # GPU support check\n        xp = cp if (gpu_support and self.is_on_gpu) else np\n\n        # Ensuring we are dealing we are dealing with ndarrays\n        observations = xp.array(observations)\n        actions = xp.array(actions)\n\n        # Computing reachable probabilities and states\n        reachable_probabilities = (self.model.reachable_transitional_observation_table[:, actions, observations, :] * self.belief_array.T[:,:,None])\n        reachable_state_per_actions = self.model.reachable_states[:, actions, :]\n\n        # Computing new probabilities\n        flatten_offset = xp.arange(len(observations))[:,None] * self.model.state_count\n        flat_shape = (len(observations), (self.model.state_count * self.model.reachable_state_count))\n\n        a = reachable_state_per_actions.swapaxes(0,1).reshape(flat_shape)\n        w = reachable_probabilities.swapaxes(0,1).reshape(flat_shape)\n\n        a_offs = a + flatten_offset\n        new_probabilities = xp.bincount(a_offs.ravel(), weights=w.ravel(), minlength=a.shape[0]*self.model.state_count).reshape((-1,self.model.state_count))\n\n        # Normalization\n        probability_sum = xp.sum(new_probabilities, axis=1)\n        if xp.any(probability_sum == 0.0) and throw_error:\n            raise ValueError('One or more belief is impossible, (ie the sum of the probability distribution is 0)')\n        non_zero_mask = probability_sum != 0\n        new_probabilities[non_zero_mask] /= probability_sum[non_zero_mask,None]\n\n        return BeliefSet(self.model, new_probabilities)\n\n\n    @property\n    def unique_belief_dict(self) -&gt; dict:\n        '''\n        A dictionary of unique belief points with the keys being the byte representation of these belief points.\n        '''\n        if self._uniqueness_dict is None:\n            self._uniqueness_dict = {belief.bytes_repr: belief for belief in self.belief_list}\n        return self._uniqueness_dict\n\n\n    def union(self, other_belief_set: 'BeliefSet') -&gt; 'BeliefSet':\n        '''\n        Function to make the union between two belief set objects.\n\n        Parameters\n        ----------\n        other_belief_set : BeliefSet\n            The other belief set to make the union with\n\n        Returns\n        -------\n        new_belief_set : BeliefSet\n            A new, combined, belief set\n        '''\n        # Deduplication\n        combined_uniqueness_dict = self.unique_belief_dict | other_belief_set.unique_belief_dict\n\n        # Generation of new set\n        new_belief_set = BeliefSet(self.model, list(combined_uniqueness_dict.values()))\n        new_belief_set._uniqueness_dict = combined_uniqueness_dict\n\n        return new_belief_set\n\n\n    def __len__(self) -&gt; int:\n        return len(self._belief_list) if self._belief_list is not None else self._belief_array.shape[0]\n\n\n    @property\n    def entropies(self) -&gt; np.ndarray:\n        '''\n        An array of the entropies of the belief points.\n        '''\n        xp = np if not gpu_support else cp.get_array_module(self.belief_array)\n\n        return entropy(self.belief_array, axis=1) if xp == np else cupy_entropy(self.belief_array, axis=1)\n\n\n    def to_gpu(self) -&gt; 'BeliefSet':\n        '''\n        Function returning an equivalent belief set object with the array of values stored on GPU instead of CPU.\n\n        Returns\n        -------\n        gpu_belief_set : BeliefSet\n            A new belief set with array on GPU.\n        '''\n        assert gpu_support, \"GPU support is not enabled, unable to execute this function\"\n\n        gpu_model = self.model.gpu_model\n\n        gpu_belief_set = None\n        if self._belief_array is not None:\n            gpu_belief_array = cp.array(self._belief_array)\n            gpu_belief_set = BeliefSet(gpu_model, gpu_belief_array)\n        else:\n            gpu_belief_list = [Belief(gpu_model, cp.array(b.values)) for b in self._belief_list]\n            gpu_belief_set = BeliefSet(gpu_model, gpu_belief_list)\n\n        return gpu_belief_set\n\n\n    def to_cpu(self) -&gt; 'BeliefSet':\n        '''\n        Function returning an equivalent belief set object with the array of values stored on CPU instead of GPU.\n\n        Returns\n        -------\n        cpu_belief_set : BeliefSet\n            A new belief set with array on CPU.\n        '''\n        assert gpu_support, \"GPU support is not enabled, unable to execute this function\"\n\n        cpu_model = self.model.cpu_model\n\n        cpu_belief_set = None\n        if self._belief_array is not None:\n            cpu_belief_array = cp.asnumpy(self._belief_array)\n            cpu_belief_set = BeliefSet(cpu_model, cpu_belief_array)\n\n        else:\n            cpu_belief_list = [Belief(cpu_model, cp.asnumpy(b.values)) for b in self._belief_list]\n            cpu_belief_set = BeliefSet(cpu_model, cpu_belief_list)\n\n        return cpu_belief_set\n</code></pre>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.BeliefSet.belief_array","title":"<code>belief_array</code>  <code>property</code>","text":"<p>A matrix of size N x S containing N belief vectors. If belief set is stored as a list of Belief objects, the matrix of beliefs will be generated from them.</p>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.BeliefSet.belief_list","title":"<code>belief_list</code>  <code>property</code>","text":"<p>A list of Belief objects. If the belief set is represented as a matrix of Belief vectors, the list of Belief objects will be generated from it.</p>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.BeliefSet.entropies","title":"<code>entropies</code>  <code>property</code>","text":"<p>An array of the entropies of the belief points.</p>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.BeliefSet.unique_belief_dict","title":"<code>unique_belief_dict</code>  <code>property</code>","text":"<p>A dictionary of unique belief points with the keys being the byte representation of these belief points.</p>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.BeliefSet.generate_all_successors","title":"<code>generate_all_successors()</code>","text":"<p>Function to generate the successors beliefs of all the beliefs in the belief set.</p> <p>Returns:</p> Name Type Description <code>all_successors</code> <code>BeliefSet</code> <p>All successors of all beliefs in the belief set.</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>def generate_all_successors(self) -&gt; 'BeliefSet':\n    '''\n    Function to generate the successors beliefs of all the beliefs in the belief set.\n\n    Returns\n    -------\n    all_successors : BeliefSet\n        All successors of all beliefs in the belief set.\n    '''\n    all_successors = []\n    for belief in self.belief_list:\n        all_successors.extend(belief.generate_successors())\n    return BeliefSet(self.model, all_successors)\n</code></pre>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.BeliefSet.to_cpu","title":"<code>to_cpu()</code>","text":"<p>Function returning an equivalent belief set object with the array of values stored on CPU instead of GPU.</p> <p>Returns:</p> Name Type Description <code>cpu_belief_set</code> <code>BeliefSet</code> <p>A new belief set with array on CPU.</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>def to_cpu(self) -&gt; 'BeliefSet':\n    '''\n    Function returning an equivalent belief set object with the array of values stored on CPU instead of GPU.\n\n    Returns\n    -------\n    cpu_belief_set : BeliefSet\n        A new belief set with array on CPU.\n    '''\n    assert gpu_support, \"GPU support is not enabled, unable to execute this function\"\n\n    cpu_model = self.model.cpu_model\n\n    cpu_belief_set = None\n    if self._belief_array is not None:\n        cpu_belief_array = cp.asnumpy(self._belief_array)\n        cpu_belief_set = BeliefSet(cpu_model, cpu_belief_array)\n\n    else:\n        cpu_belief_list = [Belief(cpu_model, cp.asnumpy(b.values)) for b in self._belief_list]\n        cpu_belief_set = BeliefSet(cpu_model, cpu_belief_list)\n\n    return cpu_belief_set\n</code></pre>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.BeliefSet.to_gpu","title":"<code>to_gpu()</code>","text":"<p>Function returning an equivalent belief set object with the array of values stored on GPU instead of CPU.</p> <p>Returns:</p> Name Type Description <code>gpu_belief_set</code> <code>BeliefSet</code> <p>A new belief set with array on GPU.</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>def to_gpu(self) -&gt; 'BeliefSet':\n    '''\n    Function returning an equivalent belief set object with the array of values stored on GPU instead of CPU.\n\n    Returns\n    -------\n    gpu_belief_set : BeliefSet\n        A new belief set with array on GPU.\n    '''\n    assert gpu_support, \"GPU support is not enabled, unable to execute this function\"\n\n    gpu_model = self.model.gpu_model\n\n    gpu_belief_set = None\n    if self._belief_array is not None:\n        gpu_belief_array = cp.array(self._belief_array)\n        gpu_belief_set = BeliefSet(gpu_model, gpu_belief_array)\n    else:\n        gpu_belief_list = [Belief(gpu_model, cp.array(b.values)) for b in self._belief_list]\n        gpu_belief_set = BeliefSet(gpu_model, gpu_belief_list)\n\n    return gpu_belief_set\n</code></pre>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.BeliefSet.union","title":"<code>union(other_belief_set)</code>","text":"<p>Function to make the union between two belief set objects.</p> <p>Parameters:</p> Name Type Description Default <code>other_belief_set</code> <code>BeliefSet</code> <p>The other belief set to make the union with</p> required <p>Returns:</p> Name Type Description <code>new_belief_set</code> <code>BeliefSet</code> <p>A new, combined, belief set</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>def union(self, other_belief_set: 'BeliefSet') -&gt; 'BeliefSet':\n    '''\n    Function to make the union between two belief set objects.\n\n    Parameters\n    ----------\n    other_belief_set : BeliefSet\n        The other belief set to make the union with\n\n    Returns\n    -------\n    new_belief_set : BeliefSet\n        A new, combined, belief set\n    '''\n    # Deduplication\n    combined_uniqueness_dict = self.unique_belief_dict | other_belief_set.unique_belief_dict\n\n    # Generation of new set\n    new_belief_set = BeliefSet(self.model, list(combined_uniqueness_dict.values()))\n    new_belief_set._uniqueness_dict = combined_uniqueness_dict\n\n    return new_belief_set\n</code></pre>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.BeliefSet.update","title":"<code>update(actions, observations, throw_error=True)</code>","text":"<p>Returns a new belief based on this current belief, the most recent action (a) and the most recent observation (o).</p> <p>Parameters:</p> Name Type Description Default <code>actions</code> <code>list or ndarray</code> <p>The most recent played actions.</p> required <code>observations</code> <code>list or ndarray</code> <p>The most recent received observations.</p> required <code>throw_error</code> <code>bool</code> <p>Whether the throw an error when attempting to generate impossible beliefs.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>new_belief_set</code> <code>BeliefSet</code> <p>An set of updated beliefs.</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>def update(self,\n           actions: list | np.ndarray,\n           observations: list | np.ndarray,\n           throw_error: bool = True\n           ) -&gt; 'BeliefSet':\n    '''\n    Returns a new belief based on this current belief, the most recent action (a) and the most recent observation (o).\n\n    Parameters\n    ----------\n    actions : list or np.ndarray\n        The most recent played actions.\n    observations : list or np.ndarray\n        The most recent received observations.\n    throw_error : bool, default=True\n        Whether the throw an error when attempting to generate impossible beliefs.\n\n    Returns\n    -------\n    new_belief_set : BeliefSet\n        An set of updated beliefs.\n    '''\n    # GPU support check\n    xp = cp if (gpu_support and self.is_on_gpu) else np\n\n    # Ensuring we are dealing we are dealing with ndarrays\n    observations = xp.array(observations)\n    actions = xp.array(actions)\n\n    # Computing reachable probabilities and states\n    reachable_probabilities = (self.model.reachable_transitional_observation_table[:, actions, observations, :] * self.belief_array.T[:,:,None])\n    reachable_state_per_actions = self.model.reachable_states[:, actions, :]\n\n    # Computing new probabilities\n    flatten_offset = xp.arange(len(observations))[:,None] * self.model.state_count\n    flat_shape = (len(observations), (self.model.state_count * self.model.reachable_state_count))\n\n    a = reachable_state_per_actions.swapaxes(0,1).reshape(flat_shape)\n    w = reachable_probabilities.swapaxes(0,1).reshape(flat_shape)\n\n    a_offs = a + flatten_offset\n    new_probabilities = xp.bincount(a_offs.ravel(), weights=w.ravel(), minlength=a.shape[0]*self.model.state_count).reshape((-1,self.model.state_count))\n\n    # Normalization\n    probability_sum = xp.sum(new_probabilities, axis=1)\n    if xp.any(probability_sum == 0.0) and throw_error:\n        raise ValueError('One or more belief is impossible, (ie the sum of the probability distribution is 0)')\n    non_zero_mask = probability_sum != 0\n    new_probabilities[non_zero_mask] /= probability_sum[non_zero_mask,None]\n\n    return BeliefSet(self.model, new_probabilities)\n</code></pre>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.ValueFunction","title":"<code>ValueFunction</code>","text":"<p>Class representing a set of AlphaVectors. One such set approximates the value function of the MDP model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model the value function is associated with.</p> required <code>alpha_vectors</code> <code>list[AlphaVector] or ndarray</code> <p>The alpha vectors composing the value function, if none are provided, it will be empty to start with and AlphaVectors can be appended.</p> <code>[]</code> <code>action_list</code> <code>list[int] or ndarray</code> <p>The actions associated with alpha vectors in the case the alpha vectors are provided as an numpy array.</p> <code>[]</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>Model</code> <p>The model the value function is associated with.</p> <code>alpha_vector_list</code> <code>list[AlphaVector]</code> <code>alpha_vector_array</code> <code>ndarray</code> <code>actions</code> <code>ndarray</code> Source code in <code>olfactory_navigation/agents/model_based_util/value_function.py</code> <pre><code>class ValueFunction:\n    '''\n    Class representing a set of AlphaVectors. One such set approximates the value function of the MDP model.\n\n\n    Parameters\n    ----------\n    model : mdp.Model\n        The model the value function is associated with.\n    alpha_vectors : list[AlphaVector] or np.ndarray, optional\n        The alpha vectors composing the value function, if none are provided, it will be empty to start with and AlphaVectors can be appended.\n    action_list : list[int] or np.ndarray, optional\n        The actions associated with alpha vectors in the case the alpha vectors are provided as an numpy array.\n\n    Attributes\n    ----------\n    model : mdp.Model\n        The model the value function is associated with.\n    alpha_vector_list : list[AlphaVector]\n    alpha_vector_array : np.ndarray\n    actions : np.ndarray\n    '''\n    def __init__(self,\n                 model: Model,\n                 alpha_vectors: list[AlphaVector] | np.ndarray = [],\n                 action_list: list[int] | np.ndarray = []\n                 ) -&gt; None:\n        self.model = model\n\n        self._vector_list = None\n        self._vector_array = None\n        self._actions = None\n\n        self.is_on_gpu = False\n\n        # List of alpha vectors\n        if isinstance(alpha_vectors, list):\n            assert all(v.values.shape[0] == model.state_count for v in alpha_vectors), f\"Some or all alpha vectors in the list provided dont have the right size, they should be of shape: {model.state_count}\"\n            self._vector_list = alpha_vectors\n\n            # Check if on gpu and make sure all vectors are also on the gpu\n            if (len(alpha_vectors) &gt; 0) and gpu_support and cp.get_array_module(alpha_vectors[0].values) == cp:\n                assert all(cp.get_array_module(v.values) == cp for v in alpha_vectors), \"Either all or none of the alpha vectors should be on the GPU, not just some.\"\n                self.is_on_gpu = True\n\n        # As numpy array\n        else:\n            av_shape = alpha_vectors.shape\n            exp_shape = (len(action_list), model.state_count)\n            assert av_shape == exp_shape, f\"Alpha vector array does not have the right shape (received: {av_shape}; expected: {exp_shape})\"\n\n            self._vector_list = []\n            for alpha_vect, action in zip(alpha_vectors, action_list):\n                self._vector_list.append(AlphaVector(alpha_vect, action))\n\n            # Check if array is on gpu\n            if gpu_support and cp.get_array_module(alpha_vectors) == cp:\n                self.is_on_gpu = True\n\n        # Deduplication\n        self._uniqueness_dict = {alpha_vector.values.tobytes(): alpha_vector for alpha_vector in self._vector_list}\n        self._vector_list = list(self._uniqueness_dict.values())\n\n        self._pruning_level = 1\n\n\n    @property\n    def alpha_vector_list(self) -&gt; list[AlphaVector]:\n        '''\n        A list of AlphaVector objects. If the value function is defined as an matrix of vectors and a list of actions, the list of AlphaVectors will be generated from them.\n        '''\n        if self._vector_list is None:\n            self._vector_list = []\n            for alpha_vect, action in zip(self._vector_array, self._actions):\n                self._vector_list.append(AlphaVector(alpha_vect, action))\n        return self._vector_list\n\n\n    @property\n    def alpha_vector_array(self) -&gt; np.ndarray:\n        '''\n        A matrix of size N x S, containing all the alpha vectors making up the value function. (N is the number of alpha vectors and S the amount of states in the model)\n        If the value function is defined as a list of AlphaVector objects, the matrix will the generated from them.\n        '''\n        xp = cp if (gpu_support and self.is_on_gpu) else np\n\n        if self._vector_array is None:\n            self._vector_array = xp.array([v.values for v in self._vector_list])\n            self._actions = xp.array([v.action for v in self._vector_list])\n        return self._vector_array\n\n\n    @property\n    def actions(self) -&gt; np.ndarray:\n        '''\n        A list of N actions corresponding to the N alpha vectors making up the value function.\n        If the value function is defined as a list of AlphaVector objects, the list will the generated from the actions of those alpha vector objects.\n        '''\n        xp = cp if (gpu_support and self.is_on_gpu) else np\n\n        if self._actions is None:\n            self._vector_array = xp.array(self._vector_list)\n            self._actions = xp.array([v.action for v in self._vector_list])\n        return self._actions\n\n\n    def __len__(self) -&gt; int:\n        return len(self._vector_list) if self._vector_list is not None else self._vector_array.shape[0]\n\n\n    def __add__(self, other_value_function: 'Model') -&gt; 'Model':\n        # combined_dict = {**self._uniqueness_dict, **other_value_function._uniqueness_dict}\n        combined_dict = {}\n        combined_dict.update(self._uniqueness_dict)\n        combined_dict.update(other_value_function._uniqueness_dict)\n\n        # Instantiation of the new value function\n        new_value_function = super().__new__(self.__class__)\n        new_value_function.model = self.model\n        new_value_function.is_on_gpu = self.is_on_gpu\n\n        new_value_function._vector_list = list(combined_dict.values())\n        new_value_function._uniqueness_dict = combined_dict\n        new_value_function._pruning_level = 1\n\n        new_value_function._vector_array = None\n        new_value_function._actions = None\n\n        return new_value_function\n\n\n    def append(self,\n               alpha_vector: AlphaVector\n               ) -&gt; None:\n        '''\n        Function to add an alpha vector to the value function.\n\n        Parameters\n        ----------\n        alpha_vector : AlphaVector\n            The alpha vector to be added to the value function.\n        '''\n        # Make sure size is correct\n        assert alpha_vector.values.shape[0] == self.model.state_count, f\"Vector to add to value function doesn't have the right size (received: {alpha_vector.values.shape[0]}, expected: {self.model.state_count})\"\n\n        # GPU support check\n        xp = cp if (gpu_support and self.is_on_gpu) else np\n        assert gpu_support and cp.get_array_module(alpha_vector.values) == xp, f\"Vector is{' not' if self.is_on_gpu else ''} on GPU while value function is{'' if self.is_on_gpu else ' not'}.\"\n\n        if self._vector_array is not None:\n            self._vector_array = xp.append(self._vector_array, alpha_vector[None,:], axis=0)\n            self._actions = xp.append(self._actions, alpha_vector.action)\n\n        if self._vector_list is not None:\n            self._vector_list.append(alpha_vector)\n\n\n    def extend(self,\n               other_value_function: 'Model'\n               ) -&gt; None:\n        '''\n        Function to add another value function is place.\n        Effectively, it performs the union of the two sets of alpha vectors.\n\n        Parameters\n        ----------\n        other_value_function : ValueFunction\n            The other side of the union.\n        '''\n        self._uniqueness_dict.update(other_value_function._uniqueness_dict)\n        self._vector_list = list(self._uniqueness_dict.values())\n\n        self._vector_array = None\n        self._actions = None\n\n        self._pruning_level = 1\n\n\n    def to_gpu(self) -&gt; 'ValueFunction':\n        '''\n        Function returning an equivalent value function object with the arrays stored on GPU instead of CPU.\n\n        Returns\n        -------\n        gpu_value_function : ValueFunction\n            A new value function with arrays on GPU.\n        '''\n        assert gpu_support, \"GPU support is not enabled, unable to execute this function\"\n\n        gpu_model = self.model.gpu_model\n\n        gpu_value_function = None\n        if self._vector_list is not None:\n            gpu_alpha_vectors = [AlphaVector(cp.array(av.values), av.action) for av in self._vector_list]\n            gpu_value_function = ValueFunction(gpu_model, gpu_alpha_vectors)\n\n        else:\n            gpu_vector_array = cp.array(self._vector_array)\n            gpu_actions = self._actions if isinstance(self._actions, list) else cp.array(self._actions)\n            gpu_value_function = ValueFunction(gpu_model, gpu_vector_array, gpu_actions)\n\n        return gpu_value_function\n\n\n    def to_cpu(self) -&gt; 'ValueFunction':\n        '''\n        Function returning an equivalent value function object with the arrays stored on CPU instead of GPU.\n\n        Returns\n        -------\n        cpu_value_function : ValueFunction\n            A new value function with arrays on CPU.\n        '''\n        assert gpu_support, \"GPU support is not enabled, unable to execute this function\"\n\n        cpu_model = self.model.cpu_model\n\n        cpu_value_function = None\n        if self._vector_list is not None:\n            cpu_alpha_vectors = [AlphaVector(cp.asnumpy(av.values), av.action) for av in self._vector_list]\n            cpu_value_function = ValueFunction(cpu_model, cpu_alpha_vectors)\n\n        else:\n            cpu_vector_array = cp.asnumpy(self._vector_array)\n            cpu_actions = self._actions if isinstance(self._actions, list) else cp.asnumpy(self._actions)\n            cpu_value_function = ValueFunction(cpu_model, cpu_vector_array, cpu_actions)\n\n        return cpu_value_function\n\n\n    def prune(self,\n              level: int = 1\n              ) -&gt; None:\n        '''\n        Function pruning the set of alpha vectors composing the value function.\n        The pruning is as thorough as the level:\n            - 2: 1+ Check of absolute domination (check if dominated at each state).\n            - 3: 2+ Solves Linear Programming problem for each alpha vector to see if it is dominated by combinations of other vectors.\n\n        Note that the higher the level, the heavier the time impact will be.\n\n        Parameters\n        ----------\n        level : int, default=1\n            Between 0 and 3, how thorough the alpha vector pruning should be.\n        '''\n        # GPU support check\n        xp = cp if (gpu_support and self.is_on_gpu) else np\n\n        # Level 1 or under\n        if level &lt; self._pruning_level or level &gt; 3:\n            log('Attempting to prune a value function to a level already reached. Returning \\'self\\'')\n            return\n\n        # Level 2 pruning: Check for absolute domination\n        if level &gt;= 2 and self._pruning_level &lt; 2:\n            non_dominated_vector_indices = []\n\n            for i, v in enumerate(self.alpha_vector_array):\n                is_dom_by = xp.all(self.alpha_vector_array &gt;= v, axis=1)\n                if len(xp.where(is_dom_by)[0]) == 1:\n                    non_dominated_vector_indices.append(i)\n\n            self._vector_array = self._vector_array[non_dominated_vector_indices]\n            self._actions = self._actions[non_dominated_vector_indices]\n\n        # Level 3 pruning: LP to check for more complex domination\n        if level &gt;= 3:\n            assert ilp_support, \"ILP support not enabled...\"\n\n            pruned_alpha_set = pruned_alpha_set.to_cpu()\n\n            alpha_set = pruned_alpha_set.alpha_vector_array\n            non_dominated_vector_indices = []\n\n            for i, alpha_vect in enumerate(alpha_set):\n                other_alphas = alpha_set[:i] + alpha_set[(i+1):]\n\n                # Objective function\n                c = np.concatenate([np.array([1]), -1*alpha_vect])\n\n                # Alpha vector contraints\n                other_count = len(other_alphas)\n                A = np.c_[np.ones(other_count), np.multiply(np.array(other_alphas), -1)]\n                alpha_constraints = LinearConstraint(A, 0, np.inf)\n\n                # Constraints that sum of beliefs is 1\n                belief_constraint = LinearConstraint(np.array([0] + ([1]*self.model.state_count)), 1, 1)\n\n                # Solve problem\n                res = milp(c=c, constraints=[alpha_constraints, belief_constraint])\n\n                # Check if dominated\n                is_dominated = (res.x[0] - np.dot(res.x[1:], alpha_vect)) &gt;= 0\n                if is_dominated:\n                    print(alpha_vect)\n                    print(' -&gt; Dominated\\n')\n                else:\n                    non_dominated_vector_indices.append(i)\n\n            self._vector_array = self._vector_array[non_dominated_vector_indices]\n            self._actions = self._actions[non_dominated_vector_indices]\n\n        # Update the tracked pruned level so far\n        self._pruning_level = level\n\n\n    def evaluate_at(self,\n                    belief: Belief | BeliefSet\n                    ) -&gt; tuple[float | np.ndarray, int | np.ndarray]:\n        '''\n        Function to evaluate the value function at a belief point or at a set of belief points.\n        It returns a value and the associated action.\n\n        Parameters\n        ----------\n        belief : Belief or BeliefSet\n\n        Returns\n        -------\n        value : float or np.ndarray\n            The largest value associated with the belief point(s)\n        action : int or np.ndarray\n            The action(s) associated with the vector having the highest values at the belief point(s).\n        '''\n        # GPU support check\n        xp = cp if (gpu_support and self.is_on_gpu) else np\n\n        best_value = None\n        best_action = None\n\n        if isinstance(belief, Belief):\n            # Computing values\n            belief_values = xp.dot(self.alpha_vector_array, belief.values)\n\n            # Selecting best vectors\n            best_vector = xp.argmax(belief_values)\n\n            # From best vector, compute the best value and action\n            best_value = float(belief_values[best_vector])\n            best_action = int(self.actions[best_vector])\n        else:\n            # Computing values\n            belief_values = xp.matmul(belief.values if isinstance(belief, Belief) else belief.belief_array, self.alpha_vector_array.T)\n\n            # Retrieving the top vectors according to the value function\n            best_vectors = xp.argmax(belief_values, axis=1)\n\n            # Retrieving the values and actions associated with the vectors chosen\n            best_value = belief_values[xp.arange(belief_values.shape[0]), best_vectors]\n            best_action = self.actions[best_vectors]\n\n        return (best_value, best_action)\n\n\n    def save(self,\n             folder: str = './ValueFunctions',\n             file_name: str | None = None\n             ) -&gt; None:\n        '''\n        Function to save the value function in a file at a given path. If no path is provided, it will be saved in a subfolder (ValueFunctions) inside the current working directory.\n        If no file_name is provided, it be saved as '&lt;current_timestamp&gt;_value_function.csv'.\n\n        Parameters\n        ----------\n        folder : str, default='./ValueFunctions'\n            The path at which the npy file will be saved.\n        file_name : str, default='&lt;current_timestamp&gt;_value_function.npy'\n            The file name used to save in.\n        '''\n        if self.is_on_gpu:\n            self.to_cpu().save(path=folder, file_name=file_name)\n            return\n\n        # Handle file_name\n        if file_name is None:\n            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n            file_name = timestamp + '_value_function.npy'\n\n        # Make sure that .csv is in the file name\n        if '.npy' not in file_name:\n            file_name += '.npy'\n\n        # Getting array\n        av_array = np.hstack([self.actions[:,None], self.alpha_vector_array])\n\n        np.save(folder + '/' + file_name, av_array)\n\n\n    @classmethod\n    def load(cls,\n             file: str,\n             model: Model\n             ) -&gt; 'ValueFunction':\n        '''\n        Function to load the value function from a csv file.\n\n        Parameters\n        ----------\n        file : str\n            The path and file_name of the value function to be loaded.\n        model : mdp.Model\n            The model the value function is linked to.\n\n        Returns\n        -------\n        loaded_value_function : ValueFunction\n            The loaded value function.\n        '''\n        av_array = np.load(file)\n\n        loaded_value_function = ValueFunction(model=model,\n                                              alpha_vectors=av_array[:,1:],\n                                              action_list=av_array[:,0].astype(int))\n\n        return loaded_value_function\n\n\n    def plot(self,\n             as_grid: bool = False,\n             size: int = 5,\n             belief_set: np.ndarray = None\n             ) -&gt; None:\n        '''\n        Function to plot out the value function in 2 or 3 dimensions if possible and the as_grid parameter is kept to false. Else, the value function is plot as a grid.\n        If a belief set array is provided and the model is a 2- or 3-model, it will be plot alongside the value function.\n\n        Parameters\n        ----------\n        as_grid : bool, default=False\n            Forces the plot to be plot as a grid.\n        size : int, default=5\n            The actual plot scale.\n        belief_set : np.ndarray, optional\n            A set of belief to plot the belief points that were explored.\n        '''\n        assert len(self) &gt; 0, \"Value function is empty, plotting is impossible...\"\n\n        # If on GPU, convert to CPU and plot that one\n        if self.is_on_gpu:\n            print('[Warning] Value function on GPU, converting to numpy before plotting...')\n            cpu_value_function = self.to_cpu()\n            cpu_value_function.plot(as_grid, size, belief_set)\n            return\n\n        func = None\n        if as_grid:\n            func = self._plot_grid\n        elif self.model.state_count == 2:\n            func = self._plot_2D\n        elif self.model.state_count == 3:\n            func = self._plot_3D\n        else:\n            print('[Warning] \\'as_grid\\' parameter set to False but state count is &gt;3 so it will be plotted as a grid')\n            func = self._plot_grid\n\n        func(size, belief_set)\n\n\n    def _plot_2D(self, size, belief_set=None):\n        x = np.linspace(0, 1, 100)\n\n        plt.figure(figsize=(int(size*1.5),size))\n        grid_spec = {'height_ratios': ([1] if belief_set is None else [19,1])}\n        _, ax = plt.subplots((2 if belief_set is not None else 1),1,sharex=True,gridspec_kw=grid_spec)\n\n        # Vector plotting\n        alpha_vects = self.alpha_vector_array\n\n        m = alpha_vects[:,1] - alpha_vects[:,0] # type: ignore\n        m = m.reshape(m.shape[0],1)\n\n        x = x.reshape((1,x.shape[0])).repeat(m.shape[0],axis=0)\n        y = (m*x) + alpha_vects[:,0].reshape(m.shape[0],1)\n\n        ax0 = ax[0] if belief_set is not None else ax\n        for i, alpha in enumerate(self.alpha_vector_list):\n            ax0.plot(x[i,:], y[i,:], color=COLOR_LIST[alpha.action]['id']) # type: ignore\n\n        # Set title\n        title = 'Value function' + ('' if belief_set is None else ' and explored belief points')\n        ax0.set_title(title)\n\n        # X-axis setting\n        ticks = [0,0.25,0.5,0.75,1]\n        x_ticks = [str(t) for t in ticks]\n        x_ticks[0] = self.model.state_labels[0]\n        x_ticks[-1] = self.model.state_labels[1]\n\n        ax0.set_xticks(ticks, x_ticks) # type: ignore\n\n        # Action legend\n        proxy = [patches.Rectangle((0,0),1,1,fc = COLOR_LIST[a]['id']) for a in self.model.actions]\n        ax0.legend(proxy, self.model.action_labels, title='Actions') # type: ignore\n\n        # Belief plotting\n        if belief_set is not None:\n            beliefs_x = belief_set.belief_array[:,1]\n            ax[1].scatter(beliefs_x, np.zeros(beliefs_x.shape[0]), c='red')\n            ax[1].get_yaxis().set_visible(False)\n            ax[1].axhline(0, color='black')\n            ax[1].set_xlabel('Belief space')\n        else:\n            ax0.set_xlabel('Belief space')\n\n        # Axis labels\n        ax0.set_ylabel('V(b)')\n\n\n    def _plot_3D(self, size, belief_set=None):\n\n        def get_alpha_vect_z(xx, yy, alpha_vect):\n            x0, y0, z0 = [0, 0, alpha_vect[0]]\n            x1, y1, z1 = [1, 0, alpha_vect[1]]\n            x2, y2, z2 = [0, 1, alpha_vect[2]]\n\n            ux, uy, uz = u = [x1-x0, y1-y0, z1-z0]\n            vx, vy, vz = v = [x2-x0, y2-y0, z2-z0]\n\n            u_cross_v = [uy*vz-uz*vy, uz*vx-ux*vz, ux*vy-uy*vx]\n\n            point  = np.array([0, 0, alpha_vect[0]])\n            normal = np.array(u_cross_v)\n\n            d = -point.dot(normal)\n\n            z = (-normal[0] * xx - normal[1] * yy - d) * 1. / normal[2]\n\n            return z\n\n        def get_plane_gradient(alpha_vect):\n\n            x0, y0, z0 = [0, 0, alpha_vect[0]]\n            x1, y1, z1 = [1, 0, alpha_vect[1]]\n            x2, y2, z2 = [0, 1, alpha_vect[2]]\n\n            ux, uy, uz = u = [x1-x0, y1-y0, z1-z0]\n            vx, vy, vz = v = [x2-x0, y2-y0, z2-z0]\n\n            u_cross_v = [uy*vz-uz*vy, uz*vx-ux*vz, ux*vy-uy*vx]\n\n            normal_vector = np.array(u_cross_v)\n            normal_vector_norm = float(np.linalg.norm(normal_vector))\n            normal_vector = np.divide(normal_vector, normal_vector_norm)\n            normal_vector[2] = 0\n\n            return np.linalg.norm(normal_vector)\n\n        # Actual plotting\n        x = np.linspace(0, 1, 1000)\n        y = np.linspace(0, 1, 1000)\n\n        xx, yy = np.meshgrid(x, y)\n\n        max_z = np.zeros((xx.shape[0], yy.shape[0]))\n        best_a = (np.zeros((xx.shape[0], yy.shape[0])))\n        plane = (np.zeros((xx.shape[0], yy.shape[0])))\n        gradients = (np.zeros((xx.shape[0], yy.shape[0])))\n\n        for alpha in self.alpha_vector_list:\n\n            z = get_alpha_vect_z(xx, yy, alpha.values)\n\n            # Action array update\n            new_a_mask = np.argmax(np.array([max_z, z]), axis=0)\n\n            best_a[new_a_mask == 1] = alpha.action\n\n            plane[new_a_mask == 1] = random.randrange(100)\n\n            alpha_gradient = get_plane_gradient(alpha.values)\n            gradients[new_a_mask == 1] = alpha_gradient\n\n            # Max z update\n            max_z = np.max(np.array([max_z, z]), axis=0)\n\n        for x_i, x_val in enumerate(x):\n            for y_i, y_val in enumerate(y):\n                if (x_val+y_val) &gt; 1:\n                    max_z[x_i, y_i] = np.nan\n                    plane[x_i, y_i] = np.nan\n                    gradients[x_i, y_i] = np.nan\n                    best_a[x_i, y_i] = np.nan\n\n        belief_points = None\n        if belief_set is not None:\n            belief_points = belief_set.belief_array[:,1:]\n\n        fig, ((ax1, ax2),(ax3,ax4)) = plt.subplots(2, 2, figsize=(size*4,size*3.5), sharex=True, sharey=True)\n\n        # Set ticks\n        ticks = [0,0.25,0.5,0.75,1]\n        x_ticks = [str(t) for t in ticks]\n        x_ticks[0] = self.model.state_labels[0]\n        x_ticks[-1] = self.model.state_labels[1]\n\n        y_ticks = [str(t) for t in ticks]\n        y_ticks[0] = self.model.state_labels[0]\n        y_ticks[-1] = self.model.state_labels[2]\n\n        plt.setp([ax1,ax2,ax3,ax4], xticks=ticks, xticklabels=x_ticks, yticks=ticks, yticklabels=y_ticks)\n\n        # Value function ax\n        ax1.set_title(\"Value function\")\n        ax1_plot = ax1.contourf(x, y, max_z, 100, cmap=\"viridis\")\n        plt.colorbar(ax1_plot, ax=ax1)\n\n        # Alpha planes ax\n        ax2.set_title(\"Alpha planes\")\n        ax2_plot = ax2.contourf(x, y, plane, 100, cmap=\"viridis\")\n        plt.colorbar(ax2_plot, ax=ax2)\n\n        # Gradient of planes ax\n        ax3.set_title(\"Gradients of planes\")\n        ax3_plot = ax3.contourf(x, y, gradients, 100, cmap=\"Blues\")\n        plt.colorbar(ax3_plot, ax=ax3)\n\n        # Action policy ax\n        ax4.set_title(\"Action policy\")\n        ax4.contourf(x, y, best_a, 1, colors=[c['id'] for c in COLOR_LIST])\n        proxy = [patches.Rectangle((0,0),1,1,fc = COLOR_LIST[int(a)]['id']) for a in self.model.actions]\n        ax4.legend(proxy, self.model.action_labels, title='Actions')\n\n        if belief_points is not None:\n            for ax in [ax1,ax2,ax3,ax4]:\n                ax.scatter(belief_points[:,0], belief_points[:,1], s=1, c='black')\n\n\n    def _plot_grid(self, size=5, belief_set=None):\n        value_table = np.max(self.alpha_vector_array, axis=0)[self.model.state_grid]\n        best_action_table = np.array(self.actions)[np.argmax(self.alpha_vector_array, axis=0)][self.model.state_grid]\n        best_action_colors = COLOR_ARRAY[best_action_table]\n\n        dimensions = self.model.state_grid.shape\n\n        fig, (ax1,ax2) = plt.subplots(1,2, figsize=(size*2, size), width_ratios=(0.55,0.45))\n\n        # Ticks\n        x_ticks = np.arange(0, dimensions[1], (1 if dimensions[1] &lt; 10 else int(dimensions[1] / 10)))\n        y_ticks = np.arange(0, dimensions[0], (1 if dimensions[0] &lt; 5 else int(dimensions[0] / 5)))\n\n        ax1.set_title('Value function')\n        ax1_plot = ax1.imshow(value_table)\n\n        if dimensions[0] &gt;= dimensions[1]: # If higher than wide \n            plt.colorbar(ax1_plot, ax=ax1)\n        else:\n            plt.colorbar(ax1_plot, ax=ax1, location='bottom', orientation='horizontal')\n\n        ax1.set_xticks(x_ticks)\n        ax1.set_yticks(y_ticks)\n\n        ax2.set_title('Action policy')\n        ax2.imshow(best_action_colors)\n        p = [ patches.Patch(color=COLOR_LIST[int(i)]['id'], label=str(self.model.action_labels[int(i)])) for i in self.model.actions]\n        ax2.legend(handles=p, bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0., title='Actions')\n        ax2.set_xticks(x_ticks)\n        ax2.set_yticks(y_ticks)\n</code></pre>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.ValueFunction.actions","title":"<code>actions</code>  <code>property</code>","text":"<p>A list of N actions corresponding to the N alpha vectors making up the value function. If the value function is defined as a list of AlphaVector objects, the list will the generated from the actions of those alpha vector objects.</p>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.ValueFunction.alpha_vector_array","title":"<code>alpha_vector_array</code>  <code>property</code>","text":"<p>A matrix of size N x S, containing all the alpha vectors making up the value function. (N is the number of alpha vectors and S the amount of states in the model) If the value function is defined as a list of AlphaVector objects, the matrix will the generated from them.</p>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.ValueFunction.alpha_vector_list","title":"<code>alpha_vector_list</code>  <code>property</code>","text":"<p>A list of AlphaVector objects. If the value function is defined as an matrix of vectors and a list of actions, the list of AlphaVectors will be generated from them.</p>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.ValueFunction.append","title":"<code>append(alpha_vector)</code>","text":"<p>Function to add an alpha vector to the value function.</p> <p>Parameters:</p> Name Type Description Default <code>alpha_vector</code> <code>AlphaVector</code> <p>The alpha vector to be added to the value function.</p> required Source code in <code>olfactory_navigation/agents/model_based_util/value_function.py</code> <pre><code>def append(self,\n           alpha_vector: AlphaVector\n           ) -&gt; None:\n    '''\n    Function to add an alpha vector to the value function.\n\n    Parameters\n    ----------\n    alpha_vector : AlphaVector\n        The alpha vector to be added to the value function.\n    '''\n    # Make sure size is correct\n    assert alpha_vector.values.shape[0] == self.model.state_count, f\"Vector to add to value function doesn't have the right size (received: {alpha_vector.values.shape[0]}, expected: {self.model.state_count})\"\n\n    # GPU support check\n    xp = cp if (gpu_support and self.is_on_gpu) else np\n    assert gpu_support and cp.get_array_module(alpha_vector.values) == xp, f\"Vector is{' not' if self.is_on_gpu else ''} on GPU while value function is{'' if self.is_on_gpu else ' not'}.\"\n\n    if self._vector_array is not None:\n        self._vector_array = xp.append(self._vector_array, alpha_vector[None,:], axis=0)\n        self._actions = xp.append(self._actions, alpha_vector.action)\n\n    if self._vector_list is not None:\n        self._vector_list.append(alpha_vector)\n</code></pre>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.ValueFunction.evaluate_at","title":"<code>evaluate_at(belief)</code>","text":"<p>Function to evaluate the value function at a belief point or at a set of belief points. It returns a value and the associated action.</p> <p>Parameters:</p> Name Type Description Default <code>belief</code> <code>Belief or BeliefSet</code> required <p>Returns:</p> Name Type Description <code>value</code> <code>float or ndarray</code> <p>The largest value associated with the belief point(s)</p> <code>action</code> <code>int or ndarray</code> <p>The action(s) associated with the vector having the highest values at the belief point(s).</p> Source code in <code>olfactory_navigation/agents/model_based_util/value_function.py</code> <pre><code>def evaluate_at(self,\n                belief: Belief | BeliefSet\n                ) -&gt; tuple[float | np.ndarray, int | np.ndarray]:\n    '''\n    Function to evaluate the value function at a belief point or at a set of belief points.\n    It returns a value and the associated action.\n\n    Parameters\n    ----------\n    belief : Belief or BeliefSet\n\n    Returns\n    -------\n    value : float or np.ndarray\n        The largest value associated with the belief point(s)\n    action : int or np.ndarray\n        The action(s) associated with the vector having the highest values at the belief point(s).\n    '''\n    # GPU support check\n    xp = cp if (gpu_support and self.is_on_gpu) else np\n\n    best_value = None\n    best_action = None\n\n    if isinstance(belief, Belief):\n        # Computing values\n        belief_values = xp.dot(self.alpha_vector_array, belief.values)\n\n        # Selecting best vectors\n        best_vector = xp.argmax(belief_values)\n\n        # From best vector, compute the best value and action\n        best_value = float(belief_values[best_vector])\n        best_action = int(self.actions[best_vector])\n    else:\n        # Computing values\n        belief_values = xp.matmul(belief.values if isinstance(belief, Belief) else belief.belief_array, self.alpha_vector_array.T)\n\n        # Retrieving the top vectors according to the value function\n        best_vectors = xp.argmax(belief_values, axis=1)\n\n        # Retrieving the values and actions associated with the vectors chosen\n        best_value = belief_values[xp.arange(belief_values.shape[0]), best_vectors]\n        best_action = self.actions[best_vectors]\n\n    return (best_value, best_action)\n</code></pre>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.ValueFunction.extend","title":"<code>extend(other_value_function)</code>","text":"<p>Function to add another value function is place. Effectively, it performs the union of the two sets of alpha vectors.</p> <p>Parameters:</p> Name Type Description Default <code>other_value_function</code> <code>ValueFunction</code> <p>The other side of the union.</p> required Source code in <code>olfactory_navigation/agents/model_based_util/value_function.py</code> <pre><code>def extend(self,\n           other_value_function: 'Model'\n           ) -&gt; None:\n    '''\n    Function to add another value function is place.\n    Effectively, it performs the union of the two sets of alpha vectors.\n\n    Parameters\n    ----------\n    other_value_function : ValueFunction\n        The other side of the union.\n    '''\n    self._uniqueness_dict.update(other_value_function._uniqueness_dict)\n    self._vector_list = list(self._uniqueness_dict.values())\n\n    self._vector_array = None\n    self._actions = None\n\n    self._pruning_level = 1\n</code></pre>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.ValueFunction.load","title":"<code>load(file, model)</code>  <code>classmethod</code>","text":"<p>Function to load the value function from a csv file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>The path and file_name of the value function to be loaded.</p> required <code>model</code> <code>Model</code> <p>The model the value function is linked to.</p> required <p>Returns:</p> Name Type Description <code>loaded_value_function</code> <code>ValueFunction</code> <p>The loaded value function.</p> Source code in <code>olfactory_navigation/agents/model_based_util/value_function.py</code> <pre><code>@classmethod\ndef load(cls,\n         file: str,\n         model: Model\n         ) -&gt; 'ValueFunction':\n    '''\n    Function to load the value function from a csv file.\n\n    Parameters\n    ----------\n    file : str\n        The path and file_name of the value function to be loaded.\n    model : mdp.Model\n        The model the value function is linked to.\n\n    Returns\n    -------\n    loaded_value_function : ValueFunction\n        The loaded value function.\n    '''\n    av_array = np.load(file)\n\n    loaded_value_function = ValueFunction(model=model,\n                                          alpha_vectors=av_array[:,1:],\n                                          action_list=av_array[:,0].astype(int))\n\n    return loaded_value_function\n</code></pre>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.ValueFunction.plot","title":"<code>plot(as_grid=False, size=5, belief_set=None)</code>","text":"<p>Function to plot out the value function in 2 or 3 dimensions if possible and the as_grid parameter is kept to false. Else, the value function is plot as a grid. If a belief set array is provided and the model is a 2- or 3-model, it will be plot alongside the value function.</p> <p>Parameters:</p> Name Type Description Default <code>as_grid</code> <code>bool</code> <p>Forces the plot to be plot as a grid.</p> <code>False</code> <code>size</code> <code>int</code> <p>The actual plot scale.</p> <code>5</code> <code>belief_set</code> <code>ndarray</code> <p>A set of belief to plot the belief points that were explored.</p> <code>None</code> Source code in <code>olfactory_navigation/agents/model_based_util/value_function.py</code> <pre><code>def plot(self,\n         as_grid: bool = False,\n         size: int = 5,\n         belief_set: np.ndarray = None\n         ) -&gt; None:\n    '''\n    Function to plot out the value function in 2 or 3 dimensions if possible and the as_grid parameter is kept to false. Else, the value function is plot as a grid.\n    If a belief set array is provided and the model is a 2- or 3-model, it will be plot alongside the value function.\n\n    Parameters\n    ----------\n    as_grid : bool, default=False\n        Forces the plot to be plot as a grid.\n    size : int, default=5\n        The actual plot scale.\n    belief_set : np.ndarray, optional\n        A set of belief to plot the belief points that were explored.\n    '''\n    assert len(self) &gt; 0, \"Value function is empty, plotting is impossible...\"\n\n    # If on GPU, convert to CPU and plot that one\n    if self.is_on_gpu:\n        print('[Warning] Value function on GPU, converting to numpy before plotting...')\n        cpu_value_function = self.to_cpu()\n        cpu_value_function.plot(as_grid, size, belief_set)\n        return\n\n    func = None\n    if as_grid:\n        func = self._plot_grid\n    elif self.model.state_count == 2:\n        func = self._plot_2D\n    elif self.model.state_count == 3:\n        func = self._plot_3D\n    else:\n        print('[Warning] \\'as_grid\\' parameter set to False but state count is &gt;3 so it will be plotted as a grid')\n        func = self._plot_grid\n\n    func(size, belief_set)\n</code></pre>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.ValueFunction.prune","title":"<code>prune(level=1)</code>","text":"<p>Function pruning the set of alpha vectors composing the value function. The pruning is as thorough as the level:     - 2: 1+ Check of absolute domination (check if dominated at each state).     - 3: 2+ Solves Linear Programming problem for each alpha vector to see if it is dominated by combinations of other vectors.</p> <p>Note that the higher the level, the heavier the time impact will be.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>Between 0 and 3, how thorough the alpha vector pruning should be.</p> <code>1</code> Source code in <code>olfactory_navigation/agents/model_based_util/value_function.py</code> <pre><code>def prune(self,\n          level: int = 1\n          ) -&gt; None:\n    '''\n    Function pruning the set of alpha vectors composing the value function.\n    The pruning is as thorough as the level:\n        - 2: 1+ Check of absolute domination (check if dominated at each state).\n        - 3: 2+ Solves Linear Programming problem for each alpha vector to see if it is dominated by combinations of other vectors.\n\n    Note that the higher the level, the heavier the time impact will be.\n\n    Parameters\n    ----------\n    level : int, default=1\n        Between 0 and 3, how thorough the alpha vector pruning should be.\n    '''\n    # GPU support check\n    xp = cp if (gpu_support and self.is_on_gpu) else np\n\n    # Level 1 or under\n    if level &lt; self._pruning_level or level &gt; 3:\n        log('Attempting to prune a value function to a level already reached. Returning \\'self\\'')\n        return\n\n    # Level 2 pruning: Check for absolute domination\n    if level &gt;= 2 and self._pruning_level &lt; 2:\n        non_dominated_vector_indices = []\n\n        for i, v in enumerate(self.alpha_vector_array):\n            is_dom_by = xp.all(self.alpha_vector_array &gt;= v, axis=1)\n            if len(xp.where(is_dom_by)[0]) == 1:\n                non_dominated_vector_indices.append(i)\n\n        self._vector_array = self._vector_array[non_dominated_vector_indices]\n        self._actions = self._actions[non_dominated_vector_indices]\n\n    # Level 3 pruning: LP to check for more complex domination\n    if level &gt;= 3:\n        assert ilp_support, \"ILP support not enabled...\"\n\n        pruned_alpha_set = pruned_alpha_set.to_cpu()\n\n        alpha_set = pruned_alpha_set.alpha_vector_array\n        non_dominated_vector_indices = []\n\n        for i, alpha_vect in enumerate(alpha_set):\n            other_alphas = alpha_set[:i] + alpha_set[(i+1):]\n\n            # Objective function\n            c = np.concatenate([np.array([1]), -1*alpha_vect])\n\n            # Alpha vector contraints\n            other_count = len(other_alphas)\n            A = np.c_[np.ones(other_count), np.multiply(np.array(other_alphas), -1)]\n            alpha_constraints = LinearConstraint(A, 0, np.inf)\n\n            # Constraints that sum of beliefs is 1\n            belief_constraint = LinearConstraint(np.array([0] + ([1]*self.model.state_count)), 1, 1)\n\n            # Solve problem\n            res = milp(c=c, constraints=[alpha_constraints, belief_constraint])\n\n            # Check if dominated\n            is_dominated = (res.x[0] - np.dot(res.x[1:], alpha_vect)) &gt;= 0\n            if is_dominated:\n                print(alpha_vect)\n                print(' -&gt; Dominated\\n')\n            else:\n                non_dominated_vector_indices.append(i)\n\n        self._vector_array = self._vector_array[non_dominated_vector_indices]\n        self._actions = self._actions[non_dominated_vector_indices]\n\n    # Update the tracked pruned level so far\n    self._pruning_level = level\n</code></pre>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.ValueFunction.save","title":"<code>save(folder='./ValueFunctions', file_name=None)</code>","text":"<p>Function to save the value function in a file at a given path. If no path is provided, it will be saved in a subfolder (ValueFunctions) inside the current working directory. If no file_name is provided, it be saved as '_value_function.csv'. <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>The path at which the npy file will be saved.</p> <code>'./ValueFunctions'</code> <code>file_name</code> <code>str</code> <p>The file name used to save in.</p> <code>'&lt;current_timestamp&gt;_value_function.npy'</code> Source code in <code>olfactory_navigation/agents/model_based_util/value_function.py</code> <pre><code>def save(self,\n         folder: str = './ValueFunctions',\n         file_name: str | None = None\n         ) -&gt; None:\n    '''\n    Function to save the value function in a file at a given path. If no path is provided, it will be saved in a subfolder (ValueFunctions) inside the current working directory.\n    If no file_name is provided, it be saved as '&lt;current_timestamp&gt;_value_function.csv'.\n\n    Parameters\n    ----------\n    folder : str, default='./ValueFunctions'\n        The path at which the npy file will be saved.\n    file_name : str, default='&lt;current_timestamp&gt;_value_function.npy'\n        The file name used to save in.\n    '''\n    if self.is_on_gpu:\n        self.to_cpu().save(path=folder, file_name=file_name)\n        return\n\n    # Handle file_name\n    if file_name is None:\n        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n        file_name = timestamp + '_value_function.npy'\n\n    # Make sure that .csv is in the file name\n    if '.npy' not in file_name:\n        file_name += '.npy'\n\n    # Getting array\n    av_array = np.hstack([self.actions[:,None], self.alpha_vector_array])\n\n    np.save(folder + '/' + file_name, av_array)\n</code></pre>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.ValueFunction.to_cpu","title":"<code>to_cpu()</code>","text":"<p>Function returning an equivalent value function object with the arrays stored on CPU instead of GPU.</p> <p>Returns:</p> Name Type Description <code>cpu_value_function</code> <code>ValueFunction</code> <p>A new value function with arrays on CPU.</p> Source code in <code>olfactory_navigation/agents/model_based_util/value_function.py</code> <pre><code>def to_cpu(self) -&gt; 'ValueFunction':\n    '''\n    Function returning an equivalent value function object with the arrays stored on CPU instead of GPU.\n\n    Returns\n    -------\n    cpu_value_function : ValueFunction\n        A new value function with arrays on CPU.\n    '''\n    assert gpu_support, \"GPU support is not enabled, unable to execute this function\"\n\n    cpu_model = self.model.cpu_model\n\n    cpu_value_function = None\n    if self._vector_list is not None:\n        cpu_alpha_vectors = [AlphaVector(cp.asnumpy(av.values), av.action) for av in self._vector_list]\n        cpu_value_function = ValueFunction(cpu_model, cpu_alpha_vectors)\n\n    else:\n        cpu_vector_array = cp.asnumpy(self._vector_array)\n        cpu_actions = self._actions if isinstance(self._actions, list) else cp.asnumpy(self._actions)\n        cpu_value_function = ValueFunction(cpu_model, cpu_vector_array, cpu_actions)\n\n    return cpu_value_function\n</code></pre>"},{"location":"reference/agents/model_based_util/#olfactory_navigation.agents.model_based_util.ValueFunction.to_gpu","title":"<code>to_gpu()</code>","text":"<p>Function returning an equivalent value function object with the arrays stored on GPU instead of CPU.</p> <p>Returns:</p> Name Type Description <code>gpu_value_function</code> <code>ValueFunction</code> <p>A new value function with arrays on GPU.</p> Source code in <code>olfactory_navigation/agents/model_based_util/value_function.py</code> <pre><code>def to_gpu(self) -&gt; 'ValueFunction':\n    '''\n    Function returning an equivalent value function object with the arrays stored on GPU instead of CPU.\n\n    Returns\n    -------\n    gpu_value_function : ValueFunction\n        A new value function with arrays on GPU.\n    '''\n    assert gpu_support, \"GPU support is not enabled, unable to execute this function\"\n\n    gpu_model = self.model.gpu_model\n\n    gpu_value_function = None\n    if self._vector_list is not None:\n        gpu_alpha_vectors = [AlphaVector(cp.array(av.values), av.action) for av in self._vector_list]\n        gpu_value_function = ValueFunction(gpu_model, gpu_alpha_vectors)\n\n    else:\n        gpu_vector_array = cp.array(self._vector_array)\n        gpu_actions = self._actions if isinstance(self._actions, list) else cp.array(self._actions)\n        gpu_value_function = ValueFunction(gpu_model, gpu_vector_array, gpu_actions)\n\n    return gpu_value_function\n</code></pre>"},{"location":"reference/agents/model_based_util/belief/","title":"belief","text":""},{"location":"reference/agents/model_based_util/belief/#olfactory_navigation.agents.model_based_util.belief.Belief","title":"<code>Belief</code>","text":"<p>A class representing a belief in the space of a given model. It is the belief to be in any combination of states: eg:     - In a 2 state POMDP: a belief of (0.5, 0.5) represent the complete ignorance of which state we are in. Where a (1.0, 0.0) belief is the certainty to be in state 0.</p> <p>The belief update function has been implemented based on the belief update define in the paper of J. Pineau, G. Gordon, and S. Thrun, 'Point-based approximations for fast POMDP solving'</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model on which the belief applies on.</p> required <code>values</code> <code>ndarray</code> <p>A vector of the probabilities to be in each state of the model. The sum of the probabilities must sum to 1. If not specified, it will be set as the start probabilities of the model.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>Model</code> <code>values</code> <code>ndarray</code> <code>bytes_repr</code> <code>bytes</code> <p>A representation in bytes of the value of the belief</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>class Belief:\n    '''\n    A class representing a belief in the space of a given model. It is the belief to be in any combination of states:\n    eg:\n        - In a 2 state POMDP: a belief of (0.5, 0.5) represent the complete ignorance of which state we are in. Where a (1.0, 0.0) belief is the certainty to be in state 0.\n\n    The belief update function has been implemented based on the belief update define in the paper of J. Pineau, G. Gordon, and S. Thrun, 'Point-based approximations for fast POMDP solving'\n\n\n    Parameters\n    ----------\n    model : pomdp.Model\n        The model on which the belief applies on.\n    values : np.ndarray, optional\n        A vector of the probabilities to be in each state of the model. The sum of the probabilities must sum to 1.\n        If not specified, it will be set as the start probabilities of the model.\n\n    Attributes\n    ----------\n    model : pomdp.Model\n    values : np.ndarray\n    bytes_repr : bytes\n        A representation in bytes of the value of the belief\n    '''\n    def __init__(self,\n                 model: Model,\n                 values: np.ndarray | None = None\n                 ) -&gt; None:\n        assert model is not None\n        self.model = model\n\n        if values is not None:\n            assert values.shape[0] == model.state_count, \"Belief must contain be of dimension |S|\"\n\n            xp = np if not gpu_support else cp.get_array_module(values)\n\n            prob_sum = xp.sum(values)\n            rounded_sum = xp.round(prob_sum, decimals=3)\n            assert rounded_sum == 1.0, f\"States probabilities in belief must sum to 1 (found: {prob_sum}; rounded {rounded_sum})\"\n\n            self._values = values\n        else:\n            self._values = model.start_probabilities\n\n\n    def __new__(cls, *args, **kwargs):\n        instance = super().__new__(cls)\n\n        instance._bytes_repr = None\n        instance._successors = {}\n\n        return instance\n\n\n    @property\n    def bytes_repr(self) -&gt; bytes:\n        '''\n        A representation as bytes of a belief.\n        '''\n        if self._bytes_repr is None:\n            self._bytes_repr = self.values.tobytes()\n        return self._bytes_repr\n\n\n    def __eq__(self, other: object) -&gt; bool:\n        '''\n        A way to check the equality between two belief points.\n        The byte representation of each belief point is compared.\n        '''\n        return self.bytes_repr == other.bytes_repr\n\n\n    @property\n    def values(self) -&gt; np.ndarray:\n        '''\n        An array of the probability distribution to be in each state.\n        '''\n        return self._values\n\n\n    def update(self,\n               a: int,\n               o: int,\n               throw_error: bool = True\n               ) -&gt; 'Belief':\n        '''\n        Returns a new belief based on this current belief, the most recent action (a) and the most recent observation (o).\n\n        Parameters\n        ----------\n        a : int\n            The most recent action.\n        o : int\n            The most recent observation.\n        throw_error : bool, default=True\n            Whether the creation of an impossible belief (sum of probabilities of 0.0) will throw an error or not.\n\n        Returns\n        -------\n        new_belief : Belief\n            An updated belief\n        '''\n        xp = np if not gpu_support else cp.get_array_module(self._values)\n\n        # Check if successor exists\n        succ_id = f'{a}_{o}'\n        succ = self._successors.get(succ_id)\n        if succ is not None:\n            return succ\n\n        # Computing new probabilities\n        reachable_state_probabilities = self.model.reachable_transitional_observation_table[:,a,o,:] * self.values[:,None]\n        new_state_probabilities = xp.bincount(self.model.reachable_states[:,a,:].flatten(), weights=reachable_state_probabilities.flatten(), minlength=self.model.state_count)\n\n        # Normalization\n        probability_sum = xp.sum(new_state_probabilities)\n        if probability_sum == 0:\n            if throw_error:\n                raise ValueError(\"Impossible belief: the sum of probabilities is 0...\")\n        else:\n            new_state_probabilities /= probability_sum\n\n        # Generation of new belief from new state probabilities\n        new_belief = self.__new__(self.__class__)\n        new_belief.model = self.model\n        new_belief._values = new_state_probabilities\n\n        # Remember generated successor\n        self._successors[succ_id] = new_belief\n\n        return new_belief\n\n\n    def generate_successors(self) -&gt; list['Belief']:\n        '''\n        Function to generate a set of belief that can be reached for each actions and observations available in the model.\n\n        Returns\n        -------\n        successor_beliefs : list[Belief]\n            The successor beliefs.\n        '''\n        successor_beliefs = []\n        for a in self.model.actions:\n            for o in self.model.observations:\n                b_ao = self.update(a,o)\n                successor_beliefs.append(b_ao)\n\n        return successor_beliefs\n\n\n    def random_state(self) -&gt; int:\n        '''\n        Returns a random state of the model weighted by the belief probabily.\n\n        Returns\n        -------\n        rand_s : int\n            A random state.\n        '''\n        xp = np if not gpu_support else cp.get_array_module(self._values)\n\n        rand_s = int(self.model.rnd_state.choice(a=self.model.states, size=1, p=self._values)[0])\n        return rand_s\n\n\n    @property\n    def entropy(self) -&gt; float:\n        '''\n        The entropy of the belief point\n        '''\n        xp = np if not gpu_support else cp.get_array_module(self._values)\n\n        return float(entropy(self._values) if xp == np else cupy_entropy(self._values))\n\n\n    def plot(self, size: int = 5) -&gt; None:\n        '''\n        Function to plot a heatmap of the belief distribution if the belief is of a grid model.\n\n        Parameters\n        ----------\n        size : int, default=5\n            The scale of the plot.\n        '''\n        # Plot setup\n        plt.figure(figsize=(size*1.2,size))\n\n        model = self.model.cpu_model\n\n        # Ticks\n        dimensions = model.state_grid.shape\n        x_ticks = np.arange(0, dimensions[1], (1 if dimensions[1] &lt; 10 else int(dimensions[1] / 10)))\n        y_ticks = np.arange(0, dimensions[0], (1 if dimensions[0] &lt; 5 else int(dimensions[0] / 5)))\n\n        plt.xticks(x_ticks)\n        plt.yticks(y_ticks)\n\n        # Title\n        plt.title(f'Belief (probability distribution over states)')\n\n        # Actual plot\n        belief_values = self._values if (not gpu_support) or (cp.get_array_module(self._values) == np) else cp.asnumpy(self._values)\n        grid_values = belief_values[model.state_grid]\n        plt.imshow(grid_values,cmap='Blues')\n        plt.colorbar()\n        plt.show()\n</code></pre>"},{"location":"reference/agents/model_based_util/belief/#olfactory_navigation.agents.model_based_util.belief.Belief.bytes_repr","title":"<code>bytes_repr</code>  <code>property</code>","text":"<p>A representation as bytes of a belief.</p>"},{"location":"reference/agents/model_based_util/belief/#olfactory_navigation.agents.model_based_util.belief.Belief.entropy","title":"<code>entropy</code>  <code>property</code>","text":"<p>The entropy of the belief point</p>"},{"location":"reference/agents/model_based_util/belief/#olfactory_navigation.agents.model_based_util.belief.Belief.values","title":"<code>values</code>  <code>property</code>","text":"<p>An array of the probability distribution to be in each state.</p>"},{"location":"reference/agents/model_based_util/belief/#olfactory_navigation.agents.model_based_util.belief.Belief.__eq__","title":"<code>__eq__(other)</code>","text":"<p>A way to check the equality between two belief points. The byte representation of each belief point is compared.</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    '''\n    A way to check the equality between two belief points.\n    The byte representation of each belief point is compared.\n    '''\n    return self.bytes_repr == other.bytes_repr\n</code></pre>"},{"location":"reference/agents/model_based_util/belief/#olfactory_navigation.agents.model_based_util.belief.Belief.generate_successors","title":"<code>generate_successors()</code>","text":"<p>Function to generate a set of belief that can be reached for each actions and observations available in the model.</p> <p>Returns:</p> Name Type Description <code>successor_beliefs</code> <code>list[Belief]</code> <p>The successor beliefs.</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>def generate_successors(self) -&gt; list['Belief']:\n    '''\n    Function to generate a set of belief that can be reached for each actions and observations available in the model.\n\n    Returns\n    -------\n    successor_beliefs : list[Belief]\n        The successor beliefs.\n    '''\n    successor_beliefs = []\n    for a in self.model.actions:\n        for o in self.model.observations:\n            b_ao = self.update(a,o)\n            successor_beliefs.append(b_ao)\n\n    return successor_beliefs\n</code></pre>"},{"location":"reference/agents/model_based_util/belief/#olfactory_navigation.agents.model_based_util.belief.Belief.plot","title":"<code>plot(size=5)</code>","text":"<p>Function to plot a heatmap of the belief distribution if the belief is of a grid model.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>The scale of the plot.</p> <code>5</code> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>def plot(self, size: int = 5) -&gt; None:\n    '''\n    Function to plot a heatmap of the belief distribution if the belief is of a grid model.\n\n    Parameters\n    ----------\n    size : int, default=5\n        The scale of the plot.\n    '''\n    # Plot setup\n    plt.figure(figsize=(size*1.2,size))\n\n    model = self.model.cpu_model\n\n    # Ticks\n    dimensions = model.state_grid.shape\n    x_ticks = np.arange(0, dimensions[1], (1 if dimensions[1] &lt; 10 else int(dimensions[1] / 10)))\n    y_ticks = np.arange(0, dimensions[0], (1 if dimensions[0] &lt; 5 else int(dimensions[0] / 5)))\n\n    plt.xticks(x_ticks)\n    plt.yticks(y_ticks)\n\n    # Title\n    plt.title(f'Belief (probability distribution over states)')\n\n    # Actual plot\n    belief_values = self._values if (not gpu_support) or (cp.get_array_module(self._values) == np) else cp.asnumpy(self._values)\n    grid_values = belief_values[model.state_grid]\n    plt.imshow(grid_values,cmap='Blues')\n    plt.colorbar()\n    plt.show()\n</code></pre>"},{"location":"reference/agents/model_based_util/belief/#olfactory_navigation.agents.model_based_util.belief.Belief.random_state","title":"<code>random_state()</code>","text":"<p>Returns a random state of the model weighted by the belief probabily.</p> <p>Returns:</p> Name Type Description <code>rand_s</code> <code>int</code> <p>A random state.</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>def random_state(self) -&gt; int:\n    '''\n    Returns a random state of the model weighted by the belief probabily.\n\n    Returns\n    -------\n    rand_s : int\n        A random state.\n    '''\n    xp = np if not gpu_support else cp.get_array_module(self._values)\n\n    rand_s = int(self.model.rnd_state.choice(a=self.model.states, size=1, p=self._values)[0])\n    return rand_s\n</code></pre>"},{"location":"reference/agents/model_based_util/belief/#olfactory_navigation.agents.model_based_util.belief.Belief.update","title":"<code>update(a, o, throw_error=True)</code>","text":"<p>Returns a new belief based on this current belief, the most recent action (a) and the most recent observation (o).</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>The most recent action.</p> required <code>o</code> <code>int</code> <p>The most recent observation.</p> required <code>throw_error</code> <code>bool</code> <p>Whether the creation of an impossible belief (sum of probabilities of 0.0) will throw an error or not.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>new_belief</code> <code>Belief</code> <p>An updated belief</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>def update(self,\n           a: int,\n           o: int,\n           throw_error: bool = True\n           ) -&gt; 'Belief':\n    '''\n    Returns a new belief based on this current belief, the most recent action (a) and the most recent observation (o).\n\n    Parameters\n    ----------\n    a : int\n        The most recent action.\n    o : int\n        The most recent observation.\n    throw_error : bool, default=True\n        Whether the creation of an impossible belief (sum of probabilities of 0.0) will throw an error or not.\n\n    Returns\n    -------\n    new_belief : Belief\n        An updated belief\n    '''\n    xp = np if not gpu_support else cp.get_array_module(self._values)\n\n    # Check if successor exists\n    succ_id = f'{a}_{o}'\n    succ = self._successors.get(succ_id)\n    if succ is not None:\n        return succ\n\n    # Computing new probabilities\n    reachable_state_probabilities = self.model.reachable_transitional_observation_table[:,a,o,:] * self.values[:,None]\n    new_state_probabilities = xp.bincount(self.model.reachable_states[:,a,:].flatten(), weights=reachable_state_probabilities.flatten(), minlength=self.model.state_count)\n\n    # Normalization\n    probability_sum = xp.sum(new_state_probabilities)\n    if probability_sum == 0:\n        if throw_error:\n            raise ValueError(\"Impossible belief: the sum of probabilities is 0...\")\n    else:\n        new_state_probabilities /= probability_sum\n\n    # Generation of new belief from new state probabilities\n    new_belief = self.__new__(self.__class__)\n    new_belief.model = self.model\n    new_belief._values = new_state_probabilities\n\n    # Remember generated successor\n    self._successors[succ_id] = new_belief\n\n    return new_belief\n</code></pre>"},{"location":"reference/agents/model_based_util/belief/#olfactory_navigation.agents.model_based_util.belief.BeliefSet","title":"<code>BeliefSet</code>","text":"<p>Class to represent a set of beliefs with regard to a POMDP model. It has the purpose to store the beliefs in a numpy array format and be able to conver it to a list of Belief class objects.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model on which the beliefs apply.</p> required <code>beliefs</code> <code>list[Belief] or ndarray</code> <p>The actual set of beliefs.</p> required <p>Attributes:</p> Name Type Description <code>model</code> <code>Model</code> <code>belief_array</code> <code>ndarray</code> <p>A 2D array of shape N x S of N belief vectors.</p> <code>belief_list</code> <code>list[Belief]</code> <p>A list of N Belief object.</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>class BeliefSet:\n    '''\n    Class to represent a set of beliefs with regard to a POMDP model.\n    It has the purpose to store the beliefs in a numpy array format and be able to conver it to a list of Belief class objects.\n\n\n    Parameters\n    ----------\n    model : pomdp.Model\n        The model on which the beliefs apply.\n    beliefs : list[Belief] or np.ndarray\n        The actual set of beliefs.\n\n    Attributes\n    ----------\n    model : pomdp.Model\n    belief_array : np.ndarray\n        A 2D array of shape N x S of N belief vectors.\n    belief_list : list[Belief]\n        A list of N Belief object.\n    '''\n    def __init__(self,\n                 model: Model,\n                 beliefs: list[Belief] | np.ndarray\n                 ) -&gt; None:\n        self.model = model\n\n        self._belief_list = None\n        self._belief_array = None\n        self._uniqueness_dict = None\n\n        self.is_on_gpu = False\n\n        if isinstance(beliefs, list):\n            assert all(len(b.values) == model.state_count for b in beliefs), f\"Beliefs in belief list provided dont all have shape ({model.state_count},)\"\n            self._belief_list = beliefs\n\n            # Check if on gpu and make sure all beliefs are also on the gpu\n            if (len(beliefs) &gt; 0) and gpu_support and cp.get_array_module(beliefs[0].values) == cp:\n                assert all(cp.get_array_module(b.values) == cp for b in beliefs), \"Either all or none of the alpha vectors should be on the GPU, not just some.\"\n                self.is_on_gpu = True\n        else:\n            assert beliefs.shape[1] == model.state_count, f\"Belief array provided doesnt have the right shape (expected (-,{model.state_count}), received {beliefs.shape})\"\n\n            self._belief_array = beliefs\n\n            # Check if array is on gpu\n            if gpu_support and cp.get_array_module(beliefs) == cp:\n                self.is_on_gpu = True\n\n\n    @property\n    def belief_array(self) -&gt; np.ndarray:\n        '''\n        A matrix of size N x S containing N belief vectors. If belief set is stored as a list of Belief objects, the matrix of beliefs will be generated from them.\n        '''\n        xp = cp if (gpu_support and self.is_on_gpu) else np\n\n        if self._belief_array is None:\n            self._belief_array = xp.array([b.values for b in self._belief_list])\n        return self._belief_array\n\n\n    @property\n    def belief_list(self) -&gt; list[Belief]:\n        '''\n        A list of Belief objects. If the belief set is represented as a matrix of Belief vectors, the list of Belief objects will be generated from it.\n        '''\n        if self._belief_list is None:\n            self._belief_list = [Belief(self.model, belief_vector) for belief_vector in self._belief_array]\n        return self._belief_list\n\n\n    def generate_all_successors(self) -&gt; 'BeliefSet':\n        '''\n        Function to generate the successors beliefs of all the beliefs in the belief set.\n\n        Returns\n        -------\n        all_successors : BeliefSet\n            All successors of all beliefs in the belief set.\n        '''\n        all_successors = []\n        for belief in self.belief_list:\n            all_successors.extend(belief.generate_successors())\n        return BeliefSet(self.model, all_successors)\n\n\n    def update(self,\n               actions: list | np.ndarray,\n               observations: list | np.ndarray,\n               throw_error: bool = True\n               ) -&gt; 'BeliefSet':\n        '''\n        Returns a new belief based on this current belief, the most recent action (a) and the most recent observation (o).\n\n        Parameters\n        ----------\n        actions : list or np.ndarray\n            The most recent played actions.\n        observations : list or np.ndarray\n            The most recent received observations.\n        throw_error : bool, default=True\n            Whether the throw an error when attempting to generate impossible beliefs.\n\n        Returns\n        -------\n        new_belief_set : BeliefSet\n            An set of updated beliefs.\n        '''\n        # GPU support check\n        xp = cp if (gpu_support and self.is_on_gpu) else np\n\n        # Ensuring we are dealing we are dealing with ndarrays\n        observations = xp.array(observations)\n        actions = xp.array(actions)\n\n        # Computing reachable probabilities and states\n        reachable_probabilities = (self.model.reachable_transitional_observation_table[:, actions, observations, :] * self.belief_array.T[:,:,None])\n        reachable_state_per_actions = self.model.reachable_states[:, actions, :]\n\n        # Computing new probabilities\n        flatten_offset = xp.arange(len(observations))[:,None] * self.model.state_count\n        flat_shape = (len(observations), (self.model.state_count * self.model.reachable_state_count))\n\n        a = reachable_state_per_actions.swapaxes(0,1).reshape(flat_shape)\n        w = reachable_probabilities.swapaxes(0,1).reshape(flat_shape)\n\n        a_offs = a + flatten_offset\n        new_probabilities = xp.bincount(a_offs.ravel(), weights=w.ravel(), minlength=a.shape[0]*self.model.state_count).reshape((-1,self.model.state_count))\n\n        # Normalization\n        probability_sum = xp.sum(new_probabilities, axis=1)\n        if xp.any(probability_sum == 0.0) and throw_error:\n            raise ValueError('One or more belief is impossible, (ie the sum of the probability distribution is 0)')\n        non_zero_mask = probability_sum != 0\n        new_probabilities[non_zero_mask] /= probability_sum[non_zero_mask,None]\n\n        return BeliefSet(self.model, new_probabilities)\n\n\n    @property\n    def unique_belief_dict(self) -&gt; dict:\n        '''\n        A dictionary of unique belief points with the keys being the byte representation of these belief points.\n        '''\n        if self._uniqueness_dict is None:\n            self._uniqueness_dict = {belief.bytes_repr: belief for belief in self.belief_list}\n        return self._uniqueness_dict\n\n\n    def union(self, other_belief_set: 'BeliefSet') -&gt; 'BeliefSet':\n        '''\n        Function to make the union between two belief set objects.\n\n        Parameters\n        ----------\n        other_belief_set : BeliefSet\n            The other belief set to make the union with\n\n        Returns\n        -------\n        new_belief_set : BeliefSet\n            A new, combined, belief set\n        '''\n        # Deduplication\n        combined_uniqueness_dict = self.unique_belief_dict | other_belief_set.unique_belief_dict\n\n        # Generation of new set\n        new_belief_set = BeliefSet(self.model, list(combined_uniqueness_dict.values()))\n        new_belief_set._uniqueness_dict = combined_uniqueness_dict\n\n        return new_belief_set\n\n\n    def __len__(self) -&gt; int:\n        return len(self._belief_list) if self._belief_list is not None else self._belief_array.shape[0]\n\n\n    @property\n    def entropies(self) -&gt; np.ndarray:\n        '''\n        An array of the entropies of the belief points.\n        '''\n        xp = np if not gpu_support else cp.get_array_module(self.belief_array)\n\n        return entropy(self.belief_array, axis=1) if xp == np else cupy_entropy(self.belief_array, axis=1)\n\n\n    def to_gpu(self) -&gt; 'BeliefSet':\n        '''\n        Function returning an equivalent belief set object with the array of values stored on GPU instead of CPU.\n\n        Returns\n        -------\n        gpu_belief_set : BeliefSet\n            A new belief set with array on GPU.\n        '''\n        assert gpu_support, \"GPU support is not enabled, unable to execute this function\"\n\n        gpu_model = self.model.gpu_model\n\n        gpu_belief_set = None\n        if self._belief_array is not None:\n            gpu_belief_array = cp.array(self._belief_array)\n            gpu_belief_set = BeliefSet(gpu_model, gpu_belief_array)\n        else:\n            gpu_belief_list = [Belief(gpu_model, cp.array(b.values)) for b in self._belief_list]\n            gpu_belief_set = BeliefSet(gpu_model, gpu_belief_list)\n\n        return gpu_belief_set\n\n\n    def to_cpu(self) -&gt; 'BeliefSet':\n        '''\n        Function returning an equivalent belief set object with the array of values stored on CPU instead of GPU.\n\n        Returns\n        -------\n        cpu_belief_set : BeliefSet\n            A new belief set with array on CPU.\n        '''\n        assert gpu_support, \"GPU support is not enabled, unable to execute this function\"\n\n        cpu_model = self.model.cpu_model\n\n        cpu_belief_set = None\n        if self._belief_array is not None:\n            cpu_belief_array = cp.asnumpy(self._belief_array)\n            cpu_belief_set = BeliefSet(cpu_model, cpu_belief_array)\n\n        else:\n            cpu_belief_list = [Belief(cpu_model, cp.asnumpy(b.values)) for b in self._belief_list]\n            cpu_belief_set = BeliefSet(cpu_model, cpu_belief_list)\n\n        return cpu_belief_set\n</code></pre>"},{"location":"reference/agents/model_based_util/belief/#olfactory_navigation.agents.model_based_util.belief.BeliefSet.belief_array","title":"<code>belief_array</code>  <code>property</code>","text":"<p>A matrix of size N x S containing N belief vectors. If belief set is stored as a list of Belief objects, the matrix of beliefs will be generated from them.</p>"},{"location":"reference/agents/model_based_util/belief/#olfactory_navigation.agents.model_based_util.belief.BeliefSet.belief_list","title":"<code>belief_list</code>  <code>property</code>","text":"<p>A list of Belief objects. If the belief set is represented as a matrix of Belief vectors, the list of Belief objects will be generated from it.</p>"},{"location":"reference/agents/model_based_util/belief/#olfactory_navigation.agents.model_based_util.belief.BeliefSet.entropies","title":"<code>entropies</code>  <code>property</code>","text":"<p>An array of the entropies of the belief points.</p>"},{"location":"reference/agents/model_based_util/belief/#olfactory_navigation.agents.model_based_util.belief.BeliefSet.unique_belief_dict","title":"<code>unique_belief_dict</code>  <code>property</code>","text":"<p>A dictionary of unique belief points with the keys being the byte representation of these belief points.</p>"},{"location":"reference/agents/model_based_util/belief/#olfactory_navigation.agents.model_based_util.belief.BeliefSet.generate_all_successors","title":"<code>generate_all_successors()</code>","text":"<p>Function to generate the successors beliefs of all the beliefs in the belief set.</p> <p>Returns:</p> Name Type Description <code>all_successors</code> <code>BeliefSet</code> <p>All successors of all beliefs in the belief set.</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>def generate_all_successors(self) -&gt; 'BeliefSet':\n    '''\n    Function to generate the successors beliefs of all the beliefs in the belief set.\n\n    Returns\n    -------\n    all_successors : BeliefSet\n        All successors of all beliefs in the belief set.\n    '''\n    all_successors = []\n    for belief in self.belief_list:\n        all_successors.extend(belief.generate_successors())\n    return BeliefSet(self.model, all_successors)\n</code></pre>"},{"location":"reference/agents/model_based_util/belief/#olfactory_navigation.agents.model_based_util.belief.BeliefSet.to_cpu","title":"<code>to_cpu()</code>","text":"<p>Function returning an equivalent belief set object with the array of values stored on CPU instead of GPU.</p> <p>Returns:</p> Name Type Description <code>cpu_belief_set</code> <code>BeliefSet</code> <p>A new belief set with array on CPU.</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>def to_cpu(self) -&gt; 'BeliefSet':\n    '''\n    Function returning an equivalent belief set object with the array of values stored on CPU instead of GPU.\n\n    Returns\n    -------\n    cpu_belief_set : BeliefSet\n        A new belief set with array on CPU.\n    '''\n    assert gpu_support, \"GPU support is not enabled, unable to execute this function\"\n\n    cpu_model = self.model.cpu_model\n\n    cpu_belief_set = None\n    if self._belief_array is not None:\n        cpu_belief_array = cp.asnumpy(self._belief_array)\n        cpu_belief_set = BeliefSet(cpu_model, cpu_belief_array)\n\n    else:\n        cpu_belief_list = [Belief(cpu_model, cp.asnumpy(b.values)) for b in self._belief_list]\n        cpu_belief_set = BeliefSet(cpu_model, cpu_belief_list)\n\n    return cpu_belief_set\n</code></pre>"},{"location":"reference/agents/model_based_util/belief/#olfactory_navigation.agents.model_based_util.belief.BeliefSet.to_gpu","title":"<code>to_gpu()</code>","text":"<p>Function returning an equivalent belief set object with the array of values stored on GPU instead of CPU.</p> <p>Returns:</p> Name Type Description <code>gpu_belief_set</code> <code>BeliefSet</code> <p>A new belief set with array on GPU.</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>def to_gpu(self) -&gt; 'BeliefSet':\n    '''\n    Function returning an equivalent belief set object with the array of values stored on GPU instead of CPU.\n\n    Returns\n    -------\n    gpu_belief_set : BeliefSet\n        A new belief set with array on GPU.\n    '''\n    assert gpu_support, \"GPU support is not enabled, unable to execute this function\"\n\n    gpu_model = self.model.gpu_model\n\n    gpu_belief_set = None\n    if self._belief_array is not None:\n        gpu_belief_array = cp.array(self._belief_array)\n        gpu_belief_set = BeliefSet(gpu_model, gpu_belief_array)\n    else:\n        gpu_belief_list = [Belief(gpu_model, cp.array(b.values)) for b in self._belief_list]\n        gpu_belief_set = BeliefSet(gpu_model, gpu_belief_list)\n\n    return gpu_belief_set\n</code></pre>"},{"location":"reference/agents/model_based_util/belief/#olfactory_navigation.agents.model_based_util.belief.BeliefSet.union","title":"<code>union(other_belief_set)</code>","text":"<p>Function to make the union between two belief set objects.</p> <p>Parameters:</p> Name Type Description Default <code>other_belief_set</code> <code>BeliefSet</code> <p>The other belief set to make the union with</p> required <p>Returns:</p> Name Type Description <code>new_belief_set</code> <code>BeliefSet</code> <p>A new, combined, belief set</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>def union(self, other_belief_set: 'BeliefSet') -&gt; 'BeliefSet':\n    '''\n    Function to make the union between two belief set objects.\n\n    Parameters\n    ----------\n    other_belief_set : BeliefSet\n        The other belief set to make the union with\n\n    Returns\n    -------\n    new_belief_set : BeliefSet\n        A new, combined, belief set\n    '''\n    # Deduplication\n    combined_uniqueness_dict = self.unique_belief_dict | other_belief_set.unique_belief_dict\n\n    # Generation of new set\n    new_belief_set = BeliefSet(self.model, list(combined_uniqueness_dict.values()))\n    new_belief_set._uniqueness_dict = combined_uniqueness_dict\n\n    return new_belief_set\n</code></pre>"},{"location":"reference/agents/model_based_util/belief/#olfactory_navigation.agents.model_based_util.belief.BeliefSet.update","title":"<code>update(actions, observations, throw_error=True)</code>","text":"<p>Returns a new belief based on this current belief, the most recent action (a) and the most recent observation (o).</p> <p>Parameters:</p> Name Type Description Default <code>actions</code> <code>list or ndarray</code> <p>The most recent played actions.</p> required <code>observations</code> <code>list or ndarray</code> <p>The most recent received observations.</p> required <code>throw_error</code> <code>bool</code> <p>Whether the throw an error when attempting to generate impossible beliefs.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>new_belief_set</code> <code>BeliefSet</code> <p>An set of updated beliefs.</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief.py</code> <pre><code>def update(self,\n           actions: list | np.ndarray,\n           observations: list | np.ndarray,\n           throw_error: bool = True\n           ) -&gt; 'BeliefSet':\n    '''\n    Returns a new belief based on this current belief, the most recent action (a) and the most recent observation (o).\n\n    Parameters\n    ----------\n    actions : list or np.ndarray\n        The most recent played actions.\n    observations : list or np.ndarray\n        The most recent received observations.\n    throw_error : bool, default=True\n        Whether the throw an error when attempting to generate impossible beliefs.\n\n    Returns\n    -------\n    new_belief_set : BeliefSet\n        An set of updated beliefs.\n    '''\n    # GPU support check\n    xp = cp if (gpu_support and self.is_on_gpu) else np\n\n    # Ensuring we are dealing we are dealing with ndarrays\n    observations = xp.array(observations)\n    actions = xp.array(actions)\n\n    # Computing reachable probabilities and states\n    reachable_probabilities = (self.model.reachable_transitional_observation_table[:, actions, observations, :] * self.belief_array.T[:,:,None])\n    reachable_state_per_actions = self.model.reachable_states[:, actions, :]\n\n    # Computing new probabilities\n    flatten_offset = xp.arange(len(observations))[:,None] * self.model.state_count\n    flat_shape = (len(observations), (self.model.state_count * self.model.reachable_state_count))\n\n    a = reachable_state_per_actions.swapaxes(0,1).reshape(flat_shape)\n    w = reachable_probabilities.swapaxes(0,1).reshape(flat_shape)\n\n    a_offs = a + flatten_offset\n    new_probabilities = xp.bincount(a_offs.ravel(), weights=w.ravel(), minlength=a.shape[0]*self.model.state_count).reshape((-1,self.model.state_count))\n\n    # Normalization\n    probability_sum = xp.sum(new_probabilities, axis=1)\n    if xp.any(probability_sum == 0.0) and throw_error:\n        raise ValueError('One or more belief is impossible, (ie the sum of the probability distribution is 0)')\n    non_zero_mask = probability_sum != 0\n    new_probabilities[non_zero_mask] /= probability_sum[non_zero_mask,None]\n\n    return BeliefSet(self.model, new_probabilities)\n</code></pre>"},{"location":"reference/agents/model_based_util/belief_value_mapping/","title":"belief_value_mapping","text":""},{"location":"reference/agents/model_based_util/belief_value_mapping/#olfactory_navigation.agents.model_based_util.belief_value_mapping.BeliefValueMapping","title":"<code>BeliefValueMapping</code>","text":"<p>Alternate representation of a value function, particularly for pomdp models. It works by adding adding belief and associated value to the object. To evaluate this version of the value function the sawtooth algorithm is used (described in Shani G. et al., \"A survey of point-based POMDP solvers\")</p> <p>We can also compute the Q value for a particular belief b and action using the qva function.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model on which the value function applies on</p> required <code>corner_belief_values</code> <code>ValueFunction</code> <p>A general value function to define the value at corner points in belief space (ie: at certainty beliefs, or when beliefs have a probability of 1 for a given state). This is usually the solution of the MDP version of the problem.</p> required <p>Attributes:</p> Name Type Description <code>model</code> <code>Model</code> <code>corner_belief_values</code> <code>ValueFunction</code> <code>corner_values</code> <code>ndarray</code> <p>Array of |S| shape, having the max value at each state based on the corner_belief_values.</p> <code>beliefs</code> <code>Belief</code> <p>Beliefs contained in the belief-value mapping.</p> <code>belief_value_mapping</code> <code>dict[bytes, float]</code> <p>Mapping of beliefs points with their associated value.</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief_value_mapping.py</code> <pre><code>class BeliefValueMapping:\n    '''\n    Alternate representation of a value function, particularly for pomdp models.\n    It works by adding adding belief and associated value to the object.\n    To evaluate this version of the value function the sawtooth algorithm is used (described in Shani G. et al., \"A survey of point-based POMDP solvers\")\n\n    We can also compute the Q value for a particular belief b and action using the qva function.\n\n\n    Parameters\n    ----------\n    model : pomdp.Model\n        The model on which the value function applies on\n    corner_belief_values : ValueFunction\n        A general value function to define the value at corner points in belief space (ie: at certainty beliefs, or when beliefs have a probability of 1 for a given state).\n        This is usually the solution of the MDP version of the problem.\n\n    Attributes\n    ----------\n    model : pomdp.Model\n    corner_belief_values : ValueFunction\n    corner_values : np.ndarray\n        Array of |S| shape, having the max value at each state based on the corner_belief_values.\n    beliefs : Belief\n        Beliefs contained in the belief-value mapping.\n    belief_value_mapping : dict[bytes, float]\n        Mapping of beliefs points with their associated value.\n\n    '''\n    def __init__(self,\n                 model: Model,\n                 corner_belief_values: ValueFunction\n                 ) -&gt; None:\n        xp = np if not gpu_support else cp.get_array_module(corner_belief_values.alpha_vector_array)\n\n        self.model = model\n        self.corner_belief_values = corner_belief_values\n\n        self.corner_values = xp.max(corner_belief_values.alpha_vector_array, axis=0)\n\n        self.beliefs = []\n        self.belief_value_mapping = {}\n\n        self._belief_array = None\n        self._value_array = None\n\n\n    def add(self,\n            b: Belief,\n            v: float\n            ) -&gt; None:\n        '''\n        Function to a belief point and its associated value to the belief value mappings.\n\n        Parameters\n        ----------\n        b: Belief\n            A belief to add the belief value mappings.\n        v: float\n            The value associated to the belief to be added to the mappings.\n        '''\n        if b not in self.beliefs:\n            self.beliefs.append(b)\n            self.belief_value_mapping[b.bytes_repr] = v\n\n\n    @property\n    def belief_array(self) -&gt; np.ndarray:\n        '''\n        The beliefs represented in the form of an array.\n        '''\n        xp = np if not gpu_support else cp.get_array_module(self.beliefs[0].values)\n\n        if self._belief_array is None:\n            self._belief_array = xp.array([b.values for b in self.beliefs])\n\n        return self._belief_array\n\n\n    @property\n    def value_array(self) -&gt; np.ndarray:\n        '''\n        An array of the values.\n        '''\n        xp = np if not gpu_support else cp.get_array_module(self.beliefs[0].values)\n\n        if self._value_array is None:\n            self._value_array = xp.array(list(self.belief_value_mapping.values()))\n\n        return self._value_array\n\n\n    def update(self) -&gt; None:\n        '''\n        Function to update the belief and value arrays to speed up computation.\n        '''\n        xp = np if not gpu_support else cp.get_array_module(self.beliefs[0].values)\n\n        self._belief_array = xp.array([b.values for b in self.beliefs])\n        self._value_array = xp.array(list(self.belief_value_mapping.values()))\n\n\n    def evaluate(self, belief: Belief) -&gt; float:\n        '''\n        Runs the sawtooth algorithm to find the value at a given belief point.\n\n        Parameters\n        ----------\n        belief : Belief\n        '''\n        xp = np if not gpu_support else cp.get_array_module(belief.values)\n\n        # Shortcut if belief already exists in the mapping\n        if belief in self.beliefs:\n            return self.belief_value_mapping[belief.bytes_repr]\n\n        v0 = xp.dot(belief.values, self.corner_values)\n\n        if len(self.beliefs) == 0:\n            return float(v0)\n\n        with np.errstate(divide='ignore', invalid='ignore'):\n            vb = v0 + ((self.value_array - xp.dot(self.belief_array, self.corner_values)) * xp.min(belief.values / self.belief_array, axis=1))\n\n        return float(xp.min(xp.append(vb, v0)))\n</code></pre>"},{"location":"reference/agents/model_based_util/belief_value_mapping/#olfactory_navigation.agents.model_based_util.belief_value_mapping.BeliefValueMapping.belief_array","title":"<code>belief_array</code>  <code>property</code>","text":"<p>The beliefs represented in the form of an array.</p>"},{"location":"reference/agents/model_based_util/belief_value_mapping/#olfactory_navigation.agents.model_based_util.belief_value_mapping.BeliefValueMapping.value_array","title":"<code>value_array</code>  <code>property</code>","text":"<p>An array of the values.</p>"},{"location":"reference/agents/model_based_util/belief_value_mapping/#olfactory_navigation.agents.model_based_util.belief_value_mapping.BeliefValueMapping.add","title":"<code>add(b, v)</code>","text":"<p>Function to a belief point and its associated value to the belief value mappings.</p> <p>Parameters:</p> Name Type Description Default <code>b</code> <code>Belief</code> <p>A belief to add the belief value mappings.</p> required <code>v</code> <code>float</code> <p>The value associated to the belief to be added to the mappings.</p> required Source code in <code>olfactory_navigation/agents/model_based_util/belief_value_mapping.py</code> <pre><code>def add(self,\n        b: Belief,\n        v: float\n        ) -&gt; None:\n    '''\n    Function to a belief point and its associated value to the belief value mappings.\n\n    Parameters\n    ----------\n    b: Belief\n        A belief to add the belief value mappings.\n    v: float\n        The value associated to the belief to be added to the mappings.\n    '''\n    if b not in self.beliefs:\n        self.beliefs.append(b)\n        self.belief_value_mapping[b.bytes_repr] = v\n</code></pre>"},{"location":"reference/agents/model_based_util/belief_value_mapping/#olfactory_navigation.agents.model_based_util.belief_value_mapping.BeliefValueMapping.evaluate","title":"<code>evaluate(belief)</code>","text":"<p>Runs the sawtooth algorithm to find the value at a given belief point.</p> <p>Parameters:</p> Name Type Description Default <code>belief</code> <code>Belief</code> required Source code in <code>olfactory_navigation/agents/model_based_util/belief_value_mapping.py</code> <pre><code>def evaluate(self, belief: Belief) -&gt; float:\n    '''\n    Runs the sawtooth algorithm to find the value at a given belief point.\n\n    Parameters\n    ----------\n    belief : Belief\n    '''\n    xp = np if not gpu_support else cp.get_array_module(belief.values)\n\n    # Shortcut if belief already exists in the mapping\n    if belief in self.beliefs:\n        return self.belief_value_mapping[belief.bytes_repr]\n\n    v0 = xp.dot(belief.values, self.corner_values)\n\n    if len(self.beliefs) == 0:\n        return float(v0)\n\n    with np.errstate(divide='ignore', invalid='ignore'):\n        vb = v0 + ((self.value_array - xp.dot(self.belief_array, self.corner_values)) * xp.min(belief.values / self.belief_array, axis=1))\n\n    return float(xp.min(xp.append(vb, v0)))\n</code></pre>"},{"location":"reference/agents/model_based_util/belief_value_mapping/#olfactory_navigation.agents.model_based_util.belief_value_mapping.BeliefValueMapping.update","title":"<code>update()</code>","text":"<p>Function to update the belief and value arrays to speed up computation.</p> Source code in <code>olfactory_navigation/agents/model_based_util/belief_value_mapping.py</code> <pre><code>def update(self) -&gt; None:\n    '''\n    Function to update the belief and value arrays to speed up computation.\n    '''\n    xp = np if not gpu_support else cp.get_array_module(self.beliefs[0].values)\n\n    self._belief_array = xp.array([b.values for b in self.beliefs])\n    self._value_array = xp.array(list(self.belief_value_mapping.values()))\n</code></pre>"},{"location":"reference/agents/model_based_util/environment_converter/","title":"environment_converter","text":""},{"location":"reference/agents/model_based_util/environment_converter/#olfactory_navigation.agents.model_based_util.environment_converter.exact_converter","title":"<code>exact_converter(agent)</code>","text":"<p>Method to create a POMDP model based on an olfactory environment object.</p> <p>This version of the converter converts the environment in an exact manner. This mean the amount of states is equal to the grid points in the olfactory environment object.</p> <p>It supports an environment in 2D, with or without layers. It supports a variety of different action sets from the agent.</p> <p>It also defines at least 3 different observations: Nothing, Something or Goal. However, if multiple thresholds are provided, the more observations will be available: |threshold| + 1 (Nothing) + 1 (Goal)</p> <p>Note: The environment and the threshold parameters are gathered from the agent instance provided.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>The agent to use to get the environment and threshold parameters from.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Model</code> <p>A generate POMDP model from the environment.</p> Source code in <code>olfactory_navigation/agents/model_based_util/environment_converter.py</code> <pre><code>def exact_converter(agent : Agent) -&gt; Model:\n    '''\n    Method to create a POMDP model based on an olfactory environment object.\n\n    This version of the converter converts the environment in an exact manner.\n    This mean the amount of states is equal to the grid points in the olfactory environment object.\n\n    It supports an environment in 2D, with or without layers. It supports a variety of different action sets from the agent.\n\n    It also defines at least 3 different observations: Nothing, Something or Goal.\n    However, if multiple thresholds are provided, the more observations will be available: |threshold| + 1 (Nothing) + 1 (Goal)\n\n    Note: The environment and the threshold parameters are gathered from the agent instance provided.\n\n    Parameters\n    ----------\n    agent : Agent\n        The agent to use to get the environment and threshold parameters from.\n\n    Returns\n    -------\n    model : Model\n        A generate POMDP model from the environment.\n    '''\n    # Agent's parameters\n    environment = agent.environment\n    thresholds = agent.thresholds\n    action_set = agent.action_set\n\n    # Assertions\n    assert environment.dimensions == 2, \"This converter only works for 2D environments...\" # TODO: implement for ND\n    assert not agent.space_aware, \"This model is not compatible with space_aware agents as the observations would not match the expected observations of this model.\"\n\n    # Base Model parameters\n    state_count = np.prod(environment.shape)\n\n    state_grid = [[f's_{x}_{y}' for x in range(environment.shape[1])] for y in range(environment.shape[0])]\n    end_states = np.argwhere(np.fromfunction(lambda x,y: ((x-environment.source_position[0])**2 + (y-environment.source_position[1])**2) &lt;= environment.source_radius**2,\n                                                shape=environment.shape).ravel())[:,0].tolist()\n\n    # Counts\n    action_count = len(agent.action_set)\n    observation_count = thresholds.shape[-1] # Thresholds minus 1; plus 1 for the goal.\n\n    # Computing odor probabilities\n    odor_fields = None\n    data_bounds_slices = tuple(slice(low, high) for low, high in environment.data_bounds)\n    if environment.has_layers:\n        odor_fields = []\n        for layer in environment.layers:\n            data_grid = environment.data[layer,:,:,:,None]\n            threshs = thresholds[layer] if len(thresholds.shape) == 2 else thresholds\n            data_odor_fields = np.average(((data_grid &gt;= threshs[:-1][None,None,None,:]) &amp; (data_grid &lt; threshs[1:][None,None,None,:])), axis=0)\n\n            # Increasing it to the full environment\n            field = np.zeros(environment.shape + (observation_count-1,))\n            field[*data_bounds_slices, :] = data_odor_fields\n\n            odor_fields.append(field)\n\n    else:\n        data_grid = environment.data[:,:,:,None]\n        threshs = thresholds\n        data_odor_fields = np.average(((data_grid &gt;= threshs[:-1][None,None,None,:]) &amp; (data_grid &lt; threshs[1:][None,None,None,:])), axis=0)\n\n        # Increasing it to the full environment\n        odor_fields = np.zeros(environment.shape + (observation_count-1,))\n        odor_fields[*data_bounds_slices, :] = data_odor_fields\n\n    # Building observation matrix\n    observations = np.empty((state_count, action_count, observation_count), dtype=float)\n    for o in range(observation_count-1): # Skipping the goal observation\n        for a, action_vector in enumerate(action_set):\n            if environment.has_layers:\n                action_layer = action_vector[0]\n                observations[:,a,o] = odor_fields[action_layer][:,:,o].ravel()\n            else:\n                observations[:,a,o] = odor_fields[:,:,o].ravel()\n\n    # Setting 'Nothing' observation in the margins to 1\n    data_margins_mask = np.ones(environment.shape, dtype=bool)\n    data_margins_mask[data_bounds_slices] = False\n    observations[data_margins_mask.ravel(),:,0] = 1.0\n\n    # Goal observation\n    observations[:,:,-1] = 0.0\n    observations[end_states,:,:] = 0.0\n    observations[end_states,:,-1] = 1.0\n\n    # Assert observations sum to 1\n    assert np.all(np.sum(observations, axis=2) == 1.0), \"Observation table malformed, something is wrong...\"\n\n    # Observation labels\n    observation_labels = ['nothing']\n    if thresholds.shape[-1] &gt; 3:\n        for i in range(thresholds.shape[-1] - 2):\n            observation_labels.append(f'something_l{i}')\n    else:\n        observation_labels.append('something')\n    observation_labels.append('goal')\n\n    # Compute reachable states\n    shape = environment.shape\n\n    points = np.array(np.unravel_index(np.arange(np.prod(shape)), shape)).T\n\n    # For each actions compute all new grid points (using the environment.move method)\n    action_new_states = []\n    movements = action_set if not environment.has_layers else action_set[:,1:]\n    for move_vector in movements:\n        new_points = environment.move(points, movement=move_vector[None,:])\n        new_states = np.ravel_multi_index((new_points[:,0], new_points[:,1]), dims=shape)\n        action_new_states.append(new_states)\n\n    # Forming it the reachable states array from the new states for each action\n    reachable_states = np.array(action_new_states).T[:,:,None]\n\n    # Instantiate the model object\n    model = Model(\n        states=state_grid,\n        actions=agent.action_labels,\n        observations=observation_labels,\n        reachable_states=reachable_states,\n        observation_table=observations,\n        end_states=end_states,\n        start_probabilities=environment.start_probabilities.ravel(),\n        seed=agent.seed\n    )\n    return model\n</code></pre>"},{"location":"reference/agents/model_based_util/environment_converter/#olfactory_navigation.agents.model_based_util.environment_converter.minimal_converter","title":"<code>minimal_converter(agent, partitions=[3, 6], margin_partitions=False)</code>","text":"<p>Method to create a POMDP Model based on an olfactory environment  object.</p> <p>This version of the converted, attempts to build a minimal version of the environment with just a few partitions in the x and y direction. This means the model will the a total of n states with n = ((|x-partitions| + 2) * (|y-partitions| + 2)). The +2 corresponds to two margin cells in the x and y axes.</p> <p>It supports an environment in 2D and therefore defines 4 available actions for the agent. (north, east, south, west) But, since the model contains so few spaces, the transitions between states are not deterministic: This means, if an agent takes a step in a direction, there is a chance the agent stays in the same state along with a lower chance the agent moves to a state in the actual direction it was meaning to go.</p> <p>It also defines at least 3 different observations: Nothing, Something or Goal. However, if multiple thresholds are provided, the more observations will be available: |threshold| + 1 (Nothing) + 1 (Goal)</p> <p>Note: The environment and the threshold parameters are gathered from the agent instance provided.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>The agent to use to get the environment and threshold parameters from.</p> required <code>partitions</code> <code>list or ndarray</code> <p>How many partitions to use in respectively the y and x directions.</p> <code>[3,6]</code> <code>margin_partitions</code> <code>bool</code> <p>Whether to have seperate partitions for the margins or not. In the case it is enabled, +2 partitions are added in each dimensions.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>model</code> <code>Model</code> <p>A generated POMDP model from the environment.</p> Source code in <code>olfactory_navigation/agents/model_based_util/environment_converter.py</code> <pre><code>def minimal_converter(agent : Agent,\n                      partitions: list | np.ndarray = [3,6],\n                      margin_partitions: bool = False\n                      ) -&gt; Model:\n    '''\n    Method to create a POMDP Model based on an olfactory environment  object.\n\n    This version of the converted, attempts to build a minimal version of the environment with just a few partitions in the x and y direction.\n    This means the model will the a total of n states with n = ((|x-partitions| + 2) * (|y-partitions| + 2)).\n    The +2 corresponds to two margin cells in the x and y axes.\n\n    It supports an environment in 2D and therefore defines 4 available actions for the agent. (north, east, south, west)\n    But, since the model contains so few spaces, the transitions between states are not deterministic:\n    This means, if an agent takes a step in a direction, there is a chance the agent stays in the same state along with a lower chance the agent moves to a state in the actual direction it was meaning to go.\n\n    It also defines at least 3 different observations: Nothing, Something or Goal.\n    However, if multiple thresholds are provided, the more observations will be available: |threshold| + 1 (Nothing) + 1 (Goal)\n\n    Note: The environment and the threshold parameters are gathered from the agent instance provided.\n\n    Parameters\n    ----------\n    agent : Agent\n        The agent to use to get the environment and threshold parameters from.\n    partitions : list or np.ndarray, default=[3,6]\n        How many partitions to use in respectively the y and x directions.\n    margin_partitions : bool, default=False\n        Whether to have seperate partitions for the margins or not. In the case it is enabled, +2 partitions are added in each dimensions.\n\n    Returns\n    -------\n    model : Model\n        A generated POMDP model from the environment.\n    '''\n    # Agent's parameters\n    environment = agent.environment\n    thresholds = agent.thresholds\n    action_set = agent.action_set\n\n    shape = environment.shape\n\n    # Assertions\n    assert not agent.space_aware, \"This model is not compatible with space_aware agents as the observations would not match the expected observations of this model.\"\n    assert not (len(agent.thresholds.shape) == 2), \"This model doesnt allow for layer specific thresholds.\"\n\n    # Getting probabilities of odor in the requested partitions and mapping grid to cells\n    partitions = np.array(partitions)\n\n    # Building cell bounds\n    if margin_partitions:\n        cell_shape = (environment.data_shape / partitions).astype(int)\n        cell_bounds = [np.array([0, *((np.arange(ax_part+1) * cell_shape[ax_i]) + environment.margins[ax_i, 0]), shape[ax_i]]) for ax_i, ax_part in enumerate(partitions)]\n        cell_counts = int(np.prod(partitions + 2)) # Add 2 in each dimensions\n    else:\n        cell_shape = (shape / partitions).astype(int)\n        cell_bounds = [np.array(np.arange(ax_part+1) * cell_shape[ax_i]) for ax_i, ax_part in enumerate(partitions)]\n        cell_counts = int(np.prod(partitions))\n\n    lower_bounds = np.array([ax_arr.ravel() for ax_arr in np.meshgrid(*[bounds_arr[:-1] for bounds_arr in cell_bounds], indexing='xy')]).T\n    upper_bounds = np.array([ax_arr.ravel() for ax_arr in np.meshgrid(*[bounds_arr[1 :] for bounds_arr in cell_bounds], indexing='xy')]).T\n\n    # Building an array mapping cell ids to the original grid\n    grid_cells = np.ones(shape) * -1\n    for i, (lower_b, upper_b) in enumerate(zip(lower_bounds, upper_bounds)):\n        slices = [slice(ax_lower, ax_upper) for ax_lower, ax_upper in zip(lower_b, upper_b)]\n\n        # Grid to cell mapping\n        grid_cells[*slices] = i\n\n    # Building transition probabilities\n    points = np.array(np.unravel_index(np.arange(np.prod(shape)), shape)).T\n    transition_probabilities = np.full((cell_counts+1, len(action_set), cell_counts+1), -1, dtype=float)\n\n    movements = (action_set if not environment.has_layers else action_set[:,1:])\n    for a, move_vector in enumerate(movements):\n        new_points = environment.move(points, movement=move_vector[None,:])\n        for state_cell in np.arange(cell_counts):\n            points_in_cell = (grid_cells[*points.T] == state_cell)[:,None]\n            count_in_cell = np.sum(points_in_cell)\n\n            next_cells = np.arange(cell_counts)\n            points_in_next_cell = (grid_cells[*new_points.T,None] == next_cells[None,:])\n\n            at_source = environment.source_reached(new_points)[:,None]\n\n            transition_probabilities[state_cell, a, next_cells] = np.sum(((points_in_cell &amp; (~at_source)) &amp; points_in_next_cell), axis=0) / count_in_cell\n            transition_probabilities[state_cell, a, -1] = np.sum(points_in_cell &amp; at_source) / count_in_cell\n\n    transition_probabilities[-1,:,:] = 0.0\n    transition_probabilities[-1,:,-1] = 1.0\n\n    # Observation labels\n    observation_labels = ['nothing']\n    if thresholds.shape[-1] &gt; 3:\n        for i in range(thresholds.shape[-1] - 2):\n            observation_labels.append(f'something_l{i}')\n    else:\n        observation_labels.append('something')\n    observation_labels.append('goal')\n\n    # Observation probabilities\n    observations = np.zeros((cell_counts+1, len(action_set), len(observation_labels)))\n\n    # Recomputing bounds for data zone only\n    data_cell_bounds = [np.array([*(np.arange(ax_part+1) * cell_shape[ax_i])]) for ax_i, ax_part in enumerate(partitions)]\n\n    data_lower_bounds = np.array([ax_arr.ravel() for ax_arr in np.meshgrid(*[bounds_arr[:-1] for bounds_arr in data_cell_bounds], indexing='xy')]).T\n    data_upper_bounds = np.array([ax_arr.ravel() for ax_arr in np.meshgrid(*[bounds_arr[1 :] for bounds_arr in data_cell_bounds], indexing='xy')]).T\n\n    cell_observations = []\n    for lower_b, upper_b in zip(data_lower_bounds, data_upper_bounds):\n        slices = [slice(ax_lower, ax_upper) for ax_lower, ax_upper in zip(lower_b, upper_b)]\n\n        observations_levels = []\n        for min_thresh, max_thresh in zip(thresholds[:-1], thresholds[1:]):\n            if environment.has_layers: # TODO: Adapt to different layer thresholding\n                odor_within_thresh = (environment.data[:,:,*slices] &gt; min_thresh) &amp; (environment.data[:,:,*slices] &lt; max_thresh)\n                observations_levels.append(np.average(odor_within_thresh, axis=tuple([a+1 for a in range(environment.dimensions + 1)])))\n            else:\n                odor_within_thresh = (environment.data[:,*slices] &gt; min_thresh) &amp; (environment.data[:,*slices] &lt; max_thresh)\n                observations_levels.append(np.average(odor_within_thresh))\n\n        cell_observations.append(observations_levels)\n\n    # Placing observation probabilities in observation matrix\n    data_cell_ids = np.arange(cell_counts).reshape(partitions+2)[1:-1,1:-1].ravel()\n    observations[:-1,:,0] = 1.0 # Nothing at 1 everywhere\n    if environment.has_layers:\n        action_layers = action_set[:,0]\n        actions = np.arange(len(action_layers))\n        for i, cell_id in enumerate(data_cell_ids):\n            for o in range(len(observation_labels) - 1):\n                observations[cell_id,actions,o] = cell_observations[i][o][action_layers]\n    else:\n        for i, cell_id in enumerate(data_cell_ids):\n            observations[cell_id,:,:-1] = cell_observations[i]\n\n    observations[-1,:,-1] = 1.0 # Goal\n\n    # Start probabilities # TODO Match data zone\n    start_probabilities = np.ones(cell_counts+1, dtype=float)\n    # start_probabilities = (odor_probabilities &gt; 0).astype(float).flatten()\n    start_probabilities /= np.sum(start_probabilities)\n\n    # Creation of the Model\n    model = Model(\n        states = [f'cell_{cell}' for cell in range(cell_counts)] + ['goal'],\n        actions = agent.action_labels,\n        observations = observation_labels,\n        transitions = transition_probabilities,\n        observation_table = observations,\n        end_states = [cell_counts], # The very last state is the goal state\n        start_probabilities = start_probabilities,\n        seed=agent.seed\n    )\n\n    return model\n</code></pre>"},{"location":"reference/agents/model_based_util/mdp/","title":"mdp","text":""},{"location":"reference/agents/model_based_util/mdp/#olfactory_navigation.agents.model_based_util.mdp.Model","title":"<code>Model</code>","text":"<p>MDP Model class.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>int or list[str] or list[list[str]]</code> <p>A list of state labels or an amount of states to be used. Also allows to provide a matrix of states to define a grid model.</p> required <code>actions</code> <code>int or list</code> <p>A list of action labels or an amount of actions to be used.</p> required <code>transitions</code> <code>array - like or function</code> <p>The transitions between states, an array can be provided and has to be |S| x |A| x |S| or a function can be provided.  If a function is provided, it has be able to deal with np.array arguments. If none is provided, it will be randomly generated.</p> <code>None</code> <code>reachable_states</code> <code>array - like</code> <p>A list of states that can be reached from each state and actions. It must be a matrix of size |S| x |A| x |R| where |R| is the max amount of states reachable from any given state and action pair. It is optional but useful for speedup purposes.</p> <code>None</code> <code>rewards</code> <code>array - like or function</code> <p>The reward matrix, has to be |S| x |A| x |S|. A function can also be provided here but it has to be able to deal with np.array arguments. If provided, it will be use in combination with the transition matrix to fill to expected rewards.</p> <code>None</code> <code>rewards_are_probabilistic</code> <code>bool</code> <p>Whether the rewards provided are probabilistic or pure rewards. If probabilist 0 or 1 will be the reward with a certain probability.</p> <code>False</code> <code>state_grid</code> <code>array - like</code> <p>If provided, the model will be converted to a grid model.</p> <code>None</code> <code>start_probabilities</code> <code>list</code> <p>The distribution of chances to start in each state. If not provided, there will be an uniform chance for each state.</p> <code>None</code> <code>end_states</code> <code>list</code> <p>Entering either state in the list during a simulation will end the simulation.</p> <code>[]</code> <code>end_actions</code> <code>list</code> <p>Playing action of the list during a simulation will end the simulation.</p> <code>[]</code> <code>print_debug</code> <code>bool</code> <p>Whether to print debug logs about the creation progress of the MDP Model.</p> <code>False</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <p>Attributes:</p> Name Type Description <code>states</code> <code>ndarray</code> <p>A 1D array of states indices. Used to loop over states.</p> <code>state_labels</code> <code>list[str]</code> <p>A list of state labels. (To be mainly used for plotting)</p> <code>state_count</code> <code>int</code> <p>How many states are in the Model.</p> <code>state_grid</code> <code>ndarray</code> <p>The state indices organized as a 2D grid. (Used for plotting purposes)</p> <code>actions</code> <code>ndarry</code> <p>A 1D array of action indices. Used to loop over actions.</p> <code>action_labels</code> <code>list[str]</code> <p>A list of action labels. (To be mainly used for plotting)</p> <code>action_count</code> <code>int</code> <p>How many action are in the Model.</p> <code>transition_table</code> <code>ndarray</code> <p>A 3D matrix of the transition probabilities. Can be None in the case a transition function is provided instead. Note: When possible, use reachable states and reachable probabilities instead.</p> <code>transition_function</code> <code>function</code> <p>A callable function taking 3 arguments: s, a, s_p; and returning a float between 0.0 and 1.0. Can be None in the case a transition table is provided instead. Note: When possible, use reachable states and reachable probabilities instead.</p> <code>reachable_states</code> <code>ndarray</code> <p>A 3D array of the shape S x A x R, where R is max amount to states that can be reached from any state-action pair.</p> <code>reachable_probabilities</code> <code>ndarray</code> <p>A 3D array of the same shape as reachable_states, the array represent the probability of reaching the state pointed by the reachable_states matrix.</p> <code>reachable_state_count</code> <code>int</code> <p>The maximum of states that can be reached from any state-action combination.</p> <code>immediate_reward_table</code> <code>ndarray</code> <p>A 3D matrix of shape S x A x S of the reward that will received when taking action a, in state s and landing in state s_p. Can be None in the case an immediate rewards function is provided instead.</p> <code>immediate_reward_function</code> <code>function</code> <p>A callable function taking 3 argments: s, a, s_p and returning the immediate reward the agent will receive. Can be None in the case an immediate rewards function is provided instead.</p> <code>expected_reward_table</code> <code>ndarray</code> <p>A 2D array of shape S x A. It represents the rewards that is expected to be received when taking action a from state s. It is made by taking the weighted average of immediate rewards and the transitions.</p> <code>start_probabilities</code> <code>ndarray</code> <p>A 1D array of length |S| containing the probility distribution of the agent starting in each state.</p> <code>rewards_are_probabilisitic</code> <code>bool</code> <p>Whether the immediate rewards are probabilitic, ie: returning a 0 or 1 based on the reward that is considered to be a probability.</p> <code>end_states</code> <code>list[int]</code> <p>A list of states that, when reached, terminate a simulation.</p> <code>end_actions</code> <code>list[int]</code> <p>A list of actions that, when taken, terminate a simulation.</p> <code>is_on_gpu</code> <code>bool</code> <p>Whether the numpy array of the model are stored on the gpu or not.</p> <code>gpu_model</code> <code>Model</code> <p>An equivalent model with the np.ndarray objects on GPU. (If already on GPU, returns self)</p> <code>cpu_model</code> <code>Model</code> <p>An equivalent model with the np.ndarray objects on CPU. (If already on CPU, returns self)</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> Source code in <code>olfactory_navigation/agents/model_based_util/mdp.py</code> <pre><code>class Model:\n    '''\n    MDP Model class.\n\n\n    Parameters\n    ----------\n    states : int or list[str] or list[list[str]]\n        A list of state labels or an amount of states to be used. Also allows to provide a matrix of states to define a grid model.\n    actions : int or list\n        A list of action labels or an amount of actions to be used.\n    transitions : array-like or function, optional\n        The transitions between states, an array can be provided and has to be |S| x |A| x |S| or a function can be provided. \n        If a function is provided, it has be able to deal with np.array arguments.\n        If none is provided, it will be randomly generated.\n    reachable_states : array-like, optional\n        A list of states that can be reached from each state and actions. It must be a matrix of size |S| x |A| x |R| where |R| is the max amount of states reachable from any given state and action pair.\n        It is optional but useful for speedup purposes.\n    rewards : array-like or function, optional\n        The reward matrix, has to be |S| x |A| x |S|.\n        A function can also be provided here but it has to be able to deal with np.array arguments.\n        If provided, it will be use in combination with the transition matrix to fill to expected rewards.\n    rewards_are_probabilistic : bool, default=False\n        Whether the rewards provided are probabilistic or pure rewards. If probabilist 0 or 1 will be the reward with a certain probability.\n    state_grid : array-like, optional\n        If provided, the model will be converted to a grid model.\n    start_probabilities : list, optional\n        The distribution of chances to start in each state. If not provided, there will be an uniform chance for each state.\n    end_states : list, optional\n        Entering either state in the list during a simulation will end the simulation.\n    end_actions : list, optional\n        Playing action of the list during a simulation will end the simulation.\n    print_debug : bool, default=False\n        Whether to print debug logs about the creation progress of the MDP Model.\n    seed : int, default=12131415\n        For reproducible randomness.\n\n    Attributes\n    ----------\n    states : np.ndarray\n        A 1D array of states indices. Used to loop over states.\n    state_labels : list[str]\n        A list of state labels. (To be mainly used for plotting)\n    state_count : int\n        How many states are in the Model.\n    state_grid : np.ndarray\n        The state indices organized as a 2D grid. (Used for plotting purposes)\n    actions : np.ndarry\n        A 1D array of action indices. Used to loop over actions.\n    action_labels : list[str]\n        A list of action labels. (To be mainly used for plotting)\n    action_count : int\n        How many action are in the Model.\n    transition_table : np.ndarray\n        A 3D matrix of the transition probabilities.\n        Can be None in the case a transition function is provided instead.\n        Note: When possible, use reachable states and reachable probabilities instead.\n    transition_function : function\n        A callable function taking 3 arguments: s, a, s_p; and returning a float between 0.0 and 1.0.\n        Can be None in the case a transition table is provided instead.\n        Note: When possible, use reachable states and reachable probabilities instead.\n    reachable_states : np.ndarray\n        A 3D array of the shape S x A x R, where R is max amount to states that can be reached from any state-action pair.\n    reachable_probabilities : np.ndarray\n        A 3D array of the same shape as reachable_states, the array represent the probability of reaching the state pointed by the reachable_states matrix.\n    reachable_state_count : int\n        The maximum of states that can be reached from any state-action combination.\n    immediate_reward_table : np.ndarray\n        A 3D matrix of shape S x A x S of the reward that will received when taking action a, in state s and landing in state s_p.\n        Can be None in the case an immediate rewards function is provided instead.\n    immediate_reward_function : function\n        A callable function taking 3 argments: s, a, s_p and returning the immediate reward the agent will receive.\n        Can be None in the case an immediate rewards function is provided instead.\n    expected_reward_table : np.ndarray\n        A 2D array of shape S x A. It represents the rewards that is expected to be received when taking action a from state s.\n        It is made by taking the weighted average of immediate rewards and the transitions.\n    start_probabilities : np.ndarray\n        A 1D array of length |S| containing the probility distribution of the agent starting in each state.\n    rewards_are_probabilisitic : bool\n        Whether the immediate rewards are probabilitic, ie: returning a 0 or 1 based on the reward that is considered to be a probability.\n    end_states : list[int]\n        A list of states that, when reached, terminate a simulation.\n    end_actions : list[int]\n        A list of actions that, when taken, terminate a simulation.\n    is_on_gpu : bool\n        Whether the numpy array of the model are stored on the gpu or not.\n    gpu_model : mdp.Model\n        An equivalent model with the np.ndarray objects on GPU. (If already on GPU, returns self)\n    cpu_model : mdp.Model\n        An equivalent model with the np.ndarray objects on CPU. (If already on CPU, returns self)\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    '''\n    def __init__(self,\n                 states: int | list[str] | list[list[str]],\n                 actions: int | list,\n                 transitions = None,\n                 reachable_states = None,\n                 rewards = None,\n                 rewards_are_probabilistic: bool = False,\n                 state_grid = None,\n                 start_probabilities: list | None = None,\n                 end_states: list[int] = [],\n                 end_actions: list[int] = [],\n                 print_debug: bool = False,\n                 seed: int = 12131415\n                 ) -&gt; None:\n        # Debug logger\n        def logger(content: str):\n            if print_debug:\n                log(content=content)\n\n        # Empty variable\n        self._alt_model = None\n        self.is_on_gpu = False\n\n        # Random variable\n        self.seed = seed\n        self.rnd_state = np.random.RandomState(seed = seed)\n\n        logger('Instantiation of MDP Model:')\n\n        # ------------------------- States -------------------------\n        self.state_grid = None\n        if isinstance(states, int): # State count\n            self.state_labels = [f's_{i}' for i in range(states)]\n\n        elif isinstance(states, list) and all(isinstance(item, list) for item in states): # 2D list of states\n            dim1 = len(states)\n            dim2 = len(states[0])\n            assert all(len(state_dim) == dim2 for state_dim in states), \"All sublists of states must be of equal size\"\n\n            self.state_labels = []\n            for state_dim in states:\n                for state in state_dim:\n                    self.state_labels.append(state)\n\n            self.state_grid = np.arange(dim1 * dim2).reshape(dim1, dim2)\n\n        else: # Default: single of list of string items\n            self.state_labels = [item for item in states if isinstance(item, str)]\n\n        self.state_count = len(self.state_labels)\n        self.states = np.arange(self.state_count)\n\n        logger(f'- {self.state_count} states')\n\n        # ------------------------- Actions -------------------------\n        if isinstance(actions, int):\n            self.action_labels = [f'a_{i}' for i in range(actions)]\n        else:\n            self.action_labels = actions\n        self.action_count = len(self.action_labels)\n        self.actions = np.arange(self.action_count)\n\n        logger(f'- {self.action_count} actions')\n\n        # ------------------------- Reachable states provided -------------------------\n        self.reachable_states = None\n        if reachable_states is not None:\n            self.reachable_states = np.array(reachable_states)\n            assert self.reachable_states.shape[:2] == (self.state_count, self.action_count), f\"Reachable states provided is not of the expected shape (received {self.reachable_states.shape}, expected ({self.state_count}, {self.action_count}, :))\"\n            self.reachable_state_count = self.reachable_states.shape[2]\n\n            logger(f'- At most {self.reachable_state_count} reachable states per state-action pair')\n\n        # ------------------------- Transitions -------------------------\n        logger('- Starting generation of transitions table')\n        start_ts = datetime.now()\n\n        self.transition_table = None\n        self.transition_function = None\n        if transitions is None:\n            if reachable_states is None:\n                # If no transitiong matrix and no reachable states given, generate random one\n                logger('    &gt; [Warning] No transition matrix and no reachable states have provided so a random transition matrix is generated...')\n                random_probs = self.rnd_state.random((self.state_count, self.action_count, self.state_count))\n\n                # Normalization to have s_p probabilies summing to 1\n                self.transition_table = random_probs / np.sum(random_probs, axis=2, keepdims=True)\n            else:\n                # Make uniform transition probabilities over reachable states\n                logger(f'    &gt; [Warning] No transition matrix or function provided but reachable states are, so probability to reach any reachable states will \"1 / reachable state count\" so here: {1/self.reachable_state_count:.3f}.')\n\n        elif callable(transitions): # Transition function\n            self.transition_function = transitions\n            # Attempt to create transition table in memory\n            t_arr = None\n            try:\n                t_arr = np.fromfunction(self.transition_function, (self.state_count, self.action_count, self.state_count))\n            except MemoryError:\n                logger('    &gt; [Warning] Not enough memory to store transition table, using transition function provided...')\n            else:\n                self.transition_table = t_arr\n\n        else: # Array like\n            self.transition_table = np.array(transitions)\n            t_shape = self.transition_table.shape\n            exp_shape = (self.state_count, self.action_count, self.state_count)\n            assert t_shape == exp_shape, f\"Transitions table provided doesnt have the right shape, it should be SxAxS (expected {exp_shape}, received {t_shape})\"\n\n        duration = (datetime.now() - start_ts).total_seconds()\n        logger(f'    &gt; Done in {duration:.3f}s')\n        if duration &gt; 1:\n            logger(f'    &gt; [Warning] Transition table generation took long, if not done already, try to use the reachable_states parameter to speedup the process.')\n\n        # ------------------------- Rewards are probabilistic toggle -------------------------\n        self.rewards_are_probabilistic = rewards_are_probabilistic\n\n        # ------------------------- State grid -------------------------\n        logger('- Generation of state grid')\n        if state_grid is None and self.state_grid is None:\n            self.state_grid = np.arange(self.state_count).reshape((1,self.state_count))\n\n        elif state_grid is not None:\n            assert all(isinstance(l, list) for l in state_grid), \"The provided states grid must be a list of lists.\"\n\n            grid_shape = (len(state_grid), len(state_grid[0]))\n            assert all(len(l) == grid_shape[1] for l in state_grid), \"All rows must have the same length.\"\n\n            if all(all(isinstance(e, int) for e in l) for l in state_grid):\n                state_grid = np.array(state_grid)\n                try:\n                    self.states[state_grid]\n                except:\n                    raise Exception('An error occured with the list of state indices provided...')\n                else:\n                    self.state_grid = state_grid\n\n            else:\n                logger('    &gt; [Warning] Looping through all grid states provided to find the corresponding states, can take a while...')\n\n                np_state_grid = np.zeros(grid_shape, dtype=int)\n                states_covered = 0\n                for i, row in enumerate(state_grid):\n                    for j, element in enumerate(state_grid):\n                        if isinstance(element, str) and (element in self.state_labels):\n                            states_covered += 1\n                            np_state_grid[i,j] = self.state_labels.index(element)\n                        elif isinstance(element, int) and (element &lt; self.state_count):\n                            np_state_grid[i,j] = element\n\n                        else:\n                            raise Exception(f'Countains a state (\\'{state}\\') not in the list of states...')\n\n                assert states_covered == self.state_count, \"Some states of the state list are missing...\"\n\n        # ------------------------- Start state probabilities -------------------------\n        logger('- Generating start probabilities table')\n        if start_probabilities is not None:\n            assert len(start_probabilities) == self.state_count\n            self.start_probabilities = np.array(start_probabilities,dtype=float)\n        else:\n            self.start_probabilities = np.full((self.state_count), 1/self.state_count)\n\n        # ------------------------- End state conditions -------------------------\n        self.end_states = end_states\n        self.end_actions = end_actions\n\n        # ------------------------- Reachable states -------------------------\n        # If not set yet\n        if self.reachable_states is None:\n            logger('- Starting computation of reachable states from transition data')\n\n            if self.state_count &gt; 1000:\n                logger('-    &gt; [Warning] For models with large amounts of states, this operation can take time. Try generating it advance and use the parameter \\'reachable_states\\'...')\n\n            start_ts = datetime.now()\n\n            self.reachable_states = []\n            self.reachable_state_count = 0\n            for s in self.states:\n                reachable_states_for_action = []\n                for a in self.actions:\n                    reachable_list = []\n                    if self.transition_table is not None:\n                        reachable_list = np.argwhere(self.transition_table[s,a,:] &gt; 0)[:,0].tolist()\n                    else:\n                        for sn in self.states:\n                            if self.transition_function(s,a,sn) &gt; 0:\n                                reachable_list.append(sn)\n                    reachable_states_for_action.append(reachable_list)\n\n                    if len(reachable_list) &gt; self.reachable_state_count:\n                        self.reachable_state_count = len(reachable_list)\n\n                self.reachable_states.append(reachable_states_for_action)\n\n            # In case some state-action pairs lead to more states than other, we fill with the 1st non states not used\n            for s in self.states:\n                for a in self.actions:\n                    to_add = 0\n                    while len(self.reachable_states[s][a]) &lt; self.reachable_state_count:\n                        if to_add not in self.reachable_states[s][a]:\n                            self.reachable_states[s][a].append(to_add)\n                        to_add += 1\n\n            # Converting to ndarray\n            self.reachable_states = np.array(self.reachable_states, dtype=int)\n\n            duration = (datetime.now() - start_ts).total_seconds()\n            logger(f'    &gt; Done in {duration:.3f}s')\n            logger(f'- At most {self.reachable_state_count} reachable states per state-action pair')\n\n        # ------------------------- Reachable state probabilities -------------------------\n        logger('- Starting computation of reachable state probabilities from transition data')\n        start_ts = datetime.now()\n\n        if self.transition_function is None and self.transition_table is None:\n            self.reachable_probabilities = np.full(self.reachable_states.shape, 1/self.reachable_state_count)\n        elif self.transition_table is not None:\n            self.reachable_probabilities = self.transition_table[self.states[:,None,None], self.actions[None,:,None], self.reachable_states]\n        else:\n            self.reachable_probabilities = np.fromfunction((lambda s,a,ri: self.transition_function(s.astype(int), a.astype(int), self.reachable_states[s.astype(int), a.astype(int), ri.astype(int)])), self.reachable_states.shape)\n\n        duration = (datetime.now() - start_ts).total_seconds()\n        logger(f'    &gt; Done in {duration:.3f}s')\n\n        # ------------------------- Rewards -------------------------\n        self.immediate_reward_table = None\n        self.immediate_reward_function = None\n        if rewards == -1: # If -1 is set, it means the rewards are defined in the superclass POMDP\n            pass\n        elif rewards is None:\n            if (len(self.end_states) &gt; 0) or (len(self.end_actions) &gt; 0):\n                logger('- [Warning] Rewards are not define but end states/actions are, reaching an end state or doing an end action will give a reward of 1.')\n                self.immediate_reward_function = self._end_reward_function\n            else:\n                # If no reward matrix given, generate random one\n                self.immediate_reward_table = self.rnd_state.random((self.state_count, self.action_count, self.state_count))\n        elif callable(rewards):\n            # Rewards is a function\n            logger('- [Warning] The rewards are provided as a function, if the model is saved, the rewards will need to be defined before loading model.')\n            logger('    &gt; Alternative: Setting end states/actions and leaving the rewards can be done to make the end states/action giving a reward of 1 by default.')\n            self.immediate_reward_function = rewards\n            assert len(signature(rewards).parameters) == 3, \"Reward function should accept 3 parameters: s, a, sn...\"\n        else:\n            # Array like\n            self.immediate_reward_table = np.array(rewards)\n            r_shape = self.immediate_reward_table.shape\n            exp_shape = (self.state_count, self.action_count, self.state_count)\n            assert r_shape == exp_shape, f\"Rewards table doesnt have the right shape, it should be SxAxS (expected: {exp_shape}, received {r_shape})\"\n\n        # ------------------------- Min and max rewards -------------------------\n        self._min_reward = None\n        self._max_reward = None\n\n        # ------------------------- Expected rewards -------------------------\n        self.expected_rewards_table = None\n        if rewards != -1:\n            logger('- Starting generation of expected rewards table')\n            start_ts = datetime.now()\n\n            reachable_rewards = None\n            if self.immediate_reward_table is not None:\n                reachable_rewards = self.immediate_reward_table[self.states[:,None,None], self.actions[None,:,None], self.reachable_states]\n            else:\n                def reach_reward_func(s,a,ri):\n                    s = s.astype(int)\n                    a = a.astype(int)\n                    ri = ri.astype(int)\n                    return self.immediate_reward_function(s,a,self.reachable_states[s,a,ri])\n\n                reachable_rewards = np.fromfunction(reach_reward_func, self.reachable_states.shape)\n\n            self._min_reward = float(np.min(reachable_rewards))\n            self._max_reward = float(np.max(reachable_rewards))\n\n            self.expected_rewards_table = np.einsum('sar,sar-&gt;sa', self.reachable_probabilities, reachable_rewards)\n\n            duration = (datetime.now() - start_ts).total_seconds()\n            logger(f'    &gt; Done in {duration:.3f}s')\n\n\n    def _end_reward_function(self, s, a, sn):\n        return (np.isin(sn, self.end_states) | np.isin(a, self.end_actions)).astype(int)\n\n\n    def transition(self,\n                   s: int,\n                   a: int\n                   ) -&gt; int:\n        '''\n        Returns a random posterior state knowing we take action a in state t and weighted on the transition probabilities.\n\n        Parameters\n        ----------\n        s : int \n            The current state\n        a : int\n            The action to take\n\n        Returns\n        -------\n        s_p : int\n            The posterior state\n        '''\n        xp = cp if self.is_on_gpu else np\n\n        # Shortcut for deterministic systems\n        if self.reachable_state_count == 1:\n            return int(self.reachable_states[s,a,0])\n\n        s_p = int(self.rnd_state.choice(a=self.reachable_states[s,a], size=1, p=self.reachable_probabilities[s,a])[0])\n        return s_p\n\n\n    def reward(self,\n               s: int,\n               a: int,\n               s_p: int\n               ) -&gt; int | float:\n        '''\n        Returns the rewards of playing action a when in state s and landing in state s_p.\n        If the rewards are probabilistic, it will return 0 or 1.\n\n        Parameters\n        ----------\n        s : int\n            The current state\n        a : int\n            The action taking in state s\n        s_p : int\n            The state landing in after taking action a in state s\n\n        Returns\n        -------\n        reward : int or float\n            The reward received.\n        '''\n        reward = float(self.immediate_reward_table[s,a,s_p] if self.immediate_reward_table is not None else self.immediate_reward_function(s,a,s_p))\n        if self.rewards_are_probabilistic:\n            rnd = random.random()\n            return 1 if rnd &lt; reward else 0\n        else:\n            return reward\n\n\n    def get_coords(self,\n                   items: int | list\n                   ) -&gt; list[list[int]] | list[int]:\n        '''\n        Function to get the coordinate (on the state_grid) for the provided state index or indices.\n\n        Parameters\n        ----------\n        items : int or list[int]\n            The states ids or id get convert to a 2D coordinate.\n\n        Returns\n        -------\n        item_coords : list[int] or list[list[int]]\n            The 2D positions of the provided item ids.\n        '''\n        item_list = [items] if isinstance(items, int) else items\n        item_coords = [np.argwhere(self.cpu_model.state_grid == s)[0] for s in item_list]\n\n        return item_coords[0] if isinstance(items, int) else item_coords\n\n\n    def save(self,\n             file_name: str,\n             path: str = './Models'\n             ) -&gt; None:\n        '''\n        Function to save the current model in a pickle file.\n        By default, the model will be saved in 'Models' directory in the current working directory but this can be changed using the 'path' parameter.\n\n        Parameters\n        ----------\n        file_name : str\n            The name of the json file the model will be saved in.\n        path : str, default='./Models'\n            The path at which the model will be saved.\n        '''\n        if not os.path.exists(path):\n            print('Folder does not exist yet, creating it...')\n            os.makedirs(path)\n\n        if not file_name.endswith('.pck'):\n            file_name += '.pck'\n\n        # Writing the cpu version of the file to a pickle file\n        with open(path + '/' + file_name, 'wb') as f:\n            pickle.dump(self.cpu_model, f)\n\n\n    @classmethod\n    def load_from_file(cls,\n                       file: str\n                       ) -&gt; 'Model':\n        '''\n        Function to load a MDP model from a pickle file. The json structure must contain the same items as in the constructor of this class.\n\n        Parameters\n        ----------\n        file : str\n            The file and path of the model to be loaded.\n\n        Returns\n        -------\n        loaded_model : mdp.Model\n            An instance of the loaded model.\n        '''\n        with open(file, 'rb') as openfile:\n            loaded_model = pickle.load(openfile)\n\n        return loaded_model\n\n\n    @property\n    def gpu_model(self) -&gt; 'Model':\n        '''\n        The same model but on the GPU instead of the CPU. If already on the GPU, the current model object is returned.\n        '''\n        if self.is_on_gpu:\n            return self\n\n        assert gpu_support, \"GPU Support is not available, try installing cupy...\"\n\n        if self._alt_model is None:\n            log('Sending Model to GPU...')\n            start = datetime.now()\n\n            # Setting all the arguments of the new class and convert to cupy if numpy array\n            new_model = super().__new__(self.__class__)\n            for arg, val in self.__dict__.items():\n                if isinstance(val, np.ndarray):\n                    new_model.__setattr__(arg, cp.array(val))\n                elif arg == 'rnd_state':\n                    new_model.__setattr__(arg, cp.random.RandomState(self.seed))\n                else:\n                    new_model.__setattr__(arg, val)\n\n            # GPU/CPU variables\n            new_model.is_on_gpu = True\n            new_model._alt_model = self\n            self._alt_model = new_model\n\n            duration = (datetime.now() - start).total_seconds()\n            log(f'    &gt; Done in {duration:.3f}s')\n\n        return self._alt_model\n\n\n    @property\n    def cpu_model(self) -&gt; 'Model':\n        '''\n        The same model but on the CPU instead of the GPU. If already on the CPU, the current model object is returned.\n        '''\n        if not self.is_on_gpu:\n            return self\n\n        assert gpu_support, \"GPU Support is not available, try installing cupy...\"\n\n        if self._alt_model is None:\n            log('Sending Model to CPU...')\n            start = datetime.now()\n\n            # Setting all the arguments of the new class and convert to numpy if cupy array\n            new_model = super().__new__(self.__class__)\n            for arg, val in self.__dict__.items():\n                new_model.__setattr__(arg, cp.asnumpy(val) if isinstance(val, cp.ndarray) else val)\n\n            # GPU/CPU variables\n            new_model.is_on_gpu = False\n            new_model._alt_model = self\n            self._alt_model = new_model\n\n            duration = (datetime.now() - start).total_seconds()\n            log(f'    &gt; Done in {duration:.3f}s')\n\n        return self._alt_model\n</code></pre>"},{"location":"reference/agents/model_based_util/mdp/#olfactory_navigation.agents.model_based_util.mdp.Model.cpu_model","title":"<code>cpu_model</code>  <code>property</code>","text":"<p>The same model but on the CPU instead of the GPU. If already on the CPU, the current model object is returned.</p>"},{"location":"reference/agents/model_based_util/mdp/#olfactory_navigation.agents.model_based_util.mdp.Model.gpu_model","title":"<code>gpu_model</code>  <code>property</code>","text":"<p>The same model but on the GPU instead of the CPU. If already on the GPU, the current model object is returned.</p>"},{"location":"reference/agents/model_based_util/mdp/#olfactory_navigation.agents.model_based_util.mdp.Model.get_coords","title":"<code>get_coords(items)</code>","text":"<p>Function to get the coordinate (on the state_grid) for the provided state index or indices.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>int or list[int]</code> <p>The states ids or id get convert to a 2D coordinate.</p> required <p>Returns:</p> Name Type Description <code>item_coords</code> <code>list[int] or list[list[int]]</code> <p>The 2D positions of the provided item ids.</p> Source code in <code>olfactory_navigation/agents/model_based_util/mdp.py</code> <pre><code>def get_coords(self,\n               items: int | list\n               ) -&gt; list[list[int]] | list[int]:\n    '''\n    Function to get the coordinate (on the state_grid) for the provided state index or indices.\n\n    Parameters\n    ----------\n    items : int or list[int]\n        The states ids or id get convert to a 2D coordinate.\n\n    Returns\n    -------\n    item_coords : list[int] or list[list[int]]\n        The 2D positions of the provided item ids.\n    '''\n    item_list = [items] if isinstance(items, int) else items\n    item_coords = [np.argwhere(self.cpu_model.state_grid == s)[0] for s in item_list]\n\n    return item_coords[0] if isinstance(items, int) else item_coords\n</code></pre>"},{"location":"reference/agents/model_based_util/mdp/#olfactory_navigation.agents.model_based_util.mdp.Model.load_from_file","title":"<code>load_from_file(file)</code>  <code>classmethod</code>","text":"<p>Function to load a MDP model from a pickle file. The json structure must contain the same items as in the constructor of this class.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>The file and path of the model to be loaded.</p> required <p>Returns:</p> Name Type Description <code>loaded_model</code> <code>Model</code> <p>An instance of the loaded model.</p> Source code in <code>olfactory_navigation/agents/model_based_util/mdp.py</code> <pre><code>@classmethod\ndef load_from_file(cls,\n                   file: str\n                   ) -&gt; 'Model':\n    '''\n    Function to load a MDP model from a pickle file. The json structure must contain the same items as in the constructor of this class.\n\n    Parameters\n    ----------\n    file : str\n        The file and path of the model to be loaded.\n\n    Returns\n    -------\n    loaded_model : mdp.Model\n        An instance of the loaded model.\n    '''\n    with open(file, 'rb') as openfile:\n        loaded_model = pickle.load(openfile)\n\n    return loaded_model\n</code></pre>"},{"location":"reference/agents/model_based_util/mdp/#olfactory_navigation.agents.model_based_util.mdp.Model.reward","title":"<code>reward(s, a, s_p)</code>","text":"<p>Returns the rewards of playing action a when in state s and landing in state s_p. If the rewards are probabilistic, it will return 0 or 1.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>int</code> <p>The current state</p> required <code>a</code> <code>int</code> <p>The action taking in state s</p> required <code>s_p</code> <code>int</code> <p>The state landing in after taking action a in state s</p> required <p>Returns:</p> Name Type Description <code>reward</code> <code>int or float</code> <p>The reward received.</p> Source code in <code>olfactory_navigation/agents/model_based_util/mdp.py</code> <pre><code>def reward(self,\n           s: int,\n           a: int,\n           s_p: int\n           ) -&gt; int | float:\n    '''\n    Returns the rewards of playing action a when in state s and landing in state s_p.\n    If the rewards are probabilistic, it will return 0 or 1.\n\n    Parameters\n    ----------\n    s : int\n        The current state\n    a : int\n        The action taking in state s\n    s_p : int\n        The state landing in after taking action a in state s\n\n    Returns\n    -------\n    reward : int or float\n        The reward received.\n    '''\n    reward = float(self.immediate_reward_table[s,a,s_p] if self.immediate_reward_table is not None else self.immediate_reward_function(s,a,s_p))\n    if self.rewards_are_probabilistic:\n        rnd = random.random()\n        return 1 if rnd &lt; reward else 0\n    else:\n        return reward\n</code></pre>"},{"location":"reference/agents/model_based_util/mdp/#olfactory_navigation.agents.model_based_util.mdp.Model.save","title":"<code>save(file_name, path='./Models')</code>","text":"<p>Function to save the current model in a pickle file. By default, the model will be saved in 'Models' directory in the current working directory but this can be changed using the 'path' parameter.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>The name of the json file the model will be saved in.</p> required <code>path</code> <code>str</code> <p>The path at which the model will be saved.</p> <code>'./Models'</code> Source code in <code>olfactory_navigation/agents/model_based_util/mdp.py</code> <pre><code>def save(self,\n         file_name: str,\n         path: str = './Models'\n         ) -&gt; None:\n    '''\n    Function to save the current model in a pickle file.\n    By default, the model will be saved in 'Models' directory in the current working directory but this can be changed using the 'path' parameter.\n\n    Parameters\n    ----------\n    file_name : str\n        The name of the json file the model will be saved in.\n    path : str, default='./Models'\n        The path at which the model will be saved.\n    '''\n    if not os.path.exists(path):\n        print('Folder does not exist yet, creating it...')\n        os.makedirs(path)\n\n    if not file_name.endswith('.pck'):\n        file_name += '.pck'\n\n    # Writing the cpu version of the file to a pickle file\n    with open(path + '/' + file_name, 'wb') as f:\n        pickle.dump(self.cpu_model, f)\n</code></pre>"},{"location":"reference/agents/model_based_util/mdp/#olfactory_navigation.agents.model_based_util.mdp.Model.transition","title":"<code>transition(s, a)</code>","text":"<p>Returns a random posterior state knowing we take action a in state t and weighted on the transition probabilities.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>int</code> <p>The current state</p> required <code>a</code> <code>int</code> <p>The action to take</p> required <p>Returns:</p> Name Type Description <code>s_p</code> <code>int</code> <p>The posterior state</p> Source code in <code>olfactory_navigation/agents/model_based_util/mdp.py</code> <pre><code>def transition(self,\n               s: int,\n               a: int\n               ) -&gt; int:\n    '''\n    Returns a random posterior state knowing we take action a in state t and weighted on the transition probabilities.\n\n    Parameters\n    ----------\n    s : int \n        The current state\n    a : int\n        The action to take\n\n    Returns\n    -------\n    s_p : int\n        The posterior state\n    '''\n    xp = cp if self.is_on_gpu else np\n\n    # Shortcut for deterministic systems\n    if self.reachable_state_count == 1:\n        return int(self.reachable_states[s,a,0])\n\n    s_p = int(self.rnd_state.choice(a=self.reachable_states[s,a], size=1, p=self.reachable_probabilities[s,a])[0])\n    return s_p\n</code></pre>"},{"location":"reference/agents/model_based_util/mdp/#olfactory_navigation.agents.model_based_util.mdp.log","title":"<code>log(content)</code>","text":"<p>Function to print a log line with a timestamp.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The content to be printed as a log.</p> required Source code in <code>olfactory_navigation/agents/model_based_util/mdp.py</code> <pre><code>def log(content:str) -&gt; None:\n    '''\n    Function to print a log line with a timestamp.\n\n    Parameters\n    ----------\n    content : str\n        The content to be printed as a log.\n    '''\n    print(f'[{datetime.now().strftime(\"%m/%d/%Y, %H:%M:%S\")}] ' + content)\n</code></pre>"},{"location":"reference/agents/model_based_util/pomdp/","title":"pomdp","text":""},{"location":"reference/agents/model_based_util/pomdp/#olfactory_navigation.agents.model_based_util.pomdp.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>Model</code></p> <p>POMDP Model class. Partially Observable Markov Decision Process Model.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>int or list[str] or list[list[str]]</code> <p>A list of state labels or an amount of states to be used. Also allows to provide a matrix of states to define a grid model.</p> required <code>actions</code> <code>int or list</code> <p>A list of action labels or an amount of actions to be used.</p> required <code>observations</code> <code>int or list</code> <p>A list of observation labels or an amount of observations to be used</p> required <code>transitions</code> <code>array - like or function</code> <p>The transitions between states, an array can be provided and has to be |S| x |A| x |S| or a function can be provided.  If a function is provided, it has be able to deal with np.array arguments. If none is provided, it will be randomly generated.</p> <code>None</code> <code>reachable_states</code> <code>array - like</code> <p>A list of states that can be reached from each state and actions. It must be a matrix of size |S| x |A| x |R| where |R| is the max amount of states reachable from any given state and action pair. It is optional but useful for speedup purposes.</p> <code>None</code> <code>rewards</code> <code>array - like or function</code> <p>The reward matrix, has to be |S| x |A| x |S|. A function can also be provided here but it has to be able to deal with np.array arguments. If provided, it will be use in combination with the transition matrix to fill to expected rewards.</p> <code>None</code> <code>observation_table</code> <code>array - like or function</code> <p>The observation matrix, has to be |S| x |A| x |O|. If none is provided, it will be randomly generated.</p> <code>None</code> <code>rewards_are_probabilistic</code> <code>bool</code> <p>Whether the rewards provided are probabilistic or pure rewards. If probabilist 0 or 1 will be the reward with a certain probability.</p> <code>False</code> <code>state_grid</code> <code>array - like</code> <p>If provided, the model will be converted to a grid model.</p> <code>None</code> <code>start_probabilities</code> <code>list</code> <p>The distribution of chances to start in each state. If not provided, there will be an uniform chance for each state. It is also used to represent a belief of complete uncertainty.</p> <code>None</code> <code>end_states</code> <code>list</code> <p>Entering either state in the list during a simulation will end the simulation.</p> <code>[]</code> <code>end_actions</code> <code>list</code> <p>Playing action of the list during a simulation will end the simulation.</p> <code>[]</code> <code>print_debug</code> <code>bool</code> <p>Whether to print debug logs about the creation progress of the POMDP Model.</p> <code>False</code> <code>seed</code> <code>int</code> <p>For reproducible randomness.</p> <code>12131415</code> <p>Attributes:</p> Name Type Description <code>states</code> <code>ndarray</code> <p>A 1D array of states indices. Used to loop over states.</p> <code>state_labels</code> <code>list[str]</code> <p>A list of state labels. (To be mainly used for plotting)</p> <code>state_count</code> <code>int</code> <p>How many states are in the Model.</p> <code>state_grid</code> <code>ndarray</code> <p>The state indices organized as a 2D grid. (Used for plotting purposes)</p> <code>actions</code> <code>ndarry</code> <p>A 1D array of action indices. Used to loop over actions.</p> <code>action_labels</code> <code>list[str]</code> <p>A list of action labels. (To be mainly used for plotting)</p> <code>action_count</code> <code>int</code> <p>How many action are in the Model.</p> <code>observations</code> <code>ndarray</code> <p>A 1D array of observation indices. Used to loop over obervations.</p> <code>observation_labels</code> <code>list[str]</code> <p>A list of observation labels. (To be mainly used for plotting)</p> <code>observation_count</code> <code>int</code> <p>How many observations can be made in the Model.</p> <code>transition_table</code> <code>ndarray</code> <p>A 3D matrix of the transition probabilities. Can be None in the case a transition function is provided instead. Note: When possible, use reachable states and reachable probabilities instead.</p> <code>transition_function</code> <code>function</code> <p>A callable function taking 3 arguments: s, a, s_p; and returning a float between 0.0 and 1.0. Can be None in the case a transition table is provided instead. Note: When possible, use reachable states and reachable probabilities instead.</p> <code>observation_table</code> <code>ndarray</code> <p>A 3D matrix of shape S x A x O representing the probabilies of obsevating o when taking action a and leading to state s_p.</p> <code>reachable_states</code> <code>ndarray</code> <p>A 3D array of the shape S x A x R, where R is max amount to states that can be reached from any state-action pair.</p> <code>reachable_probabilities</code> <code>ndarray</code> <p>A 3D array of the same shape as reachable_states, the array represent the probability of reaching the state pointed by the reachable_states matrix.</p> <code>reachable_state_count</code> <code>int</code> <p>The maximum of states that can be reached from any state-action combination.</p> <code>reachable_transitional_observation_table</code> <code>ndarray</code> <p>A 4D array of shape S x A x O x R, representing the probabiliies of landing if each reachable state r, while observing o after having taken action a from state s. Mainly used to speedup repeated operations in solver.</p> <code>immediate_reward_table</code> <code>ndarray</code> <p>A 3D matrix of shape S x A x S x O of the reward that will received when taking action a, in state s, landing in state s_p, and observing o. Can be None in the case an immediate rewards function is provided instead.</p> <code>immediate_reward_function</code> <code>function</code> <p>A callable function taking 4 argments: s, a, s_p, o and returning the immediate reward the agent will receive. Can be None in the case an immediate rewards function is provided instead.</p> <code>expected_reward_table</code> <code>ndarray</code> <p>A 2D array of shape S x A. It represents the rewards that is expected to be received when taking action a from state s. It is made by taking the weighted average of immediate rewards with the transitions and the observation probabilities.</p> <code>start_probabilities</code> <code>ndarray</code> <p>A 1D array of length |S| containing the probility distribution of the agent starting in each state.</p> <code>rewards_are_probabilisitic</code> <code>bool</code> <p>Whether the immediate rewards are probabilitic, ie: returning a 0 or 1 based on the reward that is considered to be a probability.</p> <code>end_states</code> <code>list[int]</code> <p>A list of states that, when reached, terminate a simulation.</p> <code>end_actions</code> <code>list[int]</code> <p>A list of actions that, when taken, terminate a simulation.</p> <code>is_on_gpu</code> <code>bool</code> <p>Whether the numpy array of the model are stored on the gpu or not.</p> <code>gpu_model</code> <code>Model</code> <p>An equivalent model with the np.ndarray objects on GPU. (If already on GPU, returns self)</p> <code>cpu_model</code> <code>Model</code> <p>An equivalent model with the np.ndarray objects on CPU. (If already on CPU, returns self)</p> <code>seed</code> <code>int</code> <p>The seed used for the random operations (to allow for reproducability).</p> <code>rnd_state</code> <code>RandomState</code> <p>The random state variable used to generate random values.</p> Source code in <code>olfactory_navigation/agents/model_based_util/pomdp.py</code> <pre><code>class Model(MDP_Model):\n    '''\n    POMDP Model class. Partially Observable Markov Decision Process Model.\n\n\n    Parameters\n    ----------\n    states : int or list[str] or list[list[str]]\n        A list of state labels or an amount of states to be used. Also allows to provide a matrix of states to define a grid model.\n    actions : int or list\n        A list of action labels or an amount of actions to be used.\n    observations : int or list\n        A list of observation labels or an amount of observations to be used\n    transitions : array-like or function, optional\n        The transitions between states, an array can be provided and has to be |S| x |A| x |S| or a function can be provided. \n        If a function is provided, it has be able to deal with np.array arguments.\n        If none is provided, it will be randomly generated.\n    reachable_states : array-like, optional\n        A list of states that can be reached from each state and actions. It must be a matrix of size |S| x |A| x |R| where |R| is the max amount of states reachable from any given state and action pair.\n        It is optional but useful for speedup purposes.\n    rewards : array-like or function, optional\n        The reward matrix, has to be |S| x |A| x |S|.\n        A function can also be provided here but it has to be able to deal with np.array arguments.\n        If provided, it will be use in combination with the transition matrix to fill to expected rewards.\n    observation_table : array-like or function, optional\n        The observation matrix, has to be |S| x |A| x |O|. If none is provided, it will be randomly generated.\n    rewards_are_probabilistic: bool, default=False\n        Whether the rewards provided are probabilistic or pure rewards. If probabilist 0 or 1 will be the reward with a certain probability.\n    state_grid : array-like, optional\n        If provided, the model will be converted to a grid model.\n    start_probabilities : list, optional\n        The distribution of chances to start in each state. If not provided, there will be an uniform chance for each state. It is also used to represent a belief of complete uncertainty.\n    end_states : list, optional\n        Entering either state in the list during a simulation will end the simulation.\n    end_actions : list, optional\n        Playing action of the list during a simulation will end the simulation.\n    print_debug : bool, default=False\n        Whether to print debug logs about the creation progress of the POMDP Model.\n    seed : int, default=12131415\n        For reproducible randomness.\n\n    Attributes\n    ----------\n    states : np.ndarray\n        A 1D array of states indices. Used to loop over states.\n    state_labels : list[str]\n        A list of state labels. (To be mainly used for plotting)\n    state_count : int\n        How many states are in the Model.\n    state_grid : np.ndarray\n        The state indices organized as a 2D grid. (Used for plotting purposes)\n    actions : np.ndarry\n        A 1D array of action indices. Used to loop over actions.\n    action_labels : list[str]\n        A list of action labels. (To be mainly used for plotting)\n    action_count : int\n        How many action are in the Model.\n    observations : np.ndarray\n        A 1D array of observation indices. Used to loop over obervations.\n    observation_labels : list[str]\n        A list of observation labels. (To be mainly used for plotting)\n    observation_count : int\n        How many observations can be made in the Model.\n    transition_table : np.ndarray\n        A 3D matrix of the transition probabilities.\n        Can be None in the case a transition function is provided instead.\n        Note: When possible, use reachable states and reachable probabilities instead.\n    transition_function : function\n        A callable function taking 3 arguments: s, a, s_p; and returning a float between 0.0 and 1.0.\n        Can be None in the case a transition table is provided instead.\n        Note: When possible, use reachable states and reachable probabilities instead.\n    observation_table : np.ndarray\n        A 3D matrix of shape S x A x O representing the probabilies of obsevating o when taking action a and leading to state s_p.\n    reachable_states : np.ndarray\n        A 3D array of the shape S x A x R, where R is max amount to states that can be reached from any state-action pair.\n    reachable_probabilities : np.ndarray\n        A 3D array of the same shape as reachable_states, the array represent the probability of reaching the state pointed by the reachable_states matrix.\n    reachable_state_count : int\n        The maximum of states that can be reached from any state-action combination.\n    reachable_transitional_observation_table : np.ndarray\n        A 4D array of shape S x A x O x R, representing the probabiliies of landing if each reachable state r, while observing o after having taken action a from state s.\n        Mainly used to speedup repeated operations in solver.\n    immediate_reward_table : np.ndarray\n        A 3D matrix of shape S x A x S x O of the reward that will received when taking action a, in state s, landing in state s_p, and observing o.\n        Can be None in the case an immediate rewards function is provided instead.\n    immediate_reward_function : function\n        A callable function taking 4 argments: s, a, s_p, o and returning the immediate reward the agent will receive.\n        Can be None in the case an immediate rewards function is provided instead.\n    expected_reward_table : np.ndarray\n        A 2D array of shape S x A. It represents the rewards that is expected to be received when taking action a from state s.\n        It is made by taking the weighted average of immediate rewards with the transitions and the observation probabilities.\n    start_probabilities : np.ndarray\n        A 1D array of length |S| containing the probility distribution of the agent starting in each state.\n    rewards_are_probabilisitic : bool\n        Whether the immediate rewards are probabilitic, ie: returning a 0 or 1 based on the reward that is considered to be a probability.\n    end_states : list[int]\n        A list of states that, when reached, terminate a simulation.\n    end_actions : list[int]\n        A list of actions that, when taken, terminate a simulation.\n    is_on_gpu : bool\n        Whether the numpy array of the model are stored on the gpu or not.\n    gpu_model : mdp.Model\n        An equivalent model with the np.ndarray objects on GPU. (If already on GPU, returns self)\n    cpu_model : mdp.Model\n        An equivalent model with the np.ndarray objects on CPU. (If already on CPU, returns self)\n    seed : int\n        The seed used for the random operations (to allow for reproducability).\n    rnd_state : np.random.RandomState\n        The random state variable used to generate random values.\n    '''\n    def __init__(self,\n                 states: int | list[str] | list[list[str]],\n                 actions: int | list,\n                 observations: int | list,\n                 transitions = None,\n                 reachable_states = None,\n                 rewards = None,\n                 observation_table = None,\n                 rewards_are_probabilistic: bool = False,\n                 state_grid = None,\n                 start_probabilities: list | None = None,\n                 end_states: list[int] = [],\n                 end_actions: list[int] = [],\n                 print_debug: bool = False,\n                 seed: int = 12131415\n                 ) -&gt; None:\n        super().__init__(states=states,\n                         actions=actions,\n                         transitions=transitions,\n                         reachable_states=reachable_states,\n                         rewards=-1, # Defined here lower since immediate reward table has different shape for MDP is different than for POMDP\n                         rewards_are_probabilistic=rewards_are_probabilistic,\n                         state_grid=state_grid,\n                         start_probabilities=start_probabilities,\n                         end_states=end_states,\n                         end_actions=end_actions,\n                         print_debug=print_debug,\n                         seed=seed)\n        # Debug logger\n        def logger(content: str):\n            if print_debug:\n                log(content=content)\n\n        if print_debug:\n            print()\n            log('POMDP particular parameters:')\n\n        # ------------------------- Observations -------------------------\n        if isinstance(observations, int):\n            self.observation_labels = [f'o_{i}' for i in range(observations)]\n        else:\n            self.observation_labels = observations\n        self.observation_count = len(self.observation_labels)\n        self.observations = np.arange(self.observation_count)\n\n        if observation_table is None:\n            # If no observation matrix given, generate random one\n            random_probs = self.rnd_state.random((self.state_count, self.action_count, self.observation_count))\n            # Normalization to have s_p probabilies summing to 1\n            self.observation_table = random_probs / np.sum(random_probs, axis=2, keepdims=True)\n        else:\n            self.observation_table = np.array(observation_table)\n            o_shape = self.observation_table.shape\n            exp_shape = (self.state_count, self.action_count, self.observation_count)\n            assert o_shape == exp_shape, f\"Observations table doesnt have the right shape, it should be SxAxO (expected: {exp_shape}, received: {o_shape}).\"\n\n        logger(f'- {self.observation_count} observations')\n\n        # ------------------------- Reachable transitional observation probabilities -------------------------\n        logger('- Starting of transitional observations for reachable states table')\n        start_ts = datetime.now()\n\n        reachable_observations = self.observation_table[self.reachable_states[:,:,None,:], self.actions[None,:,None,None], self.observations[None,None,:,None]] # SAOR\n        self.reachable_transitional_observation_table = np.einsum('sar,saor-&gt;saor', self.reachable_probabilities, reachable_observations)\n\n        duration = (datetime.now() - start_ts).total_seconds()\n        logger(f'    &gt; Done in {duration:.3f}s')\n\n        # ------------------------- Rewards -------------------------\n        self.immediate_reward_table = None\n        self.immediate_reward_function = None\n\n        if rewards is None:\n            if (len(self.end_states) &gt; 0) or (len(self.end_actions) &gt; 0):\n                logger('- [Warning] Rewards are not define but end states/actions are, reaching an end state or doing an end action will give a reward of 1.')\n                self.immediate_reward_function = self._end_reward_function\n            else:\n                # If no reward matrix given, generate random one\n                self.immediate_reward_table = self.rnd_state.random((self.state_count, self.action_count, self.state_count, self.observation_count))\n        elif callable(rewards):\n            # Rewards is a function\n            logger('- [Warning] The rewards are provided as a function, if the model is saved, the rewards will need to be defined before loading model.')\n            logger('    &gt; Alternative: Setting end states/actions and leaving the rewards can be done to make the end states/action giving a reward of 1 by default.')\n            self.immediate_reward_function = rewards\n            assert len(signature(rewards).parameters) == 4, \"Reward function should accept 4 parameters: s, a, sn, o...\"\n        else:\n            # Array like\n            self.immediate_reward_table = np.array(rewards)\n            r_shape = self.immediate_reward_table.shape\n            exp_shape = (self.state_count, self.action_count, self.state_count, self.observation_count)\n            assert r_shape == exp_shape, f\"Rewards table doesnt have the right shape, it should be SxAxSxO (expected: {exp_shape}, received {r_shape})\"\n\n        # ------------------------- Expected rewards -------------------------\n        logger('- Starting generation of expected rewards table')\n        start_ts = datetime.now()\n\n        reachable_rewards = None\n        if self.immediate_reward_table is not None:\n            reachable_rewards = rewards[self.states[:,None,None,None], self.actions[None,:,None,None], self.reachable_states[:,:,:,None], self.observations[None,None,None,:]]\n        else:\n            def reach_reward_func(s,a,ri,o):\n                s = s.astype(int)\n                a = a.astype(int)\n                ri = ri.astype(int)\n                o = o.astype(int)\n                return self.immediate_reward_function(s,a,self.reachable_states[s,a,ri],o)\n\n            reachable_rewards = np.fromfunction(reach_reward_func, (*self.reachable_states.shape, self.observation_count))\n\n        self._min_reward = float(np.min(reachable_rewards))\n        self._max_reward = float(np.max(reachable_rewards))\n\n        self.expected_rewards_table = np.einsum('saor,saro-&gt;sa', self.reachable_transitional_observation_table, reachable_rewards)\n\n        duration = (datetime.now() - start_ts).total_seconds()\n        logger(f'    &gt; Done in {duration:.3f}s')\n\n\n    def _end_reward_function(self, s, a, sn, o):\n        '''\n        The default reward function.\n        Returns 1 if the next state sn is in the end states or if the action is in the end actions (terminating actions)\n        '''\n        return (np.isin(sn, self.end_states) | np.isin(a, self.end_actions)).astype(int)\n\n\n    def reward(self,\n               s: int,\n               a: int,\n               s_p: int,\n               o: int\n               ) -&gt; int | float:\n        '''\n        Returns the rewards of playing action a when in state s and landing in state s_p.\n        If the rewards are probabilistic, it will return 0 or 1.\n\n        Parameters\n        ----------\n        s : int\n            The current state.\n        a : int\n            The action taking in state s.\n        s_p : int\n            The state landing in after taking action a in state s\n        o : int\n            The observation that is done after having played action a in state s and landing in s_p\n\n        Returns\n        -------\n        reward : int or float\n            The reward received.\n        '''\n        reward = float(self.immediate_reward_table[s,a,s_p,o] if self.immediate_reward_table is not None else self.immediate_reward_function(s,a,s_p,o))\n        if self.rewards_are_probabilistic:\n            rnd = random.random()\n            return 1 if rnd &lt; reward else 0\n        else:\n            return reward\n\n\n    def observe(self,\n                s_p: int,\n                a: int\n                ) -&gt; int:\n        '''\n        Returns a random observation knowing action a is taken from state s, it is weighted by the observation probabilities.\n\n        Parameters\n        ----------\n        s_p : int\n            The state landed on after having done action a.\n        a : int\n            The action to take.\n\n        Returns\n        -------\n        o : int\n            A random observation.\n        '''\n        xp = cp if self.is_on_gpu else np\n        o = int(self.rnd_state.choice(a=self.observations, size=1, p=self.observation_table[s_p,a])[0])\n        return o\n</code></pre>"},{"location":"reference/agents/model_based_util/pomdp/#olfactory_navigation.agents.model_based_util.pomdp.Model.observe","title":"<code>observe(s_p, a)</code>","text":"<p>Returns a random observation knowing action a is taken from state s, it is weighted by the observation probabilities.</p> <p>Parameters:</p> Name Type Description Default <code>s_p</code> <code>int</code> <p>The state landed on after having done action a.</p> required <code>a</code> <code>int</code> <p>The action to take.</p> required <p>Returns:</p> Name Type Description <code>o</code> <code>int</code> <p>A random observation.</p> Source code in <code>olfactory_navigation/agents/model_based_util/pomdp.py</code> <pre><code>def observe(self,\n            s_p: int,\n            a: int\n            ) -&gt; int:\n    '''\n    Returns a random observation knowing action a is taken from state s, it is weighted by the observation probabilities.\n\n    Parameters\n    ----------\n    s_p : int\n        The state landed on after having done action a.\n    a : int\n        The action to take.\n\n    Returns\n    -------\n    o : int\n        A random observation.\n    '''\n    xp = cp if self.is_on_gpu else np\n    o = int(self.rnd_state.choice(a=self.observations, size=1, p=self.observation_table[s_p,a])[0])\n    return o\n</code></pre>"},{"location":"reference/agents/model_based_util/pomdp/#olfactory_navigation.agents.model_based_util.pomdp.Model.reward","title":"<code>reward(s, a, s_p, o)</code>","text":"<p>Returns the rewards of playing action a when in state s and landing in state s_p. If the rewards are probabilistic, it will return 0 or 1.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>int</code> <p>The current state.</p> required <code>a</code> <code>int</code> <p>The action taking in state s.</p> required <code>s_p</code> <code>int</code> <p>The state landing in after taking action a in state s</p> required <code>o</code> <code>int</code> <p>The observation that is done after having played action a in state s and landing in s_p</p> required <p>Returns:</p> Name Type Description <code>reward</code> <code>int or float</code> <p>The reward received.</p> Source code in <code>olfactory_navigation/agents/model_based_util/pomdp.py</code> <pre><code>def reward(self,\n           s: int,\n           a: int,\n           s_p: int,\n           o: int\n           ) -&gt; int | float:\n    '''\n    Returns the rewards of playing action a when in state s and landing in state s_p.\n    If the rewards are probabilistic, it will return 0 or 1.\n\n    Parameters\n    ----------\n    s : int\n        The current state.\n    a : int\n        The action taking in state s.\n    s_p : int\n        The state landing in after taking action a in state s\n    o : int\n        The observation that is done after having played action a in state s and landing in s_p\n\n    Returns\n    -------\n    reward : int or float\n        The reward received.\n    '''\n    reward = float(self.immediate_reward_table[s,a,s_p,o] if self.immediate_reward_table is not None else self.immediate_reward_function(s,a,s_p,o))\n    if self.rewards_are_probabilistic:\n        rnd = random.random()\n        return 1 if rnd &lt; reward else 0\n    else:\n        return reward\n</code></pre>"},{"location":"reference/agents/model_based_util/value_function/","title":"value_function","text":""},{"location":"reference/agents/model_based_util/value_function/#olfactory_navigation.agents.model_based_util.value_function.AlphaVector","title":"<code>AlphaVector</code>","text":"<p>A class to represent an Alpha Vector, a vector representing a plane in |S| dimension for POMDP models.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>ndarray</code> <p>The actual vector with the value for each state.</p> required <code>action</code> <code>int</code> <p>The action associated with the vector.</p> required Source code in <code>olfactory_navigation/agents/model_based_util/value_function.py</code> <pre><code>class AlphaVector:\n    '''\n    A class to represent an Alpha Vector, a vector representing a plane in |S| dimension for POMDP models.\n\n\n    Parameters\n    ----------\n    values : np.ndarray\n        The actual vector with the value for each state.\n    action : int\n        The action associated with the vector.\n    '''\n    def __init__(self,\n                 values: np.ndarray,\n                 action: int\n                 ) -&gt; None:\n        self.values = values\n        self.action = int(action)\n</code></pre>"},{"location":"reference/agents/model_based_util/value_function/#olfactory_navigation.agents.model_based_util.value_function.ValueFunction","title":"<code>ValueFunction</code>","text":"<p>Class representing a set of AlphaVectors. One such set approximates the value function of the MDP model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model the value function is associated with.</p> required <code>alpha_vectors</code> <code>list[AlphaVector] or ndarray</code> <p>The alpha vectors composing the value function, if none are provided, it will be empty to start with and AlphaVectors can be appended.</p> <code>[]</code> <code>action_list</code> <code>list[int] or ndarray</code> <p>The actions associated with alpha vectors in the case the alpha vectors are provided as an numpy array.</p> <code>[]</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>Model</code> <p>The model the value function is associated with.</p> <code>alpha_vector_list</code> <code>list[AlphaVector]</code> <code>alpha_vector_array</code> <code>ndarray</code> <code>actions</code> <code>ndarray</code> Source code in <code>olfactory_navigation/agents/model_based_util/value_function.py</code> <pre><code>class ValueFunction:\n    '''\n    Class representing a set of AlphaVectors. One such set approximates the value function of the MDP model.\n\n\n    Parameters\n    ----------\n    model : mdp.Model\n        The model the value function is associated with.\n    alpha_vectors : list[AlphaVector] or np.ndarray, optional\n        The alpha vectors composing the value function, if none are provided, it will be empty to start with and AlphaVectors can be appended.\n    action_list : list[int] or np.ndarray, optional\n        The actions associated with alpha vectors in the case the alpha vectors are provided as an numpy array.\n\n    Attributes\n    ----------\n    model : mdp.Model\n        The model the value function is associated with.\n    alpha_vector_list : list[AlphaVector]\n    alpha_vector_array : np.ndarray\n    actions : np.ndarray\n    '''\n    def __init__(self,\n                 model: Model,\n                 alpha_vectors: list[AlphaVector] | np.ndarray = [],\n                 action_list: list[int] | np.ndarray = []\n                 ) -&gt; None:\n        self.model = model\n\n        self._vector_list = None\n        self._vector_array = None\n        self._actions = None\n\n        self.is_on_gpu = False\n\n        # List of alpha vectors\n        if isinstance(alpha_vectors, list):\n            assert all(v.values.shape[0] == model.state_count for v in alpha_vectors), f\"Some or all alpha vectors in the list provided dont have the right size, they should be of shape: {model.state_count}\"\n            self._vector_list = alpha_vectors\n\n            # Check if on gpu and make sure all vectors are also on the gpu\n            if (len(alpha_vectors) &gt; 0) and gpu_support and cp.get_array_module(alpha_vectors[0].values) == cp:\n                assert all(cp.get_array_module(v.values) == cp for v in alpha_vectors), \"Either all or none of the alpha vectors should be on the GPU, not just some.\"\n                self.is_on_gpu = True\n\n        # As numpy array\n        else:\n            av_shape = alpha_vectors.shape\n            exp_shape = (len(action_list), model.state_count)\n            assert av_shape == exp_shape, f\"Alpha vector array does not have the right shape (received: {av_shape}; expected: {exp_shape})\"\n\n            self._vector_list = []\n            for alpha_vect, action in zip(alpha_vectors, action_list):\n                self._vector_list.append(AlphaVector(alpha_vect, action))\n\n            # Check if array is on gpu\n            if gpu_support and cp.get_array_module(alpha_vectors) == cp:\n                self.is_on_gpu = True\n\n        # Deduplication\n        self._uniqueness_dict = {alpha_vector.values.tobytes(): alpha_vector for alpha_vector in self._vector_list}\n        self._vector_list = list(self._uniqueness_dict.values())\n\n        self._pruning_level = 1\n\n\n    @property\n    def alpha_vector_list(self) -&gt; list[AlphaVector]:\n        '''\n        A list of AlphaVector objects. If the value function is defined as an matrix of vectors and a list of actions, the list of AlphaVectors will be generated from them.\n        '''\n        if self._vector_list is None:\n            self._vector_list = []\n            for alpha_vect, action in zip(self._vector_array, self._actions):\n                self._vector_list.append(AlphaVector(alpha_vect, action))\n        return self._vector_list\n\n\n    @property\n    def alpha_vector_array(self) -&gt; np.ndarray:\n        '''\n        A matrix of size N x S, containing all the alpha vectors making up the value function. (N is the number of alpha vectors and S the amount of states in the model)\n        If the value function is defined as a list of AlphaVector objects, the matrix will the generated from them.\n        '''\n        xp = cp if (gpu_support and self.is_on_gpu) else np\n\n        if self._vector_array is None:\n            self._vector_array = xp.array([v.values for v in self._vector_list])\n            self._actions = xp.array([v.action for v in self._vector_list])\n        return self._vector_array\n\n\n    @property\n    def actions(self) -&gt; np.ndarray:\n        '''\n        A list of N actions corresponding to the N alpha vectors making up the value function.\n        If the value function is defined as a list of AlphaVector objects, the list will the generated from the actions of those alpha vector objects.\n        '''\n        xp = cp if (gpu_support and self.is_on_gpu) else np\n\n        if self._actions is None:\n            self._vector_array = xp.array(self._vector_list)\n            self._actions = xp.array([v.action for v in self._vector_list])\n        return self._actions\n\n\n    def __len__(self) -&gt; int:\n        return len(self._vector_list) if self._vector_list is not None else self._vector_array.shape[0]\n\n\n    def __add__(self, other_value_function: 'Model') -&gt; 'Model':\n        # combined_dict = {**self._uniqueness_dict, **other_value_function._uniqueness_dict}\n        combined_dict = {}\n        combined_dict.update(self._uniqueness_dict)\n        combined_dict.update(other_value_function._uniqueness_dict)\n\n        # Instantiation of the new value function\n        new_value_function = super().__new__(self.__class__)\n        new_value_function.model = self.model\n        new_value_function.is_on_gpu = self.is_on_gpu\n\n        new_value_function._vector_list = list(combined_dict.values())\n        new_value_function._uniqueness_dict = combined_dict\n        new_value_function._pruning_level = 1\n\n        new_value_function._vector_array = None\n        new_value_function._actions = None\n\n        return new_value_function\n\n\n    def append(self,\n               alpha_vector: AlphaVector\n               ) -&gt; None:\n        '''\n        Function to add an alpha vector to the value function.\n\n        Parameters\n        ----------\n        alpha_vector : AlphaVector\n            The alpha vector to be added to the value function.\n        '''\n        # Make sure size is correct\n        assert alpha_vector.values.shape[0] == self.model.state_count, f\"Vector to add to value function doesn't have the right size (received: {alpha_vector.values.shape[0]}, expected: {self.model.state_count})\"\n\n        # GPU support check\n        xp = cp if (gpu_support and self.is_on_gpu) else np\n        assert gpu_support and cp.get_array_module(alpha_vector.values) == xp, f\"Vector is{' not' if self.is_on_gpu else ''} on GPU while value function is{'' if self.is_on_gpu else ' not'}.\"\n\n        if self._vector_array is not None:\n            self._vector_array = xp.append(self._vector_array, alpha_vector[None,:], axis=0)\n            self._actions = xp.append(self._actions, alpha_vector.action)\n\n        if self._vector_list is not None:\n            self._vector_list.append(alpha_vector)\n\n\n    def extend(self,\n               other_value_function: 'Model'\n               ) -&gt; None:\n        '''\n        Function to add another value function is place.\n        Effectively, it performs the union of the two sets of alpha vectors.\n\n        Parameters\n        ----------\n        other_value_function : ValueFunction\n            The other side of the union.\n        '''\n        self._uniqueness_dict.update(other_value_function._uniqueness_dict)\n        self._vector_list = list(self._uniqueness_dict.values())\n\n        self._vector_array = None\n        self._actions = None\n\n        self._pruning_level = 1\n\n\n    def to_gpu(self) -&gt; 'ValueFunction':\n        '''\n        Function returning an equivalent value function object with the arrays stored on GPU instead of CPU.\n\n        Returns\n        -------\n        gpu_value_function : ValueFunction\n            A new value function with arrays on GPU.\n        '''\n        assert gpu_support, \"GPU support is not enabled, unable to execute this function\"\n\n        gpu_model = self.model.gpu_model\n\n        gpu_value_function = None\n        if self._vector_list is not None:\n            gpu_alpha_vectors = [AlphaVector(cp.array(av.values), av.action) for av in self._vector_list]\n            gpu_value_function = ValueFunction(gpu_model, gpu_alpha_vectors)\n\n        else:\n            gpu_vector_array = cp.array(self._vector_array)\n            gpu_actions = self._actions if isinstance(self._actions, list) else cp.array(self._actions)\n            gpu_value_function = ValueFunction(gpu_model, gpu_vector_array, gpu_actions)\n\n        return gpu_value_function\n\n\n    def to_cpu(self) -&gt; 'ValueFunction':\n        '''\n        Function returning an equivalent value function object with the arrays stored on CPU instead of GPU.\n\n        Returns\n        -------\n        cpu_value_function : ValueFunction\n            A new value function with arrays on CPU.\n        '''\n        assert gpu_support, \"GPU support is not enabled, unable to execute this function\"\n\n        cpu_model = self.model.cpu_model\n\n        cpu_value_function = None\n        if self._vector_list is not None:\n            cpu_alpha_vectors = [AlphaVector(cp.asnumpy(av.values), av.action) for av in self._vector_list]\n            cpu_value_function = ValueFunction(cpu_model, cpu_alpha_vectors)\n\n        else:\n            cpu_vector_array = cp.asnumpy(self._vector_array)\n            cpu_actions = self._actions if isinstance(self._actions, list) else cp.asnumpy(self._actions)\n            cpu_value_function = ValueFunction(cpu_model, cpu_vector_array, cpu_actions)\n\n        return cpu_value_function\n\n\n    def prune(self,\n              level: int = 1\n              ) -&gt; None:\n        '''\n        Function pruning the set of alpha vectors composing the value function.\n        The pruning is as thorough as the level:\n            - 2: 1+ Check of absolute domination (check if dominated at each state).\n            - 3: 2+ Solves Linear Programming problem for each alpha vector to see if it is dominated by combinations of other vectors.\n\n        Note that the higher the level, the heavier the time impact will be.\n\n        Parameters\n        ----------\n        level : int, default=1\n            Between 0 and 3, how thorough the alpha vector pruning should be.\n        '''\n        # GPU support check\n        xp = cp if (gpu_support and self.is_on_gpu) else np\n\n        # Level 1 or under\n        if level &lt; self._pruning_level or level &gt; 3:\n            log('Attempting to prune a value function to a level already reached. Returning \\'self\\'')\n            return\n\n        # Level 2 pruning: Check for absolute domination\n        if level &gt;= 2 and self._pruning_level &lt; 2:\n            non_dominated_vector_indices = []\n\n            for i, v in enumerate(self.alpha_vector_array):\n                is_dom_by = xp.all(self.alpha_vector_array &gt;= v, axis=1)\n                if len(xp.where(is_dom_by)[0]) == 1:\n                    non_dominated_vector_indices.append(i)\n\n            self._vector_array = self._vector_array[non_dominated_vector_indices]\n            self._actions = self._actions[non_dominated_vector_indices]\n\n        # Level 3 pruning: LP to check for more complex domination\n        if level &gt;= 3:\n            assert ilp_support, \"ILP support not enabled...\"\n\n            pruned_alpha_set = pruned_alpha_set.to_cpu()\n\n            alpha_set = pruned_alpha_set.alpha_vector_array\n            non_dominated_vector_indices = []\n\n            for i, alpha_vect in enumerate(alpha_set):\n                other_alphas = alpha_set[:i] + alpha_set[(i+1):]\n\n                # Objective function\n                c = np.concatenate([np.array([1]), -1*alpha_vect])\n\n                # Alpha vector contraints\n                other_count = len(other_alphas)\n                A = np.c_[np.ones(other_count), np.multiply(np.array(other_alphas), -1)]\n                alpha_constraints = LinearConstraint(A, 0, np.inf)\n\n                # Constraints that sum of beliefs is 1\n                belief_constraint = LinearConstraint(np.array([0] + ([1]*self.model.state_count)), 1, 1)\n\n                # Solve problem\n                res = milp(c=c, constraints=[alpha_constraints, belief_constraint])\n\n                # Check if dominated\n                is_dominated = (res.x[0] - np.dot(res.x[1:], alpha_vect)) &gt;= 0\n                if is_dominated:\n                    print(alpha_vect)\n                    print(' -&gt; Dominated\\n')\n                else:\n                    non_dominated_vector_indices.append(i)\n\n            self._vector_array = self._vector_array[non_dominated_vector_indices]\n            self._actions = self._actions[non_dominated_vector_indices]\n\n        # Update the tracked pruned level so far\n        self._pruning_level = level\n\n\n    def evaluate_at(self,\n                    belief: Belief | BeliefSet\n                    ) -&gt; tuple[float | np.ndarray, int | np.ndarray]:\n        '''\n        Function to evaluate the value function at a belief point or at a set of belief points.\n        It returns a value and the associated action.\n\n        Parameters\n        ----------\n        belief : Belief or BeliefSet\n\n        Returns\n        -------\n        value : float or np.ndarray\n            The largest value associated with the belief point(s)\n        action : int or np.ndarray\n            The action(s) associated with the vector having the highest values at the belief point(s).\n        '''\n        # GPU support check\n        xp = cp if (gpu_support and self.is_on_gpu) else np\n\n        best_value = None\n        best_action = None\n\n        if isinstance(belief, Belief):\n            # Computing values\n            belief_values = xp.dot(self.alpha_vector_array, belief.values)\n\n            # Selecting best vectors\n            best_vector = xp.argmax(belief_values)\n\n            # From best vector, compute the best value and action\n            best_value = float(belief_values[best_vector])\n            best_action = int(self.actions[best_vector])\n        else:\n            # Computing values\n            belief_values = xp.matmul(belief.values if isinstance(belief, Belief) else belief.belief_array, self.alpha_vector_array.T)\n\n            # Retrieving the top vectors according to the value function\n            best_vectors = xp.argmax(belief_values, axis=1)\n\n            # Retrieving the values and actions associated with the vectors chosen\n            best_value = belief_values[xp.arange(belief_values.shape[0]), best_vectors]\n            best_action = self.actions[best_vectors]\n\n        return (best_value, best_action)\n\n\n    def save(self,\n             folder: str = './ValueFunctions',\n             file_name: str | None = None\n             ) -&gt; None:\n        '''\n        Function to save the value function in a file at a given path. If no path is provided, it will be saved in a subfolder (ValueFunctions) inside the current working directory.\n        If no file_name is provided, it be saved as '&lt;current_timestamp&gt;_value_function.csv'.\n\n        Parameters\n        ----------\n        folder : str, default='./ValueFunctions'\n            The path at which the npy file will be saved.\n        file_name : str, default='&lt;current_timestamp&gt;_value_function.npy'\n            The file name used to save in.\n        '''\n        if self.is_on_gpu:\n            self.to_cpu().save(path=folder, file_name=file_name)\n            return\n\n        # Handle file_name\n        if file_name is None:\n            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n            file_name = timestamp + '_value_function.npy'\n\n        # Make sure that .csv is in the file name\n        if '.npy' not in file_name:\n            file_name += '.npy'\n\n        # Getting array\n        av_array = np.hstack([self.actions[:,None], self.alpha_vector_array])\n\n        np.save(folder + '/' + file_name, av_array)\n\n\n    @classmethod\n    def load(cls,\n             file: str,\n             model: Model\n             ) -&gt; 'ValueFunction':\n        '''\n        Function to load the value function from a csv file.\n\n        Parameters\n        ----------\n        file : str\n            The path and file_name of the value function to be loaded.\n        model : mdp.Model\n            The model the value function is linked to.\n\n        Returns\n        -------\n        loaded_value_function : ValueFunction\n            The loaded value function.\n        '''\n        av_array = np.load(file)\n\n        loaded_value_function = ValueFunction(model=model,\n                                              alpha_vectors=av_array[:,1:],\n                                              action_list=av_array[:,0].astype(int))\n\n        return loaded_value_function\n\n\n    def plot(self,\n             as_grid: bool = False,\n             size: int = 5,\n             belief_set: np.ndarray = None\n             ) -&gt; None:\n        '''\n        Function to plot out the value function in 2 or 3 dimensions if possible and the as_grid parameter is kept to false. Else, the value function is plot as a grid.\n        If a belief set array is provided and the model is a 2- or 3-model, it will be plot alongside the value function.\n\n        Parameters\n        ----------\n        as_grid : bool, default=False\n            Forces the plot to be plot as a grid.\n        size : int, default=5\n            The actual plot scale.\n        belief_set : np.ndarray, optional\n            A set of belief to plot the belief points that were explored.\n        '''\n        assert len(self) &gt; 0, \"Value function is empty, plotting is impossible...\"\n\n        # If on GPU, convert to CPU and plot that one\n        if self.is_on_gpu:\n            print('[Warning] Value function on GPU, converting to numpy before plotting...')\n            cpu_value_function = self.to_cpu()\n            cpu_value_function.plot(as_grid, size, belief_set)\n            return\n\n        func = None\n        if as_grid:\n            func = self._plot_grid\n        elif self.model.state_count == 2:\n            func = self._plot_2D\n        elif self.model.state_count == 3:\n            func = self._plot_3D\n        else:\n            print('[Warning] \\'as_grid\\' parameter set to False but state count is &gt;3 so it will be plotted as a grid')\n            func = self._plot_grid\n\n        func(size, belief_set)\n\n\n    def _plot_2D(self, size, belief_set=None):\n        x = np.linspace(0, 1, 100)\n\n        plt.figure(figsize=(int(size*1.5),size))\n        grid_spec = {'height_ratios': ([1] if belief_set is None else [19,1])}\n        _, ax = plt.subplots((2 if belief_set is not None else 1),1,sharex=True,gridspec_kw=grid_spec)\n\n        # Vector plotting\n        alpha_vects = self.alpha_vector_array\n\n        m = alpha_vects[:,1] - alpha_vects[:,0] # type: ignore\n        m = m.reshape(m.shape[0],1)\n\n        x = x.reshape((1,x.shape[0])).repeat(m.shape[0],axis=0)\n        y = (m*x) + alpha_vects[:,0].reshape(m.shape[0],1)\n\n        ax0 = ax[0] if belief_set is not None else ax\n        for i, alpha in enumerate(self.alpha_vector_list):\n            ax0.plot(x[i,:], y[i,:], color=COLOR_LIST[alpha.action]['id']) # type: ignore\n\n        # Set title\n        title = 'Value function' + ('' if belief_set is None else ' and explored belief points')\n        ax0.set_title(title)\n\n        # X-axis setting\n        ticks = [0,0.25,0.5,0.75,1]\n        x_ticks = [str(t) for t in ticks]\n        x_ticks[0] = self.model.state_labels[0]\n        x_ticks[-1] = self.model.state_labels[1]\n\n        ax0.set_xticks(ticks, x_ticks) # type: ignore\n\n        # Action legend\n        proxy = [patches.Rectangle((0,0),1,1,fc = COLOR_LIST[a]['id']) for a in self.model.actions]\n        ax0.legend(proxy, self.model.action_labels, title='Actions') # type: ignore\n\n        # Belief plotting\n        if belief_set is not None:\n            beliefs_x = belief_set.belief_array[:,1]\n            ax[1].scatter(beliefs_x, np.zeros(beliefs_x.shape[0]), c='red')\n            ax[1].get_yaxis().set_visible(False)\n            ax[1].axhline(0, color='black')\n            ax[1].set_xlabel('Belief space')\n        else:\n            ax0.set_xlabel('Belief space')\n\n        # Axis labels\n        ax0.set_ylabel('V(b)')\n\n\n    def _plot_3D(self, size, belief_set=None):\n\n        def get_alpha_vect_z(xx, yy, alpha_vect):\n            x0, y0, z0 = [0, 0, alpha_vect[0]]\n            x1, y1, z1 = [1, 0, alpha_vect[1]]\n            x2, y2, z2 = [0, 1, alpha_vect[2]]\n\n            ux, uy, uz = u = [x1-x0, y1-y0, z1-z0]\n            vx, vy, vz = v = [x2-x0, y2-y0, z2-z0]\n\n            u_cross_v = [uy*vz-uz*vy, uz*vx-ux*vz, ux*vy-uy*vx]\n\n            point  = np.array([0, 0, alpha_vect[0]])\n            normal = np.array(u_cross_v)\n\n            d = -point.dot(normal)\n\n            z = (-normal[0] * xx - normal[1] * yy - d) * 1. / normal[2]\n\n            return z\n\n        def get_plane_gradient(alpha_vect):\n\n            x0, y0, z0 = [0, 0, alpha_vect[0]]\n            x1, y1, z1 = [1, 0, alpha_vect[1]]\n            x2, y2, z2 = [0, 1, alpha_vect[2]]\n\n            ux, uy, uz = u = [x1-x0, y1-y0, z1-z0]\n            vx, vy, vz = v = [x2-x0, y2-y0, z2-z0]\n\n            u_cross_v = [uy*vz-uz*vy, uz*vx-ux*vz, ux*vy-uy*vx]\n\n            normal_vector = np.array(u_cross_v)\n            normal_vector_norm = float(np.linalg.norm(normal_vector))\n            normal_vector = np.divide(normal_vector, normal_vector_norm)\n            normal_vector[2] = 0\n\n            return np.linalg.norm(normal_vector)\n\n        # Actual plotting\n        x = np.linspace(0, 1, 1000)\n        y = np.linspace(0, 1, 1000)\n\n        xx, yy = np.meshgrid(x, y)\n\n        max_z = np.zeros((xx.shape[0], yy.shape[0]))\n        best_a = (np.zeros((xx.shape[0], yy.shape[0])))\n        plane = (np.zeros((xx.shape[0], yy.shape[0])))\n        gradients = (np.zeros((xx.shape[0], yy.shape[0])))\n\n        for alpha in self.alpha_vector_list:\n\n            z = get_alpha_vect_z(xx, yy, alpha.values)\n\n            # Action array update\n            new_a_mask = np.argmax(np.array([max_z, z]), axis=0)\n\n            best_a[new_a_mask == 1] = alpha.action\n\n            plane[new_a_mask == 1] = random.randrange(100)\n\n            alpha_gradient = get_plane_gradient(alpha.values)\n            gradients[new_a_mask == 1] = alpha_gradient\n\n            # Max z update\n            max_z = np.max(np.array([max_z, z]), axis=0)\n\n        for x_i, x_val in enumerate(x):\n            for y_i, y_val in enumerate(y):\n                if (x_val+y_val) &gt; 1:\n                    max_z[x_i, y_i] = np.nan\n                    plane[x_i, y_i] = np.nan\n                    gradients[x_i, y_i] = np.nan\n                    best_a[x_i, y_i] = np.nan\n\n        belief_points = None\n        if belief_set is not None:\n            belief_points = belief_set.belief_array[:,1:]\n\n        fig, ((ax1, ax2),(ax3,ax4)) = plt.subplots(2, 2, figsize=(size*4,size*3.5), sharex=True, sharey=True)\n\n        # Set ticks\n        ticks = [0,0.25,0.5,0.75,1]\n        x_ticks = [str(t) for t in ticks]\n        x_ticks[0] = self.model.state_labels[0]\n        x_ticks[-1] = self.model.state_labels[1]\n\n        y_ticks = [str(t) for t in ticks]\n        y_ticks[0] = self.model.state_labels[0]\n        y_ticks[-1] = self.model.state_labels[2]\n\n        plt.setp([ax1,ax2,ax3,ax4], xticks=ticks, xticklabels=x_ticks, yticks=ticks, yticklabels=y_ticks)\n\n        # Value function ax\n        ax1.set_title(\"Value function\")\n        ax1_plot = ax1.contourf(x, y, max_z, 100, cmap=\"viridis\")\n        plt.colorbar(ax1_plot, ax=ax1)\n\n        # Alpha planes ax\n        ax2.set_title(\"Alpha planes\")\n        ax2_plot = ax2.contourf(x, y, plane, 100, cmap=\"viridis\")\n        plt.colorbar(ax2_plot, ax=ax2)\n\n        # Gradient of planes ax\n        ax3.set_title(\"Gradients of planes\")\n        ax3_plot = ax3.contourf(x, y, gradients, 100, cmap=\"Blues\")\n        plt.colorbar(ax3_plot, ax=ax3)\n\n        # Action policy ax\n        ax4.set_title(\"Action policy\")\n        ax4.contourf(x, y, best_a, 1, colors=[c['id'] for c in COLOR_LIST])\n        proxy = [patches.Rectangle((0,0),1,1,fc = COLOR_LIST[int(a)]['id']) for a in self.model.actions]\n        ax4.legend(proxy, self.model.action_labels, title='Actions')\n\n        if belief_points is not None:\n            for ax in [ax1,ax2,ax3,ax4]:\n                ax.scatter(belief_points[:,0], belief_points[:,1], s=1, c='black')\n\n\n    def _plot_grid(self, size=5, belief_set=None):\n        value_table = np.max(self.alpha_vector_array, axis=0)[self.model.state_grid]\n        best_action_table = np.array(self.actions)[np.argmax(self.alpha_vector_array, axis=0)][self.model.state_grid]\n        best_action_colors = COLOR_ARRAY[best_action_table]\n\n        dimensions = self.model.state_grid.shape\n\n        fig, (ax1,ax2) = plt.subplots(1,2, figsize=(size*2, size), width_ratios=(0.55,0.45))\n\n        # Ticks\n        x_ticks = np.arange(0, dimensions[1], (1 if dimensions[1] &lt; 10 else int(dimensions[1] / 10)))\n        y_ticks = np.arange(0, dimensions[0], (1 if dimensions[0] &lt; 5 else int(dimensions[0] / 5)))\n\n        ax1.set_title('Value function')\n        ax1_plot = ax1.imshow(value_table)\n\n        if dimensions[0] &gt;= dimensions[1]: # If higher than wide \n            plt.colorbar(ax1_plot, ax=ax1)\n        else:\n            plt.colorbar(ax1_plot, ax=ax1, location='bottom', orientation='horizontal')\n\n        ax1.set_xticks(x_ticks)\n        ax1.set_yticks(y_ticks)\n\n        ax2.set_title('Action policy')\n        ax2.imshow(best_action_colors)\n        p = [ patches.Patch(color=COLOR_LIST[int(i)]['id'], label=str(self.model.action_labels[int(i)])) for i in self.model.actions]\n        ax2.legend(handles=p, bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0., title='Actions')\n        ax2.set_xticks(x_ticks)\n        ax2.set_yticks(y_ticks)\n</code></pre>"},{"location":"reference/agents/model_based_util/value_function/#olfactory_navigation.agents.model_based_util.value_function.ValueFunction.actions","title":"<code>actions</code>  <code>property</code>","text":"<p>A list of N actions corresponding to the N alpha vectors making up the value function. If the value function is defined as a list of AlphaVector objects, the list will the generated from the actions of those alpha vector objects.</p>"},{"location":"reference/agents/model_based_util/value_function/#olfactory_navigation.agents.model_based_util.value_function.ValueFunction.alpha_vector_array","title":"<code>alpha_vector_array</code>  <code>property</code>","text":"<p>A matrix of size N x S, containing all the alpha vectors making up the value function. (N is the number of alpha vectors and S the amount of states in the model) If the value function is defined as a list of AlphaVector objects, the matrix will the generated from them.</p>"},{"location":"reference/agents/model_based_util/value_function/#olfactory_navigation.agents.model_based_util.value_function.ValueFunction.alpha_vector_list","title":"<code>alpha_vector_list</code>  <code>property</code>","text":"<p>A list of AlphaVector objects. If the value function is defined as an matrix of vectors and a list of actions, the list of AlphaVectors will be generated from them.</p>"},{"location":"reference/agents/model_based_util/value_function/#olfactory_navigation.agents.model_based_util.value_function.ValueFunction.append","title":"<code>append(alpha_vector)</code>","text":"<p>Function to add an alpha vector to the value function.</p> <p>Parameters:</p> Name Type Description Default <code>alpha_vector</code> <code>AlphaVector</code> <p>The alpha vector to be added to the value function.</p> required Source code in <code>olfactory_navigation/agents/model_based_util/value_function.py</code> <pre><code>def append(self,\n           alpha_vector: AlphaVector\n           ) -&gt; None:\n    '''\n    Function to add an alpha vector to the value function.\n\n    Parameters\n    ----------\n    alpha_vector : AlphaVector\n        The alpha vector to be added to the value function.\n    '''\n    # Make sure size is correct\n    assert alpha_vector.values.shape[0] == self.model.state_count, f\"Vector to add to value function doesn't have the right size (received: {alpha_vector.values.shape[0]}, expected: {self.model.state_count})\"\n\n    # GPU support check\n    xp = cp if (gpu_support and self.is_on_gpu) else np\n    assert gpu_support and cp.get_array_module(alpha_vector.values) == xp, f\"Vector is{' not' if self.is_on_gpu else ''} on GPU while value function is{'' if self.is_on_gpu else ' not'}.\"\n\n    if self._vector_array is not None:\n        self._vector_array = xp.append(self._vector_array, alpha_vector[None,:], axis=0)\n        self._actions = xp.append(self._actions, alpha_vector.action)\n\n    if self._vector_list is not None:\n        self._vector_list.append(alpha_vector)\n</code></pre>"},{"location":"reference/agents/model_based_util/value_function/#olfactory_navigation.agents.model_based_util.value_function.ValueFunction.evaluate_at","title":"<code>evaluate_at(belief)</code>","text":"<p>Function to evaluate the value function at a belief point or at a set of belief points. It returns a value and the associated action.</p> <p>Parameters:</p> Name Type Description Default <code>belief</code> <code>Belief or BeliefSet</code> required <p>Returns:</p> Name Type Description <code>value</code> <code>float or ndarray</code> <p>The largest value associated with the belief point(s)</p> <code>action</code> <code>int or ndarray</code> <p>The action(s) associated with the vector having the highest values at the belief point(s).</p> Source code in <code>olfactory_navigation/agents/model_based_util/value_function.py</code> <pre><code>def evaluate_at(self,\n                belief: Belief | BeliefSet\n                ) -&gt; tuple[float | np.ndarray, int | np.ndarray]:\n    '''\n    Function to evaluate the value function at a belief point or at a set of belief points.\n    It returns a value and the associated action.\n\n    Parameters\n    ----------\n    belief : Belief or BeliefSet\n\n    Returns\n    -------\n    value : float or np.ndarray\n        The largest value associated with the belief point(s)\n    action : int or np.ndarray\n        The action(s) associated with the vector having the highest values at the belief point(s).\n    '''\n    # GPU support check\n    xp = cp if (gpu_support and self.is_on_gpu) else np\n\n    best_value = None\n    best_action = None\n\n    if isinstance(belief, Belief):\n        # Computing values\n        belief_values = xp.dot(self.alpha_vector_array, belief.values)\n\n        # Selecting best vectors\n        best_vector = xp.argmax(belief_values)\n\n        # From best vector, compute the best value and action\n        best_value = float(belief_values[best_vector])\n        best_action = int(self.actions[best_vector])\n    else:\n        # Computing values\n        belief_values = xp.matmul(belief.values if isinstance(belief, Belief) else belief.belief_array, self.alpha_vector_array.T)\n\n        # Retrieving the top vectors according to the value function\n        best_vectors = xp.argmax(belief_values, axis=1)\n\n        # Retrieving the values and actions associated with the vectors chosen\n        best_value = belief_values[xp.arange(belief_values.shape[0]), best_vectors]\n        best_action = self.actions[best_vectors]\n\n    return (best_value, best_action)\n</code></pre>"},{"location":"reference/agents/model_based_util/value_function/#olfactory_navigation.agents.model_based_util.value_function.ValueFunction.extend","title":"<code>extend(other_value_function)</code>","text":"<p>Function to add another value function is place. Effectively, it performs the union of the two sets of alpha vectors.</p> <p>Parameters:</p> Name Type Description Default <code>other_value_function</code> <code>ValueFunction</code> <p>The other side of the union.</p> required Source code in <code>olfactory_navigation/agents/model_based_util/value_function.py</code> <pre><code>def extend(self,\n           other_value_function: 'Model'\n           ) -&gt; None:\n    '''\n    Function to add another value function is place.\n    Effectively, it performs the union of the two sets of alpha vectors.\n\n    Parameters\n    ----------\n    other_value_function : ValueFunction\n        The other side of the union.\n    '''\n    self._uniqueness_dict.update(other_value_function._uniqueness_dict)\n    self._vector_list = list(self._uniqueness_dict.values())\n\n    self._vector_array = None\n    self._actions = None\n\n    self._pruning_level = 1\n</code></pre>"},{"location":"reference/agents/model_based_util/value_function/#olfactory_navigation.agents.model_based_util.value_function.ValueFunction.load","title":"<code>load(file, model)</code>  <code>classmethod</code>","text":"<p>Function to load the value function from a csv file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>The path and file_name of the value function to be loaded.</p> required <code>model</code> <code>Model</code> <p>The model the value function is linked to.</p> required <p>Returns:</p> Name Type Description <code>loaded_value_function</code> <code>ValueFunction</code> <p>The loaded value function.</p> Source code in <code>olfactory_navigation/agents/model_based_util/value_function.py</code> <pre><code>@classmethod\ndef load(cls,\n         file: str,\n         model: Model\n         ) -&gt; 'ValueFunction':\n    '''\n    Function to load the value function from a csv file.\n\n    Parameters\n    ----------\n    file : str\n        The path and file_name of the value function to be loaded.\n    model : mdp.Model\n        The model the value function is linked to.\n\n    Returns\n    -------\n    loaded_value_function : ValueFunction\n        The loaded value function.\n    '''\n    av_array = np.load(file)\n\n    loaded_value_function = ValueFunction(model=model,\n                                          alpha_vectors=av_array[:,1:],\n                                          action_list=av_array[:,0].astype(int))\n\n    return loaded_value_function\n</code></pre>"},{"location":"reference/agents/model_based_util/value_function/#olfactory_navigation.agents.model_based_util.value_function.ValueFunction.plot","title":"<code>plot(as_grid=False, size=5, belief_set=None)</code>","text":"<p>Function to plot out the value function in 2 or 3 dimensions if possible and the as_grid parameter is kept to false. Else, the value function is plot as a grid. If a belief set array is provided and the model is a 2- or 3-model, it will be plot alongside the value function.</p> <p>Parameters:</p> Name Type Description Default <code>as_grid</code> <code>bool</code> <p>Forces the plot to be plot as a grid.</p> <code>False</code> <code>size</code> <code>int</code> <p>The actual plot scale.</p> <code>5</code> <code>belief_set</code> <code>ndarray</code> <p>A set of belief to plot the belief points that were explored.</p> <code>None</code> Source code in <code>olfactory_navigation/agents/model_based_util/value_function.py</code> <pre><code>def plot(self,\n         as_grid: bool = False,\n         size: int = 5,\n         belief_set: np.ndarray = None\n         ) -&gt; None:\n    '''\n    Function to plot out the value function in 2 or 3 dimensions if possible and the as_grid parameter is kept to false. Else, the value function is plot as a grid.\n    If a belief set array is provided and the model is a 2- or 3-model, it will be plot alongside the value function.\n\n    Parameters\n    ----------\n    as_grid : bool, default=False\n        Forces the plot to be plot as a grid.\n    size : int, default=5\n        The actual plot scale.\n    belief_set : np.ndarray, optional\n        A set of belief to plot the belief points that were explored.\n    '''\n    assert len(self) &gt; 0, \"Value function is empty, plotting is impossible...\"\n\n    # If on GPU, convert to CPU and plot that one\n    if self.is_on_gpu:\n        print('[Warning] Value function on GPU, converting to numpy before plotting...')\n        cpu_value_function = self.to_cpu()\n        cpu_value_function.plot(as_grid, size, belief_set)\n        return\n\n    func = None\n    if as_grid:\n        func = self._plot_grid\n    elif self.model.state_count == 2:\n        func = self._plot_2D\n    elif self.model.state_count == 3:\n        func = self._plot_3D\n    else:\n        print('[Warning] \\'as_grid\\' parameter set to False but state count is &gt;3 so it will be plotted as a grid')\n        func = self._plot_grid\n\n    func(size, belief_set)\n</code></pre>"},{"location":"reference/agents/model_based_util/value_function/#olfactory_navigation.agents.model_based_util.value_function.ValueFunction.prune","title":"<code>prune(level=1)</code>","text":"<p>Function pruning the set of alpha vectors composing the value function. The pruning is as thorough as the level:     - 2: 1+ Check of absolute domination (check if dominated at each state).     - 3: 2+ Solves Linear Programming problem for each alpha vector to see if it is dominated by combinations of other vectors.</p> <p>Note that the higher the level, the heavier the time impact will be.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>Between 0 and 3, how thorough the alpha vector pruning should be.</p> <code>1</code> Source code in <code>olfactory_navigation/agents/model_based_util/value_function.py</code> <pre><code>def prune(self,\n          level: int = 1\n          ) -&gt; None:\n    '''\n    Function pruning the set of alpha vectors composing the value function.\n    The pruning is as thorough as the level:\n        - 2: 1+ Check of absolute domination (check if dominated at each state).\n        - 3: 2+ Solves Linear Programming problem for each alpha vector to see if it is dominated by combinations of other vectors.\n\n    Note that the higher the level, the heavier the time impact will be.\n\n    Parameters\n    ----------\n    level : int, default=1\n        Between 0 and 3, how thorough the alpha vector pruning should be.\n    '''\n    # GPU support check\n    xp = cp if (gpu_support and self.is_on_gpu) else np\n\n    # Level 1 or under\n    if level &lt; self._pruning_level or level &gt; 3:\n        log('Attempting to prune a value function to a level already reached. Returning \\'self\\'')\n        return\n\n    # Level 2 pruning: Check for absolute domination\n    if level &gt;= 2 and self._pruning_level &lt; 2:\n        non_dominated_vector_indices = []\n\n        for i, v in enumerate(self.alpha_vector_array):\n            is_dom_by = xp.all(self.alpha_vector_array &gt;= v, axis=1)\n            if len(xp.where(is_dom_by)[0]) == 1:\n                non_dominated_vector_indices.append(i)\n\n        self._vector_array = self._vector_array[non_dominated_vector_indices]\n        self._actions = self._actions[non_dominated_vector_indices]\n\n    # Level 3 pruning: LP to check for more complex domination\n    if level &gt;= 3:\n        assert ilp_support, \"ILP support not enabled...\"\n\n        pruned_alpha_set = pruned_alpha_set.to_cpu()\n\n        alpha_set = pruned_alpha_set.alpha_vector_array\n        non_dominated_vector_indices = []\n\n        for i, alpha_vect in enumerate(alpha_set):\n            other_alphas = alpha_set[:i] + alpha_set[(i+1):]\n\n            # Objective function\n            c = np.concatenate([np.array([1]), -1*alpha_vect])\n\n            # Alpha vector contraints\n            other_count = len(other_alphas)\n            A = np.c_[np.ones(other_count), np.multiply(np.array(other_alphas), -1)]\n            alpha_constraints = LinearConstraint(A, 0, np.inf)\n\n            # Constraints that sum of beliefs is 1\n            belief_constraint = LinearConstraint(np.array([0] + ([1]*self.model.state_count)), 1, 1)\n\n            # Solve problem\n            res = milp(c=c, constraints=[alpha_constraints, belief_constraint])\n\n            # Check if dominated\n            is_dominated = (res.x[0] - np.dot(res.x[1:], alpha_vect)) &gt;= 0\n            if is_dominated:\n                print(alpha_vect)\n                print(' -&gt; Dominated\\n')\n            else:\n                non_dominated_vector_indices.append(i)\n\n        self._vector_array = self._vector_array[non_dominated_vector_indices]\n        self._actions = self._actions[non_dominated_vector_indices]\n\n    # Update the tracked pruned level so far\n    self._pruning_level = level\n</code></pre>"},{"location":"reference/agents/model_based_util/value_function/#olfactory_navigation.agents.model_based_util.value_function.ValueFunction.save","title":"<code>save(folder='./ValueFunctions', file_name=None)</code>","text":"<p>Function to save the value function in a file at a given path. If no path is provided, it will be saved in a subfolder (ValueFunctions) inside the current working directory. If no file_name is provided, it be saved as '_value_function.csv'. <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>The path at which the npy file will be saved.</p> <code>'./ValueFunctions'</code> <code>file_name</code> <code>str</code> <p>The file name used to save in.</p> <code>'&lt;current_timestamp&gt;_value_function.npy'</code> Source code in <code>olfactory_navigation/agents/model_based_util/value_function.py</code> <pre><code>def save(self,\n         folder: str = './ValueFunctions',\n         file_name: str | None = None\n         ) -&gt; None:\n    '''\n    Function to save the value function in a file at a given path. If no path is provided, it will be saved in a subfolder (ValueFunctions) inside the current working directory.\n    If no file_name is provided, it be saved as '&lt;current_timestamp&gt;_value_function.csv'.\n\n    Parameters\n    ----------\n    folder : str, default='./ValueFunctions'\n        The path at which the npy file will be saved.\n    file_name : str, default='&lt;current_timestamp&gt;_value_function.npy'\n        The file name used to save in.\n    '''\n    if self.is_on_gpu:\n        self.to_cpu().save(path=folder, file_name=file_name)\n        return\n\n    # Handle file_name\n    if file_name is None:\n        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n        file_name = timestamp + '_value_function.npy'\n\n    # Make sure that .csv is in the file name\n    if '.npy' not in file_name:\n        file_name += '.npy'\n\n    # Getting array\n    av_array = np.hstack([self.actions[:,None], self.alpha_vector_array])\n\n    np.save(folder + '/' + file_name, av_array)\n</code></pre>"},{"location":"reference/agents/model_based_util/value_function/#olfactory_navigation.agents.model_based_util.value_function.ValueFunction.to_cpu","title":"<code>to_cpu()</code>","text":"<p>Function returning an equivalent value function object with the arrays stored on CPU instead of GPU.</p> <p>Returns:</p> Name Type Description <code>cpu_value_function</code> <code>ValueFunction</code> <p>A new value function with arrays on CPU.</p> Source code in <code>olfactory_navigation/agents/model_based_util/value_function.py</code> <pre><code>def to_cpu(self) -&gt; 'ValueFunction':\n    '''\n    Function returning an equivalent value function object with the arrays stored on CPU instead of GPU.\n\n    Returns\n    -------\n    cpu_value_function : ValueFunction\n        A new value function with arrays on CPU.\n    '''\n    assert gpu_support, \"GPU support is not enabled, unable to execute this function\"\n\n    cpu_model = self.model.cpu_model\n\n    cpu_value_function = None\n    if self._vector_list is not None:\n        cpu_alpha_vectors = [AlphaVector(cp.asnumpy(av.values), av.action) for av in self._vector_list]\n        cpu_value_function = ValueFunction(cpu_model, cpu_alpha_vectors)\n\n    else:\n        cpu_vector_array = cp.asnumpy(self._vector_array)\n        cpu_actions = self._actions if isinstance(self._actions, list) else cp.asnumpy(self._actions)\n        cpu_value_function = ValueFunction(cpu_model, cpu_vector_array, cpu_actions)\n\n    return cpu_value_function\n</code></pre>"},{"location":"reference/agents/model_based_util/value_function/#olfactory_navigation.agents.model_based_util.value_function.ValueFunction.to_gpu","title":"<code>to_gpu()</code>","text":"<p>Function returning an equivalent value function object with the arrays stored on GPU instead of CPU.</p> <p>Returns:</p> Name Type Description <code>gpu_value_function</code> <code>ValueFunction</code> <p>A new value function with arrays on GPU.</p> Source code in <code>olfactory_navigation/agents/model_based_util/value_function.py</code> <pre><code>def to_gpu(self) -&gt; 'ValueFunction':\n    '''\n    Function returning an equivalent value function object with the arrays stored on GPU instead of CPU.\n\n    Returns\n    -------\n    gpu_value_function : ValueFunction\n        A new value function with arrays on GPU.\n    '''\n    assert gpu_support, \"GPU support is not enabled, unable to execute this function\"\n\n    gpu_model = self.model.gpu_model\n\n    gpu_value_function = None\n    if self._vector_list is not None:\n        gpu_alpha_vectors = [AlphaVector(cp.array(av.values), av.action) for av in self._vector_list]\n        gpu_value_function = ValueFunction(gpu_model, gpu_alpha_vectors)\n\n    else:\n        gpu_vector_array = cp.array(self._vector_array)\n        gpu_actions = self._actions if isinstance(self._actions, list) else cp.array(self._actions)\n        gpu_value_function = ValueFunction(gpu_model, gpu_vector_array, gpu_actions)\n\n    return gpu_value_function\n</code></pre>"},{"location":"reference/agents/model_based_util/vi_solver/","title":"vi_solver","text":""},{"location":"reference/agents/model_based_util/vi_solver/#olfactory_navigation.agents.model_based_util.vi_solver.SolverHistory","title":"<code>SolverHistory</code>","text":"<p>Class to represent the solving history of a solver. The purpose of this class is to allow plotting of the solution and plotting the evolution of the value function over the training process. This class is not meant to be instanciated manually, it meant to be used when returned by the solve() method of a Solver object.</p> <p>Parameters:</p> Name Type Description Default <code>tracking_level</code> <code>int</code> <p>The tracking level of the solver.</p> required <code>model</code> <code>Model</code> <p>The model that has been solved by the Solver.</p> required <code>gamma</code> <code>float</code> <p>The gamma parameter used by the solver (learning rate).</p> required <code>eps</code> <code>float</code> <p>The epsilon parameter used by the solver (covergence bound).</p> required <code>initial_value_function</code> <code>ValueFunction</code> <p>The initial value function the solver will use to start the solving process.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>tracking_level</code> <code>int</code> <code>model</code> <code>Model</code> <code>gamma</code> <code>float</code> <code>eps</code> <code>float</code> <code>run_ts</code> <code>datetime</code> <p>The time at which the SolverHistory object was instantiated which is assumed to be the start of the solving run.</p> <code>iteration_times</code> <code>list[float]</code> <p>A list of recorded iteration times.</p> <code>value_function_changes</code> <code>list[float]</code> <p>A list of recorded value function changes (the maximum changed value between 2 value functions).</p> <code>value_functions</code> <code>list[ValueFunction]</code> <p>A list of recorded value functions.</p> <code>solution</code> <code>ValueFunction</code> <code>summary</code> <code>str</code> Source code in <code>olfactory_navigation/agents/model_based_util/vi_solver.py</code> <pre><code>class SolverHistory:\n    '''\n    Class to represent the solving history of a solver.\n    The purpose of this class is to allow plotting of the solution and plotting the evolution of the value function over the training process.\n    This class is not meant to be instanciated manually, it meant to be used when returned by the solve() method of a Solver object.\n\n\n    Parameters\n    ----------\n    tracking_level : int\n        The tracking level of the solver.\n    model : mdp.Model\n        The model that has been solved by the Solver.\n    gamma : float\n        The gamma parameter used by the solver (learning rate).\n    eps : float\n        The epsilon parameter used by the solver (covergence bound).\n    initial_value_function : ValueFunction, optional\n        The initial value function the solver will use to start the solving process.\n\n    Attributes\n    ----------\n    tracking_level : int\n    model : mdp.Model\n    gamma : float\n    eps : float\n    run_ts : datetime\n        The time at which the SolverHistory object was instantiated which is assumed to be the start of the solving run.\n    iteration_times : list[float]\n        A list of recorded iteration times.\n    value_function_changes : list[float]\n        A list of recorded value function changes (the maximum changed value between 2 value functions).\n    value_functions : list[ValueFunction]\n        A list of recorded value functions.\n    solution : ValueFunction\n    summary : str\n    '''\n    def __init__(self,\n                 tracking_level: int,\n                 model: Model,\n                 gamma: float,\n                 eps: float,\n                 initial_value_function: ValueFunction | None = None\n                 ) -&gt; None:\n        self.tracking_level = tracking_level\n        self.model = model\n        self.gamma = gamma\n        self.eps = eps\n        self.run_ts = datetime.now()\n\n        # Tracking metrics\n        self.iteration_times = []\n        self.value_function_changes = []\n\n        self.value_functions = []\n        if self.tracking_level &gt;= 2:\n            self.value_functions.append(initial_value_function)\n\n\n    @property\n    def solution(self) -&gt; ValueFunction:\n        '''\n        The last value function of the solving process.\n        '''\n        assert self.tracking_level &gt;= 2, \"Tracking level is set too low, increase it to 2 if you want to have value function tracking as well.\"\n        return self.value_functions[-1]\n\n\n    def add(self,\n            iteration_time: float,\n            value_function_change: float,\n            value_function: ValueFunction\n            ) -&gt; None:\n        '''\n        Function to add a step in the simulation history.\n\n        Parameters\n        ----------\n        iteration_time : float\n            The time it took to run the iteration.\n        value_function_change : float\n            The change between the value function of this iteration and of the previous iteration.\n        value_function : ValueFunction\n            The value function resulting after a step of the solving process.\n        '''\n        if self.tracking_level &gt;= 1:\n            self.iteration_times.append(float(iteration_time))\n            self.value_function_changes.append(float(value_function_change))\n\n        if self.tracking_level &gt;= 2:\n            self.value_functions.append(value_function if not value_function.is_on_gpu else value_function.to_cpu())\n\n\n    @property\n    def summary(self) -&gt; str:\n        '''\n        A summary as a string of the information recorded.\n        '''\n        summary_str =  f'Summary of Value Iteration run'\n        summary_str += f'\\n  - Model: {self.model.state_count}-state, {self.model.action_count}-action'\n        summary_str += f'\\n  - Converged in {len(self.iteration_times)} iterations and {sum(self.iteration_times):.4f} seconds'\n\n        if self.tracking_level &gt;= 1:\n            summary_str += f'\\n  - Took on average {sum(self.iteration_times) / len(self.iteration_times):.4f}s per iteration'\n\n        return summary_str\n\n\n    def plot_changes(self) -&gt; None:\n        '''\n        Function to plot the value function changes over the solving process.\n        '''\n        assert self.tracking_level &gt;= 1, \"To plot the change of the value function over time, use tracking level 1 or higher.\"\n\n        plt.title('Value function change over time')\n        plt.plot(np.arange(len(self.value_function_changes)), self.value_function_changes)\n        plt.xlabel('Iteration')\n        plt.ylabel('Value function change')\n        plt.show()\n</code></pre>"},{"location":"reference/agents/model_based_util/vi_solver/#olfactory_navigation.agents.model_based_util.vi_solver.SolverHistory.solution","title":"<code>solution</code>  <code>property</code>","text":"<p>The last value function of the solving process.</p>"},{"location":"reference/agents/model_based_util/vi_solver/#olfactory_navigation.agents.model_based_util.vi_solver.SolverHistory.summary","title":"<code>summary</code>  <code>property</code>","text":"<p>A summary as a string of the information recorded.</p>"},{"location":"reference/agents/model_based_util/vi_solver/#olfactory_navigation.agents.model_based_util.vi_solver.SolverHistory.add","title":"<code>add(iteration_time, value_function_change, value_function)</code>","text":"<p>Function to add a step in the simulation history.</p> <p>Parameters:</p> Name Type Description Default <code>iteration_time</code> <code>float</code> <p>The time it took to run the iteration.</p> required <code>value_function_change</code> <code>float</code> <p>The change between the value function of this iteration and of the previous iteration.</p> required <code>value_function</code> <code>ValueFunction</code> <p>The value function resulting after a step of the solving process.</p> required Source code in <code>olfactory_navigation/agents/model_based_util/vi_solver.py</code> <pre><code>def add(self,\n        iteration_time: float,\n        value_function_change: float,\n        value_function: ValueFunction\n        ) -&gt; None:\n    '''\n    Function to add a step in the simulation history.\n\n    Parameters\n    ----------\n    iteration_time : float\n        The time it took to run the iteration.\n    value_function_change : float\n        The change between the value function of this iteration and of the previous iteration.\n    value_function : ValueFunction\n        The value function resulting after a step of the solving process.\n    '''\n    if self.tracking_level &gt;= 1:\n        self.iteration_times.append(float(iteration_time))\n        self.value_function_changes.append(float(value_function_change))\n\n    if self.tracking_level &gt;= 2:\n        self.value_functions.append(value_function if not value_function.is_on_gpu else value_function.to_cpu())\n</code></pre>"},{"location":"reference/agents/model_based_util/vi_solver/#olfactory_navigation.agents.model_based_util.vi_solver.SolverHistory.plot_changes","title":"<code>plot_changes()</code>","text":"<p>Function to plot the value function changes over the solving process.</p> Source code in <code>olfactory_navigation/agents/model_based_util/vi_solver.py</code> <pre><code>def plot_changes(self) -&gt; None:\n    '''\n    Function to plot the value function changes over the solving process.\n    '''\n    assert self.tracking_level &gt;= 1, \"To plot the change of the value function over time, use tracking level 1 or higher.\"\n\n    plt.title('Value function change over time')\n    plt.plot(np.arange(len(self.value_function_changes)), self.value_function_changes)\n    plt.xlabel('Iteration')\n    plt.ylabel('Value function change')\n    plt.show()\n</code></pre>"},{"location":"reference/agents/model_based_util/vi_solver/#olfactory_navigation.agents.model_based_util.vi_solver.solve","title":"<code>solve(model, horizon=100, initial_value_function=None, gamma=0.99, eps=1e-06, use_gpu=False, history_tracking_level=1, print_progress=True)</code>","text":"<p>Function to solve an MDP model using Value Iteration. If an initial value function is not provided, the value function will be initiated with the expected rewards.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model on which to run value iteration.</p> required <code>horizon</code> <code>int</code> <p>How many iterations to run the value iteration solver for.</p> <code>100</code> <code>initial_value_function</code> <code>ValueFunction</code> <p>An optional initial value function to kick-start the value iteration process.</p> <code>None</code> <code>gamma</code> <code>float</code> <p>The discount factor to value immediate rewards more than long term rewards. The learning rate is 1/gamma.</p> <code>0.99</code> <code>eps</code> <code>float</code> <p>The smallest allowed changed for the value function. Bellow the amound of change, the value function is considered converged and the value iteration process will end early.</p> <code>1e-6</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU with cupy array to accelerate solving.</p> <code>False</code> <code>history_tracking_level</code> <code>int</code> <p>How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)</p> <code>1</code> <code>print_progress</code> <code>bool</code> <p>Whether or not to print out the progress of the value iteration process.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>value_function</code> <code>ValueFunction</code> <p>The resulting value function solution to the model.</p> <code>history</code> <code>SolverHistory</code> <p>The tracking of the solution over time.</p> Source code in <code>olfactory_navigation/agents/model_based_util/vi_solver.py</code> <pre><code>def solve(model: Model,\n          horizon: int = 100,\n          initial_value_function: ValueFunction | None = None,\n          gamma: float = 0.99,\n          eps: float = 1e-6,\n          use_gpu: bool = False,\n          history_tracking_level: int = 1,\n          print_progress: bool = True\n          ) -&gt; tuple[ValueFunction, SolverHistory]:\n    '''\n    Function to solve an MDP model using Value Iteration.\n    If an initial value function is not provided, the value function will be initiated with the expected rewards.\n\n    Parameters\n    ----------\n    model : mdp.Model\n        The model on which to run value iteration.\n    horizon : int, default=100\n        How many iterations to run the value iteration solver for.\n    initial_value_function : ValueFunction, optional\n        An optional initial value function to kick-start the value iteration process.\n    gamma : float, default=0.99\n        The discount factor to value immediate rewards more than long term rewards.\n        The learning rate is 1/gamma.\n    eps : float, default=1e-6\n        The smallest allowed changed for the value function.\n        Bellow the amound of change, the value function is considered converged and the value iteration process will end early.\n    use_gpu : bool, default=False\n        Whether to use the GPU with cupy array to accelerate solving.\n    history_tracking_level : int, default=1\n        How thorough the tracking of the solving process should be. (0: Nothing; 1: Times and sizes of belief sets and value function; 2: The actual value functions and beliefs sets)\n    print_progress : bool, default=True\n        Whether or not to print out the progress of the value iteration process.\n\n    Returns\n    -------\n    value_function: ValueFunction\n        The resulting value function solution to the model.\n    history : SolverHistory\n        The tracking of the solution over time.\n    '''\n    # GPU support\n    if use_gpu:\n        assert gpu_support, \"GPU support is not enabled, Cupy might need to be installed...\"\n\n    xp = np if not use_gpu else cp\n    model = model if not use_gpu else model.gpu_model\n\n    # Value function initialization\n    if initial_value_function is None:\n        V = ValueFunction(model, model.expected_rewards_table.T, model.actions)\n    else:\n        V = initial_value_function.to_gpu() if use_gpu else initial_value_function\n    V_opt = xp.max(V.alpha_vector_array, axis=0)\n\n    # History tracking setup\n    solve_history = SolverHistory(tracking_level=history_tracking_level,\n                                  model=model,\n                                  gamma=gamma,\n                                  eps=eps,\n                                  initial_value_function=V)\n\n    # Computing max allowed change from epsilon and gamma parameters\n    max_allowed_change = eps * (gamma / (1-gamma))\n\n    iterator = trange(horizon) if print_progress else range(horizon)\n    for _ in iterator:\n        old_V_opt = V_opt\n\n        start = datetime.now()\n\n        # Computing the new alpha vectors\n        alpha_vectors = model.expected_rewards_table.T + (gamma * xp.einsum('sar,sar-&gt;as', model.reachable_probabilities, V_opt[model.reachable_states]))\n        V = ValueFunction(model, alpha_vectors, model.actions)\n\n        V_opt = xp.max(V.alpha_vector_array, axis=0)\n\n        # Change computation\n        max_change = xp.max(xp.abs(V_opt - old_V_opt))\n\n        # Tracking the history\n        iteration_time = (datetime.now() - start).total_seconds()\n        solve_history.add(iteration_time=iteration_time,\n                            value_function_change=max_change,\n                            value_function=V)\n\n        # Convergence check\n        if max_change &lt; max_allowed_change:\n            if print_progress:\n                iterator.close()\n            break\n\n    return V, solve_history\n</code></pre>"},{"location":"tutorials/agent_description/","title":"What is an Agent?","text":"<p>The concept of an agent within the olfactory navigation framework is a an abstract concept.</p> <p>Fundamentally, to create an agent, the user has to create a subclass of the generic Agent class. Along with this, the various functions need to be overwritten as needed. This article will describe the various components of the Agent class and how to make one for yourself with some examples.</p> <p>The various components can be seperated between the attributes and methods or functions. The functions can be grouped in the following categories training, testing, and general functions. As part of the testing function, the functions required to interact with the run_test() function.</p> <p>Table Of Content:</p> <ul> <li>Attributes</li> <li>Functions<ul> <li>Training</li> <li>Testing<ul> <li>State initialization</li> <li>Action choice</li> <li>State update</li> <li>Agent pruning</li> </ul> </li> <li>General<ul> <li>Save/load</li> <li>GPU support</li> </ul> </li> </ul> </li> </ul>"},{"location":"tutorials/agent_description/#attributes","title":"Attributes","text":"<p>The agent has a set of attributes by default. Here is a list of some important attributes:</p> <ul> <li>environment: The Environment the agent should be trained on.</li> <li>threshold: The olfactory sensitivity of the agent. A list of multiple threshold can also be set to represent the agent being able to smell different concentrations of odors.</li> <li>action_set: A list of the actions available to the agent. It should be an array of different action vectors.</li> </ul> <p>On top of these attributes, other ones are also present such as name, or action_labels which help with more general functions, they are not directly involved with the core functionality of the agent.</p> <p>Following this, other attributes can be defined within the init function. Those attribute can be of one of three categories:</p> <ul> <li>Static: Those attribute should be there to help within the functions of the agent. For example, we can imagine some conversion matrix the agent can use to update its state.</li> <li>Trainable: Those attribute typically should be set to None within the init and defined after the train() function has been run.</li> <li>Status: Those attributes are dynamic variables that will change over the course of the simulation. They should reprensent the status of the agent during the simulation (for example, where the agent believes he is in the space, or an internal clock, or even a memory).</li> </ul>"},{"location":"tutorials/agent_description/#functions","title":"Functions","text":""},{"location":"tutorials/agent_description/#training","title":"Training","text":"<p>Function: train() <sub>reference</sub></p> <p>For the training part, the concept of the agent is trained. We define the brain of the agent. It is optional to overwrite this function as we can imagine an agent that has some hard-coded behavior and therefore does not require training.</p>"},{"location":"tutorials/agent_description/#testing","title":"Testing","text":"<p>For the testing, the agent needs to be able to interact be interacted with from the run_test() function of the simulation module.</p> <p>For this the following functions need to be implemented:</p> <ol> <li>initialize_state(n) <sub>reference</sub></li> <li>choose_action() <sub>reference</sub></li> <li>update_state(observation, source_reached) <sub>reference</sub></li> <li>kill(simulations_to_kill) <sub>reference</sub></li> </ol>"},{"location":"tutorials/agent_description/#state-initialization","title":"State initialization","text":"<p>Function: initialize_state(n) <sub>reference</sub></p> <p>In this function, the way the initial state of an agent should be has to be implemented. For example, say the agent concept you are defining relies on a clock system, at this step, the clocks for the n agents would be initialized for example at zero. Another example is for the POMDP-based agents, the initial \"belief\" of the agent has to be set.</p> <p>Note: This step can be skipped with a skip_initialization parameter of the run_test() function that can be useful if want to initialize the agent in a particular manner compared to the default agent's initialization.</p>"},{"location":"tutorials/agent_description/#action-choice","title":"Action choice","text":"<p>Function: choose_action() <sub>reference</sub></p> <p>In the step of the simulation process, it is asked of the agent(s) to choose an action to make based on their internal state (clock or something else), hence why no parameter is being passed here.</p> <p>The action chosen should be a vector (or a list of vectors) with the first component of the vector being the olfactory layer to be querried; then the other components should be the displacements in each dimension of the environment. Note that, the layer component is not needed in the case the environment is not a layered environment. Then, the amount of dispacement compenents should also match the amount of physical dimensions of the environment.</p>"},{"location":"tutorials/agent_description/#state-update","title":"State update","text":"<p>Function: update_state(observation, source_reached) <sub>reference</sub></p> <p>Following the action of the agent being applied, an observation is returned to it along with a cue of whether or not it has found the source of the odor. The odor cue that is returned to the agent depends on the actual position of the agent relative to the odor source (which is unknown to him). The odor cue returned to the agent doesn't only depend on its physical position, it also depend on the time of the simulation. Unless specified otherwise using the time_shift parameter of the run_test() function, the time starts at zero for all of the agents. </p> <p>This function is therefore meant for the agent to update its internal state based on the observation it received. For example, if the agent's state is a clock measuring the amount of time since it last received an odor cue, if the agent receives an odor cue above its olfaction threshold, the clock would be reset to zero, else it would be incremented by one.</p>"},{"location":"tutorials/agent_description/#agent-pruning","title":"Agent pruning","text":"<p>Function: kill(simulations_to_kill) <sub>reference</sub></p> <p>When a agent reached the source, the simulation will not keep track if it anymore and will prune it's position its memory. This is done to speed up the simulation as more and more agents reach the source. The simulation therefore returns to agent which is to so the states of the agents that have reached the source can also be pruned.</p> <p>This is done by sending a boolean array of which agent's states are the be pruned/killed to the kill() function.</p>"},{"location":"tutorials/agent_description/#general","title":"General","text":""},{"location":"tutorials/agent_description/#saveload","title":"Save/load","text":"<p>The agent must be able to be saved to memory for reproducability's sake. Related functions:</p> <ul> <li>save() <sub>reference</sub></li> <li>load() <sub>reference</sub></li> </ul> <p>By default, the agent can be saved as a pickle file. But it is recommended to define your own save() and load() functions as a pickle file is a blackbox and may save too many attributes, so not very space efficient. For instance, for the agent to be re-used later, only the trainable variables are needed.</p>"},{"location":"tutorials/agent_description/#gpu-support","title":"GPU support","text":"<p>To speedup large operations, the arrays associated to the agent can be sent to the GPU for the operations to be performed there. Related functions:</p> <ul> <li>to_gpu() <sub>reference</sub></li> <li>to_cpu() <sub>reference</sub></li> </ul> <p>These functions are to be defined to send the various componenents to and from the gpu memory. If some components are not directly Numpy arrays but contain Numpy arrays, these components should be handled specifically by overwriting the to_gpu() function.</p> <p>By default, the to_cpu() function returns the instance of the agent before it was sent to GPU using the to_gpu() function. If a different behavior is expected, it can be defined explicitly by overwriting the to_cpu() function.</p>"},{"location":"tutorials/available_tests/","title":"What tests are available?","text":"<p>In this article, the various test setup that have been built to facilitate the testing of different performance aspects of an agent. All the tests that have been built upon the run_test() function which has been described in more detail in the \"How does a simulation work?\" tutorial. All these tests are part of the test_setups module.</p> <p>These tests include:</p> <ul> <li>All start test</li> <li>N start per cell</li> <li>Shape robustness test</li> <li>Scale robustness test</li> </ul>"},{"location":"tutorials/available_tests/#all-start-test","title":"All start test","text":"<p>Function: run_all_starts_test() <sub>reference</sub></p> <p>The \"all starts\" test allows to quick test all possible start positions of the agent in space. Since the environment has a start_probabilities attribute, we can use it to check all the positions where the probability is higher than zero. With this test, we can easily test if there are areas in space where the agent performs better than other areas.</p> <p>For example, in a 2-dimensional environment, we can plot the start positions that lead to a successful trajectory in blue and the rest in red:</p> <p></p>"},{"location":"tutorials/available_tests/#n-start-per-cell","title":"N start per cell","text":"<p>Function: run_n_by_cell_test() <sub>reference</sub></p> <p>In the case where the environment is too detailed and therefore would require too many points to test the whole starting area, we can divide the space in \"cells\" in which we same a number of points n at random to test the performances averaged over these cells. Another scenario where this test can become useful is also when we want a more statistically significant amount of trajectories to draw conclusions about the performance of an agent.</p> <p>For example, in a 2-dimensional environment, we can divide the space in a 3 by 26 grid of cells and draw 20 random starting points in each cells:</p> <p></p> <p>And over each cell we can average the amount of steps required to reach the source leading to the following heatmap:</p> <p></p>"},{"location":"tutorials/available_tests/#shape-robustness-test","title":"Shape robustness test","text":"<p>Function: test_shape_robustness() <sub>reference</sub></p> <p>This test is meant test the robustness of an agent to changes in the olfactory plume shape compared to the one it has been trained with. This test, by default, modifies the shape in the x and y direction by increments of 20%, from 20% the size to 200% the size. For each modified environment an \"All start test\" is run to evaluate the performance. This test compared to the ones defined previously return a list of SimulationHistory instances rather than a single one.</p> <p>When the test is done, the list of SimulationHistory instances can be analyzed with the analyse_shape_robustness() function. Following which a heat-map of the performances can be plot for each modifications.</p> <p></p>"},{"location":"tutorials/available_tests/#scale-robustness-test","title":"Scale robustness test","text":"<p>Function: test_scale_robustness() <sub>reference</sub></p> <p>This test works a bit in a similar fashion as the \"Shape robustness test\", as in, it modifies the environment and runs simulations with the \"All start test\" for a series of values. But in this scenario, instead of modifying the shape of the olfactory plume, we analyse the sampling of the olfactory navigation environment. We imagine the agent has been trained on a n by n environment, we then test its performance on a 10n by 10n environment and n/10 by n/10 environemnt. These environments therefore more or less granularity and detail while maintaining the same olfactory probabilities.</p> <p>By default, as for the previous test, the environment scale is modified by increments of 20% from 20% scale to 200% scale. And, after analyzing the list of SimulationHistory instance using the analyse_scale_robustness() function, we can plot the results as follows:</p> <p></p>"},{"location":"tutorials/simulation_process/","title":"How does a simulation work?","text":"<p>In this article, the run_test() function, used for simulating an olfactory problem, will be described in detail.</p>"},{"location":"tutorials/simulation_process/#process","title":"Process","text":"<p>The run_test() function works by, first, initialize the state of the agent. This initialization is made of initializing the positions of the n agents within the environment, and asking the agent to initialize it internal state (agent.initialize_state(n)).</p> <p>Then, the simulation loop starts. This loop goes on until the horizon is reached, or all the agents reached the source. Within this loop, first, it is asked of the agents to choose an action to take (agent.choose_action()). These actions are then used to move the positions of the agents in the physical space (environment.move()). From this new position of the agents, an observation is querried (environment.get_observation()). Using the new positions, it is also checked whether the agents have reached the source or not (environment.source_reached()). The observations and whether or not the agents reached the source is then fed back to the agent in order to update the internal state (agent.update_state()). And finally, the agents that have reached the source are pruned from the simulation by removing their positions from the list and asking the agent to prune those simulations (agent.kill()).</p> <p>Once the simulation process is over, a SimulationHistory instance is returned. This will be expanded upon in the \"Output\" section of this tutorial.</p>"},{"location":"tutorials/simulation_process/#diagram","title":"Diagram","text":"<p>We can see that the simulation process of the olfactory navigation is mostly an interaction between an agent and the environment it lives in. The simulation (run_test()) function simply works as an interface between the agent and its environment. In the diagram the actions performed by the agent are in blue while the one of the environment are in green. We can also note that the position of the agent is never sent to the agent, representing the fact the agent is unaware of it's relative position to the odor source.</p>"},{"location":"tutorials/simulation_process/#pseudocode","title":"Pseudocode","text":"<pre><code>1. agent.initialize_state(n)\n2. positions \u2190 environment.random_start_positions(n)\n3. for iteration \"t\" from \"time_shift\" to \"horizon\" do\n4.      actions \u2190 agent.choose_action()\n5.      positions \u2190 environment.move(positions, actions)\n6.      observations \u2190 environment.get_observations(positions)\n7.      source_reached \u2190 environment.source_reached(positions)\n8.      agent.update_state(observations, source_reached)\n9.      agent.kill(source_reached)\n10.     positions \u2190 positions[not source_reached]\n11.     if |positions| = 0 do\n12.         break\n13.     end if\n14. end for\n</code></pre>"},{"location":"tutorials/simulation_process/#parameters","title":"Parameters","text":"<p>Multiple things can be changed when running a test. All of this can be done through the means of parameters. The components that can be change when running a simulation will be listed here along with how they will affect the simulation itself.</p> Parameter Description n This parameter controls how many agents will be launched in the simulation at once. With this parameter, n positions will be needed and the agent will need to initialize n internal states. start_points This parameter controls the strarting positions of the agents in the environment. By default they are picked at random in according to the starting probability distribution of the environment. If this parameter is provided, however, it need to either be a single starting point that will be repeated n times, or n starting points. environment The environment in which the simulation will happen. By default, it is the environment the agent was trained on. But, if it is provided, this environment will be used instead to test the agent in different circumstances than the ones he has been trained in. time_shifts The environment are based on a time-series of olfactory data, therefore, by default, during the simulation, the olfactory at time t is querried and t is incremented at each loop of the simulation. But, this can be changed using the time_shifts parameter. This parameter allows for the time-slice t + time_shifts to be querried. time_shifts can also be a list of n time shifts for each agent. time_loop As stated above, the environment's olfactory data comes as a time-series, therefore, there are a limited amount of timestamps available. If the t + time_shifts becomes higher than the amount of timestamps available, we can either stop the simulation or start over from zero by using a modulo operator. This is what the time_loop controls, if enabled, the time always starts over at zero, else, the simulations end early. horizon This parameter controls how many loop iterations can happen as part of the simulation. By default, this is set to 1000. skip_initialization The first step of run_test() function is the initialization of the internal states of the agents. In some special case, we may want to initialize the agent's states in a custom way compared to the way defined in the agent.initialize_state() function, in such case the skip_initialization can be enabled to skip the agent initialization step."},{"location":"tutorials/simulation_process/#output","title":"Output","text":"<p>During the simulation process, the positions, actions and observations are recorded in a SimulationHistory instance and are returned at the end of the run_test() function.</p> <p>This object allows to compute statistics about the performance of the agent (summary), easily save the results to csv files (save()), and plot trajectories (plot()).</p>"},{"location":"tutorials/simulation_process/#summary","title":"Summary","text":"<p>The summary attribute is a string summarizing the performance metrics for the simulation process. The performance metrics that are considered are the following:</p> <ul> <li>Convergence: The percentage of agent that managed to reach the source before the horizon.</li> <li>Step count: The average amount of steps taken by the agents along the simulation.</li> <li>Extra steps: The average amount of extra steps compared to an optimal trajectory taken by the agents along the simulation. </li> <li>Discounted rewards: The average discounted rewards received by the agent. Knowing the agent receives a reward of zero if it doesnt find the source and one if it does. Based on a discount factor d, and a trajectory of l steps to reach the source, we have a discounted reward of d<sup>l</sup>. By default the discount factor is of 0.99.</li> <li>Tmin / T: The average of normalized metric computing how close a trajectory is to an optimal trajectory. This metric is computed by dividing the length of the optimal trajectory (Tmin) by the amount of steps taken(T).</li> </ul> <p>Note: The performance metrics are each displayed with their standard deviation, and both computed over all the trajectories or filtered to only the successful trajectories.</p>"},{"location":"tutorials/simulation_process/#trajectories-saving","title":"Trajectories saving","text":"<p>The save() function allows to record the results of a simulation in a readable .csv file. The information recorded are all the information need to reproduce the trajectory of all agents. This information can be summarized in a table by appending under one another all the trajectories. This table can be viewed as a list of Pandas DataFrame object by querrying the simulation_dfs attribute.</p> <p>A sample table of the trajectories on a 2 dimensional envrionment:</p> time y x dy dx o done 0 14 171 1 14 170 0 -1 3.245e-08 0 2 13 170 -1 0 0.0 0 ... ... ... ... ... ... ... 196 27 64 0 -1 -1.394e-07 1 0 15 139 ... ... ... ... ... ... ... <p>Additionally, in this table some extra columns are added giving information about the agent and the environment, then it also saves the horizon, the reward discount, and a column with the timestamps of the iterations to have statistics about the time required to run each iteration. The information saved for the agent and the environment are their name and save location (if it exists) along with some of their respective attributes that required for plotting. These attribute for environment include the amount of dimensions, the source position and radius, and the shape. Whereas, for the agent, it is the olfactory thresholds that are recorded.</p> <p>The sample shown above is of simulation on a 2 dimensonal environment. But simulations can be performed on higher dimensional environments. This would lead to more columns for the position and displacement to be available. In 3 dimensions, a z and dz would be added. And for n-dimensional environment it would be x1, x2, ..., xn and similarly for the dispacements. Additionally, a layered environment can also be considered, in which case, a layer column would be added to represent which layer of odor is querried at each timestamp.</p>"},{"location":"tutorials/simulation_process/#analysis-saving","title":"Analysis saving","text":"<p>An \"analysis\" table can also be built. This table summarizes the performance metrics described above for each of the agents and also computes the averages and standard deviations. This table is available as the analysis_df attribute.</p> <p>A sample table of the analysis of the trajectories on a 2 dimensional envrionment:</p> y x optimal_steps_count converged reached_horizon steps_taken discounted_rewards extra_steps t_min_over_t mean 0.803 0.196 277.078 0.344 206.044 0.63 standard_deviation 0.397 0.397 361.525 0.26 358.632 0.338 success_mean 1.0 0.0 100.388 0.428 29.478 0.767 success_standard_deviation 0.0 0.0 60.794 0.219 34.212 0.216 run_0 14.0 171.0 120.0 True False 196.0 0.139 76.0 0.612 ... ... ... ... ... ... ... ... ... ... <p>As for the summary attribute, all the performance metrics are computed both for the full set of trajectories and when the trajectories are filtered to the successful ones only.</p> <p>Note that if the analysis .csv file has not been generated or does not exists, it is always possible to regenerate it by loading a SimulationHistory object using the load_from_file() function.</p>"},{"location":"tutorials/simulation_process/#trajectory-plot","title":"Trajectory plot","text":"<p>The plot() function allows for one of the trajectories to be plot. It shows the path of the agent from the start point (green dot), and the observations it does along the way (blue dots). The source is marker with the red circle. If the agent querries odors at other layers, it will be marker with crosses of different colors.</p> <p></p> <p>Note: the plotting function only works with simulations of environments in 2 dimensions.</p>"},{"location":"tutorials/simulation_process/#going-further","title":"Going Further","text":"<p>Using this simulation function, some more predefined tests have been defined. Some tests are just a predefined way to choose the starting positions (run_all_starts_test(), or run_n_by_cell_test()), whereas some modify the environment entirely to test the robustness of the agent (test_shape_robustness(), or test_scale_robustness()).</p>"}]}